/*
 * Copyright 2003-2007, Regents of the University of Nebraska
 *
 *  Licensed under the University of Nebraska Open Academic License,
 *  Version 1.0 (the "License"); you may not use this file except in
 *  compliance with the License. The License must be provided with
 *  the distribution of this software; if the license is absent from
 *  the distribution, please report immediately to galileo@cse.unl.edu
 *  and indicate where you obtained this software.
 *
 *  You may also obtain a copy of the License at:
 *
 *      http://sofya.unl.edu/LICENSE-1.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */

package sofya.mutator.verifier;

import java.io.ByteArrayInputStream;
import java.io.IOException;

import org.apache.bcel.Repository;
import org.apache.bcel.classfile.*;

/**
 * Wrapper for BCEL's <code>JustIce</code> verifier.
 *
 * <p>This verifier has significant limitations. It is incomplete, and thus
 * will report verification failures on classes generated by the Sun
 * compiler, a behavior that has been observed so far on pass 3a. It also
 * does not report verification failures in a manner easily handled
 * programmatically, though it does produce understandable messages.
 * Finally, it cannot (efficiently) report the pass on which verification
 * failed if it is a verification pass that precedes the requested pass.</p>
 *
 * @author Alex Kinneer
 * @version 06/09/2006
 */
public final class JustIceVerifier implements Verifier {
    public JustIceVerifier() {
    }

    public void loadClass(JavaClass clazz) {
        Repository.removeClass(clazz.getClassName());
        Repository.addClass(clazz);
    }

    public void loadClass(String className, byte[] classBytes)
            throws VerifierException {
        ByteArrayInputStream bytes = new ByteArrayInputStream(classBytes);
        ClassParser clParser = new ClassParser(bytes, className);
        JavaClass clazz = null;

        try {
            clazz = clParser.parse();
        }
        catch (ClassFormatException e) {
            throw new VerifierException("Invalid Java class", e);
        }
        catch (IOException e) {
            throw new VerifierException("Could not read class", e);
        }

        loadClass(clazz);
    }

    public VerificationResult verify(String className, String methodName,
            String signature, Pass level) throws VerifierException {
        JavaClass clazz = null;
        try {
            clazz = Repository.lookupClass(className);
        }
        catch (ClassNotFoundException e) {
            throw new VerifierException("Could not find class", e);
        }

        org.apache.bcel.verifier.Verifier v =
            org.apache.bcel.verifier.VerifierFactory.getVerifier(className);
        v.flush();

        Method[] methods = clazz.getMethods();
        int i = 0;
        for ( ; i < methods.length; i++) {
            if (methods[i].getName().equals(methodName) &&
                    methods[i].getSignature().equals(signature)) {
                break;
            }
        }
        if (i == methods.length) {
            throw new VerifierException("Unable to verify: method not found " +
                "(" + methodName + signature + ")");
        }

        org.apache.bcel.verifier.VerificationResult result = null;

        switch (level.toInt()) {
        case Pass.IONE:
            result = v.doPass1();
            break;
        case Pass.ITWO:
            result = v.doPass2();
            break;
        case Pass.ITHREE_A:
            result = v.doPass3a(i);
            break;
        case Pass.ITHREE_B:
            result = v.doPass3b(i);
            break;
        }

        return new ResultDecorator(result, level);
    }

    public VerificationResult verify(String className, Pass level)
            throws VerifierException {
        org.apache.bcel.verifier.Verifier v =
            org.apache.bcel.verifier.VerifierFactory.getVerifier(className);
        v.flush();

        org.apache.bcel.verifier.VerificationResult result = null;

        switch (level.toInt()) {
        case Pass.IONE:
            result = v.doPass1();
            break;
        case Pass.ITWO:
        case Pass.ITHREE_A:
        case Pass.ITHREE_B:
            result = v.doPass2();
            level = Pass.TWO;
            break;
//         case Pass.ITHREE_B:
//             JavaClass clazz = Repository.lookupClass(className);
//             Method[] methods = clazz.getMethods();
//             for (int i = 0; i < methods.length; i++) {
//                 result = v.doPass3b(i);
//                 if (result.getStatus() != org.apache.bcel.verifier.
//                         VerificationResult.VERIFIED_OK) {
//                     return new ResultDecorator(result, level);
//                 }
//             }
//             break;
        }

        return new ResultDecorator(result, level);
    }

    /**
     * Decorates a BCEL VerificationResult as a Sofya mutator
     * VerificationResult.
     */
    private static class ResultDecorator implements VerificationResult {
        private org.apache.bcel.verifier.VerificationResult bcelResult;
        private Pass level;

        private ResultDecorator() {
        }

        ResultDecorator(org.apache.bcel.verifier.VerificationResult result,
                Pass level) {
            this.bcelResult = result;
        }

        public int getResult() {
            if (bcelResult.getStatus() ==
                    org.apache.bcel.verifier.VerificationResult.VERIFIED_OK) {
                return 0;
            }
            else {
                return 1;
            }
        }

        public String getMessage() {
            return bcelResult.getMessage();
        }

        public Pass getLevel() {
            return level;
        }
    }
}
