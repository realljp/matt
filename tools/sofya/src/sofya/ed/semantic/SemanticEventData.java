/*
 * Copyright 2003-2007, Regents of the University of Nebraska
 *
 *  Licensed under the University of Nebraska Open Academic License,
 *  Version 1.0 (the "License"); you may not use this file except in
 *  compliance with the License. The License must be provided with
 *  the distribution of this software; if the license is absent from
 *  the distribution, please report immediately to galileo@cse.unl.edu
 *  and indicate where you obtained this software.
 *
 *  You may also obtain a copy of the License at:
 *
 *      http://sofya.unl.edu/LICENSE-1.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */

package sofya.ed.semantic;

import java.util.Collection;
import java.util.Map;
import java.util.LinkedHashMap;
import java.util.Set;
import java.util.Iterator;
import java.io.DataInputStream;
import java.io.DataOutputStream;
import java.io.PrintStream;
import java.io.IOException;
import java.lang.ref.SoftReference;

import gnu.trove.THashMap;
import gnu.trove.THashSet;
import gnu.trove.TIntHashSet;
import gnu.trove.TIntArrayList;
import gnu.trove.TObjectIntHashMap;
import gnu.trove.TIntObjectHashMap;
import gnu.trove.TIntObjectIterator;
import gnu.trove.TIntIterator;

/**
 * Contains information generated by the instrumentor which is necessary for
 * the semantic event dispatcher to operate.
 *
 * <p>This class will contain a string table and a compiled version of
 * the module description, and other information as needed.</p>
 *
 * @author Alex Kinneer
 * @version 01/11/2007
 */
@SuppressWarnings("unchecked")
public class SemanticEventData {
    /** The global name associated with the entire suite from
        which this event data object was constructed. */
    private String suiteName;

    /** Maps all of the active event specifications in this suite
        by their keys. */
    private Map<Object, EventSpecification> specs =
        new LinkedHashMap<Object, EventSpecification>();
    
    /** Holds a memory-sensitive reference to the array of active event
        specifications in this suite. An array is retrieved by some
        consumers to maximize efficiency, and we want to avoid reconstructing
        it for each consumer. */
    private SoftReference<EventSpecification[]> cachedSpecArray =
        new SoftReference<EventSpecification[]>(null);
    
    /** String table generated by the instrumentor. */
    private TIntObjectHashMap stringTable = new TIntObjectHashMap();
    /** Reverse string table, used to prevent redundant entries. This table
        is not serialized, though it is recovered during deserialization. */
    private TObjectIntHashMap revStringTable = new TObjectIntHashMap();
    /** Next available string index. */
    private int nextStringIndex = 0;
    
    /** Records the names of call interceptor methods added by
        the instrumentor. */
    private TIntObjectHashMap callInterceptors = new TIntObjectHashMap();
    
    /** Records the names of field interceptor methods added by
        the instrumentor. */
    private Map<Object, Object> fieldInterceptors = new THashMap();

    /** Flag indicating whether instrumentation probes were logged. */
    private boolean probesLogged = false;
    /** Set of probe IDs that are free; A probe ID may be freed after
        a probe is removed adaptively, and reclaiming those IDs will
        help avoid overflow. */
    private TIntArrayList freeProbeIds;
    /** Next probe ID available to be assigned, if there are currently
        no freed probe IDs. Used when adding new probes adaptively. */
    private int nextFreeProbeId;

    /** Table mapping Sofya event types to the data structures recording
        the location of all probes for that event type. */
    private TIntObjectHashMap probeTable;

    SemanticEventData() {
        setSuiteName("default");
    }
    
    SemanticEventData(String suiteName) {
        setSuiteName(suiteName);
    }
    
    /**
     * Gets the name associated with the suite of event specifications
     * represented by this data object.
     * 
     * @return The name associated with this suite of event specifications.
     */
    public String getSuiteName() {
        return suiteName;
    }
    
    /**
     * Sets the name associated with the suite of event specifications
     * represented by this data object.
     * 
     * @param name The name to be associated with this suite of
     * specifications.
     */
    void setSuiteName(String name) {
        this.suiteName = name;
    }
    
    /**
     * Gets the number of event specifications in this suite.
     * 
     * @return The number of event specifications contained in this suite.
     */
    public int getEventSpecificationCount() {
        return specs.size();
    }
    
    /**
     * Gets an event specification by its key.
     * 
     * @param key Key used to identify the event specification to retrieve.
     * 
     * @return The event specification associated with the given key.
     */
    public EventSpecification getEventSpecification(String key) {
        return specs.get(key);
    }
    
    /**
     * Gets all of the event specifications in the suite contained in
     * this data object.
     * 
     * @return A shallow reference to the collection of event specifications
     * constituting the suite contained by this data object.
     */
    Collection<EventSpecification> getEventSpecifications() {
        return specs.values();
    }
    
    /**
     * Gets all of the event specifications in the suite contained in this
     * data object, as an array for maximum efficiency.
     * 
     * <p>The result of this call may be cached to speed up future queries
     * for shared references. However, if no other object holds a reference
     * to the array, the result of this method is not guaranteed to be
     * the same array on subsequent calls, even when the <code>shared</code>
     * flag is true.</p>
     * 
     * @param shared Flag indicating whether the return value of this
     * method is permitted to be an array that might be shared with
     * other callers of this method.
     * 
     * @return An array of the event specifications in the suite contained
     * in this data object.
     */
    public EventSpecification[] getEventSpecificationsArray(boolean shared) {
        EventSpecification[] specsArray;
        
        if (!shared || ((specsArray = cachedSpecArray.get()) == null)) {
            int size = specs.size();
            specsArray = new EventSpecification[size];
            
            Iterator<EventSpecification> specIter =
                specs.values().iterator();
            for (int i = 0; i < size; i++) {
                specsArray[i] = specIter.next();
            }
            
            if (shared) {
                cachedSpecArray =
                    new SoftReference<EventSpecification[]>(specsArray);
            }
        }
        
        
        return specsArray;
    }

    /**
     * Adds a new event specification to the suite contained by this
     * data object.
     * 
     * @param eventSpec Event specification to be added.
     * 
     * @param failOnOverwrite Flag indicating whether to fail if the
     * key for the added event specification conflicts with a key for
     * an existing event specification.
     */
    void addEventSpecification(EventSpecification eventSpec,
            boolean failOnOverwrite) {
        String key = eventSpec.getKey();
        if (failOnOverwrite && specs.containsKey(key)) {
            throw new IllegalStateException("Event specification key " +
                "already used");
        }
        specs.put(key, eventSpec);
    }
    
    /**
     * Records the name of a call interceptor method added to a given class.
     *
     * @param className Name of the class to which the call interceptor
     * was added.
     * @param interceptorName Name of the added call interceptor method.
     */
    void recordCallInterceptor(String className, String interceptorName) {
        int classIndex = addString(className);

        TIntHashSet names;
        if (callInterceptors.containsKey(classIndex)) {
            names = (TIntHashSet) callInterceptors.get(classIndex);
        }
        else {
            names = new TIntHashSet();
            callInterceptors.put(classIndex, names);
        }

        names.add(addString(interceptorName));
    }

    /**
     * Gets the names of all of the call interceptor methods added by the
     * instrumentor.
     *
     * @return A map from class names to sets containing the names of
     * the inserted call interceptors.
     */
    @SuppressWarnings("unchecked")
    public Map<Object, Object> getCallInterceptors() {
        Map<Object, Object> classes = new THashMap();

        int clCount = callInterceptors.size();
        TIntObjectIterator clIter = callInterceptors.iterator();
        for (int i = clCount; i-- > 0; ) {
            clIter.advance();
            int classIndex = clIter.key();
            TIntHashSet names = (TIntHashSet) clIter.value();

            Set<Object> methods = new THashSet();
            int nameCount = names.size();
            TIntIterator namesIter = names.iterator();
            for (int j = nameCount; j-- > 0; ) {
                methods.add(getString(namesIter.next()));
            }

            classes.put(getString(classIndex), methods);
        }

        return classes;
    }
    
    /**
     * Records information about the field interceptor methods added
     * to a given class.
     *
     * @param className Name of the class to which the field interceptor
     * methods were added.
     * @param icptData Field interceptor data object containing information
     * about the interceptor methods added by the instrumentor.
     */
    void recordFieldInterceptors(String className,
            FieldInterceptorData icptData) {
        fieldInterceptors.put(className, icptData);
    }
    
    /**
     * Gets information about the field interceptor methods added by the
     * instrumentor to a given class.
     * 
     * @param className Name of the class for which to retrieve field
     * interceptor information.
     *
     * @return A data structure containing information about the field
     * interceptor methods added by the instrumentor.
     */
    FieldInterceptorData getFieldInterceptors(String className) {
        return (FieldInterceptorData) fieldInterceptors.get(className);
    }

    /**
     * Adds a string to the string table, if it is not already there.
     *
     * @param str String to be added to the string table.
     *
     * @return The index in the string table of the added string, or
     * the index previously allocated if the string is already in
     * the string table.
     */
    int addString(String str) {
        if (revStringTable.containsKey(str)) {
            return revStringTable.get(str);
        }

        int index = nextStringIndex++;
        stringTable.put(index, str);
        revStringTable.put(str, index);

        return index;
    }

    /**
     * Gets a string from the string table.
     *
     * @param index Index to the desired string in the string table.
     *
     * @return The string corresponding to the given index.
     */
    public String getString(int index) {
        return (String) stringTable.get(index);
    }

    /**
     * Gets a copy of the full string table.
     *
     * @return The complete string table. Changes to this array will not
     * be reflected internally.
     */
    public String[] getStringTable() {
        int size = stringTable.size();
        String[] table = new String[size];

        TIntObjectIterator it = stringTable.iterator();
        for (int i = size; i-- > 0; ) {
            it.advance();
            table[it.key()] = (String) it.value();
        }

        return table;
    }

    /**
     * Gets the reverse string table mapping strings to indices.
     */
    TObjectIntHashMap getReverseStringTable() {
        return revStringTable;
    }

    void setProbesLogged(boolean logged) {
        this.probesLogged = logged;
    }

    boolean areProbesLogged() {
        return probesLogged;
    }

    void setProbeIdFreeList(TIntArrayList freeIds) {
        this.freeProbeIds = freeIds;
    }

    TIntArrayList getProbeIdFreeList() {
        return freeProbeIds;
    }

    void setNextFreeProbeId(int nextId) {
        this.nextFreeProbeId = nextId;
    }

    int getNextFreeProbeId() {
        return nextFreeProbeId;
    }

    void setProbeTable(TIntObjectHashMap probeTable) {
        this.probeTable = probeTable;
    }

    TIntObjectHashMap getProbeTable() {
        return probeTable;
    }
    
    static final void warnKeyNotAdaptive(PrintStream out,
            String key) {
        out.println("WARNING: Key \"" + key + "\" does not reference an " +
            "adaptive event specification");
    }

    void serialize(DataOutputStream out) throws IOException {
        out.writeUTF(suiteName);
        
        int size = stringTable.size();
        String[] strTableArr = new String[size];
        TIntObjectIterator strIter = stringTable.iterator();
        for (int i = size; i-- > 0; ) {
            strIter.advance();
            strTableArr[strIter.key()] = (String) strIter.value();
        }

        int tableSize = strTableArr.length;
        out.writeInt(tableSize);
        for (int i = 0; i < tableSize; i++) {
            out.writeUTF(strTableArr[i]);
        }

        serializeInterceptors(out);

        out.writeBoolean(probesLogged);
        if (probesLogged) {
            out.writeInt(nextFreeProbeId);

            int idCount = freeProbeIds.size();
            out.writeInt(idCount);
            for (int i = 0; i < idCount; i++) {
                out.writeInt(freeProbeIds.getQuick(i));
            }

            int keyCnt = probeTable.size();
            TIntObjectIterator probeIter = probeTable.iterator();
            out.writeInt(keyCnt);
            for (int i = keyCnt; i-- > 0; ) {
                probeIter.advance();
                out.writeInt(probeIter.key());
                ((ProbeLocationTree) probeIter.value()).serialize(out);
            }
        }
        
        int specCount = specs.size();
        Iterator<EventSpecification> specIter = specs.values().iterator();
        out.writeInt(specCount);
        for (int i = specCount; i-- > 0; ) {
            EventSpecification eventSpec = specIter.next();
            String specClassName = eventSpec.getClass().getName();
            out.writeUTF(specClassName);
            eventSpec.serialize(out);
        }
        
        int clCount = fieldInterceptors.size();
        out.writeInt(clCount);
        Iterator<Object> clIter = fieldInterceptors.keySet().iterator();
        for (int i = clCount; i-- > 0; ) {
            String clName = (String) clIter.next();
            out.writeUTF(clName);
            
            FieldInterceptorData icptData =
                (FieldInterceptorData) fieldInterceptors.get(clName);
            icptData.serialize(out);
        }
    }

    static SemanticEventData deserialize(DataInputStream in)
            throws IOException {
        SemanticEventData data = new SemanticEventData(in.readUTF());

        int strTableLength = in.readInt();
        for (int i = 0; i < strTableLength; i++) {
            data.addString(in.readUTF());
        }

        data.deserializeInterceptors(in);

        data.probesLogged = in.readBoolean();
        if (data.probesLogged) {
            data.nextFreeProbeId = in.readInt();

            int idCount = in.readInt();
            data.freeProbeIds = new TIntArrayList(idCount);
            for (int i = 0; i < idCount; i++) {
                data.freeProbeIds.add(in.readInt());
            }

            data.probeTable = new TIntObjectHashMap();
            int keyCnt = in.readInt();
            for (int i = keyCnt; i-- > 0; ) {
                data.probeTable.put(in.readInt(),
                    ProbeLocationTree.deserialize(in));
            }
        }
        
        int specCount = in.readInt();
        for (int i = specCount; i-- > 0; ) {
            String specClassName = in.readUTF();
            EventSpecification eventSpec = null;
    
            try {
                Class specClass = Class.forName(specClassName);
                eventSpec = (EventSpecification) specClass.newInstance();
            }
            catch (ClassNotFoundException e) {
                IOException ioe = new IOException();
                ioe.initCause(e);
                throw ioe;
            }
            catch (InstantiationException e) {
                IOException ioe = new IOException();
                ioe.initCause(e);
                throw ioe;
            }
            catch (IllegalAccessException e) {
                IOException ioe = new IOException();
                ioe.initCause(e);
                throw ioe;
            }
    
            eventSpec.deserialize(in);
            
            data.addEventSpecification(eventSpec, false);
        }
        
        int fldIcptClassCount = in.readInt();
        for (int i = fldIcptClassCount; i-- > 0; ) {
            String clName = in.readUTF();
            data.fieldInterceptors.put(clName,
                FieldInterceptorData.deserialize(in));
        }

        return data;
    }

    /**
     * Serializes the interceptor data to a stream.
     *
     * @param out Stream to which the interceptor data will be
     * serialized.
     */
    void serializeInterceptors(DataOutputStream out) throws IOException {
        int clCount = callInterceptors.size();
        out.writeInt(clCount);

        TIntObjectIterator clIter = callInterceptors.iterator();
        for (int i = clCount; i-- > 0; ) {
            clIter.advance();
            int classIndex = clIter.key();
            TIntHashSet names = (TIntHashSet) clIter.value();
            out.writeInt(classIndex);

            int nameCount = names.size();
            out.writeInt(nameCount);

            TIntIterator namesIter = names.iterator();
            for (int j = nameCount; j-- > 0; ) {
                out.writeInt(namesIter.next());
            }
        }
    }

    /**
     * Deserializes interceptor data from a stream.
     *
     * @param in Stream from which to deserialize the interceptor data.
     */
    void deserializeInterceptors(DataInputStream in) throws IOException {
        callInterceptors = new TIntObjectHashMap();

        int clCount = in.readInt();
        for (int i = 0; i < clCount; i++) {
            int classIndex = in.readInt();
            int nameCount = in.readInt();

            TIntHashSet names = new TIntHashSet();
            callInterceptors.put(classIndex, names);

            for (int j = 0; j < nameCount; j++) {
                names.add(in.readInt());
            }
        }
    }
}
