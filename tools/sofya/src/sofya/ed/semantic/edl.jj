/*
 * Copyright 2003-2007, Regents of the University of Nebraska
 *
 *  Licensed under the University of Nebraska Open Academic License,
 *  Version 1.0 (the "License"); you may not use this file except in
 *  compliance with the License. The License must be provided with
 *  the distribution of this software; if the license is absent from
 *  the distribution, please report immediately to galileo@cse.unl.edu
 *  and indicate where you obtained this software.
 *
 *  You may also obtain a copy of the License at:
 *
 *      http://sofya.unl.edu/LICENSE-1.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */

/* JavaCC grammar file for specifying the current EDL input language.
 */

options {
    JAVA_UNICODE_ESCAPE = true;
    STATIC = false;
    JDK_VERSION = "1.5";
    //DEBUG_TOKEN_MANAGER = true;
    //DEBUG_PARSER = true;
    //DEBUG_LOOKAHEAD = true;
}

PARSER_BEGIN(EDLParser)
/*
 * Copyright 2003-2007, Regents of the University of Nebraska
 *
 *  Licensed under the University of Nebraska Open Academic License,
 *  Version 1.0 (the "License"); you may not use this file except in
 *  compliance with the License. The License must be provided with
 *  the distribution of this software; if the license is absent from
 *  the distribution, please report immediately to galileo@cse.unl.edu
 *  and indicate where you obtained this software.
 *
 *  You may also obtain a copy of the License at:
 *
 *      http://sofya.unl.edu/LICENSE-1.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */

package sofya.ed.semantic;

import java.io.Reader;
import java.io.FileReader;
import java.io.IOException;
import java.util.Map;
import java.util.HashMap;
import java.util.Set;
import java.util.HashSet;
import java.util.List;
import java.util.ArrayList;

import org.apache.bcel.generic.ArrayType;
import org.apache.bcel.generic.Type;
import org.apache.bcel.generic.ReferenceType;
import org.apache.bcel.generic.ObjectType;

import sofya.base.Handler;
import sofya.base.ProgramUnit;
import sofya.ed.semantic.SemanticConstants;
import sofya.ed.semantic.EventSpecification.ArrayElementType;
import sofya.ed.semantic.EventSpecification.ArrayElementBounds;
import sofya.ed.semantic.EventSpecification.CallType;
import sofya.ed.semantic.EventSpecification.FieldType;
import sofya.ed.semantic.EventSpecification.MonitorType;
import sofya.ed.semantic.EventSpecification.MethodAction;
import sofya.ed.semantic.EDLSpecification.*;

/* Implementation note: type alias substitutions can occur at the
   following places:
       - global array element bounds
       - array element bounds event
       - argument types in method selection expressions
       - class names in event specifications and method selection expressions
 */

/**
 * Parses event description language (EDL) files.
 *
 * <p>The parser constructs a corresponding abstract data type that is used
 * to control the instrumentor and event dispatcher to collect the
 * observations of the specified events.</p>
 *
 * <p>The underlying parser engine is generated by JavaCC.</p>
 *
 * @author Alex Kinneer
 * @version 10/04/2007
 */
@SuppressWarnings("unused")
public class EDLParser {
	/** The type alias table, containing mappings for shorthand type names
	    defined in <code>Preamble Type-name:</code> declarations. */
    private final Map<String, Type> typeNames = new HashMap<String, Type>();


	/** The name of the file currently being parsed. */
    private String curFile;
    
    /** Stack of files currently open for parsing, but waiting for a
        return from an &quot;<code>@import</code>&quot;ed file. */
    private final List<LexerStream> parseStack = new ArrayList<LexerStream>(4);
    
    /** Set of open file names, for detecting circular imports. */
    private final Set<String> openFiles = new HashSet<String>();


	/** The semantic event data object that will record the specification
		ADT's parsed from the EDL file; a new instance will be created on
		each call to the parser entry point. */
    private SemanticEventData semEventData;
    
    /** Data structure recording globally scoped EDL declarations, which
        are declared in the <code>EDLSuite</code> section and apply to
        all <code>Observables</code> sections, including those that
        are imported. */
    private GlobalConstraints globalConstraints;
    
    /** The event specification ADT currently being constructed by the
        parser; each <code>Observables</code> section results in a new
        instance of this type (a single global variable is safe because
        parsing of one section must fully complete before parsing can
        begin on another. */
    private EDLSpecification edlSpec;


    // Values that are potentially modified per event specification in an
    // Observables section
    
    /** The rank (or precedence) of the current event specification. This
        is incremented linearly per each event specification parsed in
        the Observables section. It is also incremented by location
        constraints, to enforce precedence resolution of conflicting
        constraints across multiple event specifications. */
    private int eventRank = 1;
    
    /** Flag indicating whether the current event specification is selecting
        or excluding the particular event (under the given constraints,
        if any). */
    private boolean inclusion = false;


	// The following fields are global to avoid the need to create
	// extremely short lived objects simply to return multiple values
	// from a production. They should always be consumed before
	// entering another production that potentially overwrites them.
	
    /** Class name parsed from a method selection expression. */
    private String descClassName;
    
    /** Method name parsed from a method selection expression,
    	if applicable. */
    private String descMethodName;


	/** Constant representing the character that is used for
	    wildcard selection. */
    public static final String WILDCARD = "*";

	/** Compile time flag to control whether the parser emits a trace
	    of its EDL matching; possibly useful for debugging. This is
	    slightly higher level than the JavaCC provided tracing of
	    grammar productions and or lexer processing, which must be
	    enabled with the appropriate JavaCC grammar options. */
    private static final boolean DEBUG = false;

    /**
     * Simple data structure used to record an active parse of an EDL file
     * in the EDL import stack.
     */
    private static final class LexerStream {
        /** Name of the file being parsed. */
        final String fileName;

		/** The JavaCC input stream attached to the file being parsed. */
        final JavaCharStream stream;
        // The type may have to be adjusted if the grammar options are
        // modified to change the type of input that is handled

        private LexerStream() {
            throw new AssertionError("Illegal constructor");
        }

        LexerStream(String fileName, JavaCharStream stream) {
            this.fileName = fileName;
            this.stream = stream;
        }
    }

	/**
	 * Simple data structure to mark off a subsection of the token chain
	 * for special handling.
	 */
    private static final class TokenList {
        public final Token head;
        public final Token tail;

        private TokenList() {
            throw new AssertionError("Illegal constructor");
        }

        TokenList(Token head, Token tail) {
            this.head = head;
            this.tail = tail;
        }
    }

    private EDLParser() {
        throw new AssertionError("Illegal constructor");
    }

	/**
	 * Constructs a parser that is prepared to parse from the given file.
	 */
    public EDLParser(String fileName) throws IOException {
        this(new FileReader(fileName));
        curFile = fileName;
        openFiles.add(fileName);
    }
    
    /**
     * Constructs a parser to parse from a provided stream associated
     * with the given file.
     *
     * @param fileName The name of the file to parse, which should be the
     *     same file from which <code>input</code> is reading.
     * @param input The stream attached to the file given by
     *     <code>fileName</code>.
     */
    public EDLParser(String fileName, Reader input) throws IOException {
   		this(input);
   		curFile = fileName;
   		openFiles.add(fileName);
    }
    
    /**
     * Constructs a parser to parse from a provided stream associated
     * with the given file, merging the results into an existing
     * {@link SemanticEventData} object.
     *
     * <p>NOTE: If the parser is constructed in this manner, it should
     * be invoked using {@link #importEdlUnit(boolean)} as the root
     * production with the parameter value <code>true</code>, or a
     * new <code>SemanticEventData</code> object will be constructed.</p>
     *
     * @param fileName The name of the file to parse, which should be the
     *     same file from which <code>input</code> is reading.
     * @param input The stream attached to the file given by
     *     <code>fileName</code>.
     * @param mergeEventData The {@link SemanticEventData} object into
     *     which the parsed EDL specification will be merged.
     * @param priorGC The existing global constraints extracted from the
     *     the {@link SemanticEventData} into which the current EDL
     *     will be merged.
     */
    EDLParser(String fileName, Reader input, SemanticEventData mergeEventData,
    		GlobalConstraints priorGC) throws IOException {
		this(fileName, input);
		this.semEventData = mergeEventData;
		this.globalConstraints = priorGC;
	}

	/**
	 * Entry point for testing.
	 */
    public static void main(String[] argv) throws IOException, Exception {
        EDLParser parser = new EDLParser(argv[0]);

        try {
            SemanticEventData sed = parser.edlUnit();
        }
        catch (ParseException e) {
            if (DEBUG) {
                e.printStackTrace();
            }
            else {
                System.err.println(e.getMessage());
            }
            System.err.println("Encountered errors during parse.");
        }
    }

    /**
     * Combines a sequence of tokens (inclusive) into a string.
     */
    private final String tokensToString(Token start, Token end) {
        StringBuilder str = new StringBuilder();

        for (Token t = start; true; t = t.next) {
            str.append(t.image);
            if (t == end) break;
        }

        return str.toString();
    }

	/**
	 * Combines a list of tokens into a string.
	 *
	 * @return A <code>StringBuilder</code> containing the result of
	 *     appending the sequence of tokens together.
	 *     A <code>StringBuilder</code> is provided to enable the caller
	 *     to efficiently make additional modifications to the result.
	 */
    private final StringBuilder tokensToString(TokenList tokens) {
        StringBuilder str = new StringBuilder();

        for (Token t = tokens.head; true; t = t.next) {
            str.append(t.image);
            if (t == tokens.tail) break;
        }

        return str;
    }

	/**
	 * Constructs a string from the subset of tokens in a token list that
	 * are most likely to correspond to a qualified class name.
	 *
	 * <p>This method is designed with the expectation that the input
	 * token list will be of the pattern:</p>
	 * <pre>
	 *     javaId ("." javaId)*
	 * </pre>
	 * <p>It will ignore the final '<code>"." javaId</code>',
	 * on the assumption that the final component is likely to be a
	 * field or method name. It is up to the caller to further modify
	 * the returned string based on whether that assumption is correct.</p>
	 *
	 * @param tokens List of tokens, expected to match a pattern of the
	 *     form <code>javaId ("." javaId)*)</code>.
	 *
	 * @return A <code>StringBuilder</code> containing the result of
	 *     appending the sequence of tokens together as described.
	 *     A <code>StringBuilder</code> is provided to enable the caller
	 *     to efficiently make additional modifications to the result.
	 */
    private final StringBuilder classTokensToString(TokenList tokens) {
        StringBuilder str = new StringBuilder();
        for (Token t = tokens.head; t.next != tokens.tail; t = t.next) {
            str.append(t.image);
        }
        return str;
    }

    /**
     * Processes a token list to construct a qualified class name string
     * in the format expected by {@link EDLSpecification} event request
     * methods.
     *
     * <p>
     * Post-conditions: The parser variable <code>descClassName</code>
     *     will be set to a new value. No guarantees are made about
     *     any other parser variables.
     * </p>
     *
     * @param nameSpec List of tokens from which the class name will be
     *     constructed.
     * @param isTotalWild Flag that signifies whether the parser rule
     *     determined that the base class name is a wildcard.
     * @param isPkgWild Flag that signifies whether the parser rule
     *     determined that some package qualification is available,
     *     but that the specific class name is a wildcard.
     */
    private final void processClassExpr(TokenList nameSpec,
            boolean isTotalWild, boolean isPkgWild) {
        if (isTotalWild) {
            descClassName = WILDCARD;
        }
        else {
            StringBuilder klass = tokensToString(nameSpec);

            if (isPkgWild) {
                klass.append(".");
                klass.append(WILDCARD);
                descClassName = klass.toString();
            }
            else {
                descClassName = klass.toString();
                Type typeSub = typeNames.get(descClassName);
                if (typeSub != null) {
                    descClassName = typeSub.toString();
                }
            }
        }
    }

    /**
     * Processes a token list to construct the qualified class name, and
     * method name, strings in the format expected by {@link EDLSpecification}
     * event request methods.
     *
     * <p>
     * Post-conditions: The parser variables <code>descClassName</code>
     *     and <code>descMethodName</code> will be set to new values.
     *     No guarantees are made about any other parser variables.
     * </p>
     *
     * @param nameSpec List of tokens from which the class and method
     *     names will be constructed.
     * @param classIsWild Flag that signifies whether the parser rule
     *     determined that the class name is a wildcard.
     * @param methodIsWild Flag that signifies whether the parser rule
     *     determined that the method name is a wildcard.
     *
     * @throws ParseException If it is determined that the class name is
     *     not a wildcard, but no method name is available.
     */
    private final void processClassAndMethodExpr(TokenList nameSpec,
            boolean classIsWild, boolean methodIsWild) throws ParseException {
        if (classIsWild) {
            descClassName = WILDCARD;
            descMethodName = WILDCARD;
        }
        else {
            if (methodIsWild) {
                descClassName = tokensToString(nameSpec).toString();
                descMethodName = WILDCARD;
            }
            else {
                if (nameSpec.head == nameSpec.tail) {
                    throw new ParseException("Missing method name at line " +
                        nameSpec.head.endLine + ", column " +
                        (nameSpec.head.endColumn + 1));
                }

                descClassName = classTokensToString(nameSpec).toString();
                descMethodName = nameSpec.tail.image;
            }

            Type typeSub = typeNames.get(descClassName);
            if (typeSub != null) {
                descClassName = typeSub.toString();
            }
        }
    }

    /**
     * Processes a token list to construct the qualified class and field
     * name string in the format expected by {@link EDLSpecification}
     * event request methods.
     *
     * @param nameSpec List of tokens from which the class and field
     *     name string will be constructed.
     * @param fieldIsWild Flag that signifies whether the parser rule
     *     determined that the field name is a wildcard.
     *
     * @return A string representing the combined qualified class and
     *     field name constructed from the token list.
     *
     * @throws ParseException If it is determined that the class name is
     *     not a wildcard, but no field name is available.
     */
    private final String processFieldExpr(TokenList nameSpec,
            boolean fieldIsWild) throws ParseException {
        StringBuilder klass;
        String fieldStr = null;

        if (fieldIsWild) {
            klass = tokensToString(nameSpec);
            fieldStr = WILDCARD;
        }
        else {
            if (nameSpec.head == nameSpec.tail) {
                throw new ParseException("Missing field name at line " +
                    nameSpec.head.endLine + ", column " +
                    (nameSpec.head.endColumn + 1));
            }

            klass = classTokensToString(nameSpec);
            fieldStr = nameSpec.tail.image;
        }

        Type typeSub = typeNames.get(klass.toString());
        if (typeSub != null) {
            klass = new StringBuilder(typeSub.toString());
        }

        return klass.append(".").append(fieldStr).toString();
    }

    /**
     * Utility method to construct an {@link ArrayElementBounds} object
     * required by associated {@link EDLSpecification} event request
     * method.
     *
     * @param javaType The element type to which the bounds will apply.
     * @param minTok The lexer token containing the minimum bound; the
     *     lexer should guarantee that the format is parsable as a
     *     numeric value.
     * @param maxTok The lexer token containing the maximum bound; the
     *     lexer should guaranteed that the format is parsable as a
     *     numeric value.
     *
     * @return The {@link ArrayElementBounds} object encapsulating the
     *     parsed bounds information.
     */
    private final ArrayElementBounds processArrayElementBounds(Type javaType,
            Token minTok, Token maxTok) {
        ArrayElementBounds bounds = new ArrayElementBounds(javaType);
        try {
            if (minTok != null) {
                bounds.min = Integer.parseInt(minTok.image);
            }
            if (maxTok != null) {
                bounds.max = Integer.parseInt(maxTok.image);
            }
        }
        catch (NumberFormatException e) {
            // Should not happen -- lexer should enforce valid input
            throw new AssertionError("Lexer error: <UINT> permitted invalid " +
                "numeric input");
        }
        return bounds;
    }
    
    /**
     * Utility method to remove the double quotes from a string literal
     * token returned by the lexer.
     *
     * <p>Once the string is in memory, the double quotes are no longer
     * needed to delineate the start and end of the string.</p>
     */
    private final String stripQuotes(Token stringLiteralTok) {
    	return stringLiteralTok.image.substring(1,
    		stringLiteralTok.image.length() - 1);
    }
}

PARSER_END(EDLParser)


//****************************************
// Lexer
//****************************************

TOKEN_MGR_DECLS :
{
    private int anyStringCount = 0;
}

// White space
<*> SKIP :
{
    < WHITESPACE: " " | "\t" | "\n" | "\r" | "\f" >
}

// Single line comment
<*> SKIP :
{
    < SINGLE_LINE_COMMENT: "//" (~["\n", "\r"])* ("\n" | "\r" | "\r\n")? >
}

// Core EDL keywords
TOKEN :
{
    < IMPORT:         "@import" >
  | < BEGIN:          "begin" >
  | < END:            "end" >
  | < EDLSUITE:       "EDLSuite" > { anyStringCount++; } : PERM_WILD_STRING
  | < OBSERVABLES:    "Observables" > { anyStringCount++; } : PERM_WILD_STRING
  | < PREAMBLE:       "Preamble" >
  | < SYSTEM_CLASSES: "System-classes:" > { anyStringCount++; } : PERM_WILD_STRING
  | < MODULE_CLASSES: "Module-classes:" > { anyStringCount++; } : PERM_WILD_STRING
  | < DATABASE_TAG:   "Database-tag:" >  { anyStringCount++; } : PERM_WILD_STRING
  | < TYPE_NAME:      "Type-name:" >
  | < INTERCEPTOR:    "#INT" >
  | < IN:             "in" >
  | < NOT:            "not" >
}

// Event keywords
TOKEN :
{
    < NEW_OBJECT: "new_object" >
  | < CONSTRUCT_OBJECT: "construct_object" >
  | < CONSTRUCT_FINISH: "construct_finish" >
  | < GET_STATIC: "get_static" >
  | < PUT_STATIC: "put_static" >
  | < GET_FIELD: "get_field" >
  | < PUT_FIELD: "put_field" >
  | < CONSTRUCTOR_CALL: "constructor_call" >
  | < STATIC_CALL: "static_call" >
  | < VIRTUAL_CALL: "virtual_call" >
  | < INTERFACE_CALL: "interface_call" >
  | < VIRTUAL_METHOD_ENTER: "virtual_method_enter" >
  | < VIRTUAL_METHOD_EXIT: "virtual_method_exit" >
  | < STATIC_METHOD_ENTER: "static_method_enter" >
  | < STATIC_METHOD_EXIT: "static_method_exit" >
  | < MONITOR_CONTEND: "monitor_contend" >
  | < MONITOR_ACQUIRE: "monitor_acquire" >
  | < MONITOR_PRE_RELEASE: "monitor_pre_release" >
  | < MONITOR_RELEASE: "monitor_release" >
  | < THROW: "throw" >
  | < CATCH: "catch" >
  | < STATIC_INIT_ENTER: "static_init_enter" >
  | < ARRAY_ELEM_LOAD_BOUNDS: "array_element_load_bounds" >
  | < ARRAY_ELEM_STORE_BOUNDS: "array_element_store_bounds" >
  | < ARRAY_ELEM_LOAD: "array_element_load" >
  | < ARRAY_ELEM_STORE: "array_element_store" >
}

// General keywords
TOKEN :
{
    < TRUE:  "true" >
  | < FALSE: "false" >
  | < VOID:    "void" >
  | < BYTE:    "byte" >
  | < CHAR:    "char" >
  | < DOUBLE:  "double" >
  | < FLOAT:   "float" >
  | < INT:     "int" >
  | < LONG:    "long" >
  | < BOOLEAN: "boolean" >
  | < SHORT:   "short" >
  | < STRING:  "string" >
  | < JNI_VOID:    "V" >
  | < JNI_BYTE:    "B" >
  | < JNI_CHAR:    "C" >
  | < JNI_DOUBLE:  "D" >
  | < JNI_FLOAT:   "F" >
  | < JNI_INT:     "I" >
  | < JNI_LONG:    "J" >
  | < JNI_BOOLEAN: "Z" >
  | < JNI_SHORT:   "S" >
  | < JNI_ARRAY:   "[" >
}

<PERM_WILD_STRING> TOKEN :
{
    < WILD_STRING: (~["\"" , " " , "\t" , "\n" , "\r" , "\f"])+ >
        {
            if (--anyStringCount == 0) {
                SwitchTo(DEFAULT);
            }
        }
}

<*> TOKEN :
{
    < STRING_LITERAL: "\"" (~["\""])* "\"" >
        {
            if (anyStringCount > 0) {
                anyStringCount--;
                if (anyStringCount == 0) {
                	SwitchTo(DEFAULT);
                }
            }
        }
}

TOKEN :
{
    // Prohibit a leading zero to prevent confusion with typical
    // octal notation
    < UINT: ["1"-"9"] (["0"-"9"])* >
}

// Identifiers

TOKEN :
{
  < JAVA_ID: <LETTER> (<PART_LETTER>)* >
|
  < #LETTER:
      [  // all chars for which Character.isIdentifierStart is true
         "$",
         "A"-"Z",
         "_",
         "a"-"z",
         "\u00a2"-"\u00a5",
         "\u00aa",
         "\u00b5",
         "\u00ba",
         "\u00c0"-"\u00d6",
         "\u00d8"-"\u00f6",
         "\u00f8"-"\u021f",
         "\u0222"-"\u0233",
         "\u0250"-"\u02ad",
         "\u02b0"-"\u02b8",
         "\u02bb"-"\u02c1",
         "\u02d0"-"\u02d1",
         "\u02e0"-"\u02e4",
         "\u02ee",
         "\u037a",
         "\u0386",
         "\u0388"-"\u038a",
         "\u038c",
         "\u038e"-"\u03a1",
         "\u03a3"-"\u03ce",
         "\u03d0"-"\u03d7",
         "\u03da"-"\u03f3",
         "\u0400"-"\u0481",
         "\u048c"-"\u04c4",
         "\u04c7"-"\u04c8",
         "\u04cb"-"\u04cc",
         "\u04d0"-"\u04f5",
         "\u04f8"-"\u04f9",
         "\u0531"-"\u0556",
         "\u0559",
         "\u0561"-"\u0587",
         "\u05d0"-"\u05ea",
         "\u05f0"-"\u05f2",
         "\u0621"-"\u063a",
         "\u0640"-"\u064a",
         "\u0671"-"\u06d3",
         "\u06d5",
         "\u06e5"-"\u06e6",
         "\u06fa"-"\u06fc",
         "\u0710",
         "\u0712"-"\u072c",
         "\u0780"-"\u07a5",
         "\u0905"-"\u0939",
         "\u093d",
         "\u0950",
         "\u0958"-"\u0961",
         "\u0985"-"\u098c",
         "\u098f"-"\u0990",
         "\u0993"-"\u09a8",
         "\u09aa"-"\u09b0",
         "\u09b2",
         "\u09b6"-"\u09b9",
         "\u09dc"-"\u09dd",
         "\u09df"-"\u09e1",
         "\u09f0"-"\u09f3",
         "\u0a05"-"\u0a0a",
         "\u0a0f"-"\u0a10",
         "\u0a13"-"\u0a28",
         "\u0a2a"-"\u0a30",
         "\u0a32"-"\u0a33",
         "\u0a35"-"\u0a36",
         "\u0a38"-"\u0a39",
         "\u0a59"-"\u0a5c",
         "\u0a5e",
         "\u0a72"-"\u0a74",
         "\u0a85"-"\u0a8b",
         "\u0a8d",
         "\u0a8f"-"\u0a91",
         "\u0a93"-"\u0aa8",
         "\u0aaa"-"\u0ab0",
         "\u0ab2"-"\u0ab3",
         "\u0ab5"-"\u0ab9",
         "\u0abd",
         "\u0ad0",
         "\u0ae0",
         "\u0b05"-"\u0b0c",
         "\u0b0f"-"\u0b10",
         "\u0b13"-"\u0b28",
         "\u0b2a"-"\u0b30",
         "\u0b32"-"\u0b33",
         "\u0b36"-"\u0b39",
         "\u0b3d",
         "\u0b5c"-"\u0b5d",
         "\u0b5f"-"\u0b61",
         "\u0b85"-"\u0b8a",
         "\u0b8e"-"\u0b90",
         "\u0b92"-"\u0b95",
         "\u0b99"-"\u0b9a",
         "\u0b9c",
         "\u0b9e"-"\u0b9f",
         "\u0ba3"-"\u0ba4",
         "\u0ba8"-"\u0baa",
         "\u0bae"-"\u0bb5",
         "\u0bb7"-"\u0bb9",
         "\u0c05"-"\u0c0c",
         "\u0c0e"-"\u0c10",
         "\u0c12"-"\u0c28",
         "\u0c2a"-"\u0c33",
         "\u0c35"-"\u0c39",
         "\u0c60"-"\u0c61",
         "\u0c85"-"\u0c8c",
         "\u0c8e"-"\u0c90",
         "\u0c92"-"\u0ca8",
         "\u0caa"-"\u0cb3",
         "\u0cb5"-"\u0cb9",
         "\u0cde",
         "\u0ce0"-"\u0ce1",
         "\u0d05"-"\u0d0c",
         "\u0d0e"-"\u0d10",
         "\u0d12"-"\u0d28",
         "\u0d2a"-"\u0d39",
         "\u0d60"-"\u0d61",
         "\u0d85"-"\u0d96",
         "\u0d9a"-"\u0db1",
         "\u0db3"-"\u0dbb",
         "\u0dbd",
         "\u0dc0"-"\u0dc6",
         "\u0e01"-"\u0e30",
         "\u0e32"-"\u0e33",
         "\u0e3f"-"\u0e46",
         "\u0e81"-"\u0e82",
         "\u0e84",
         "\u0e87"-"\u0e88",
         "\u0e8a",
         "\u0e8d",
         "\u0e94"-"\u0e97",
         "\u0e99"-"\u0e9f",
         "\u0ea1"-"\u0ea3",
         "\u0ea5",
         "\u0ea7",
         "\u0eaa"-"\u0eab",
         "\u0ead"-"\u0eb0",
         "\u0eb2"-"\u0eb3",
         "\u0ebd",
         "\u0ec0"-"\u0ec4",
         "\u0ec6",
         "\u0edc"-"\u0edd",
         "\u0f00",
         "\u0f40"-"\u0f47",
         "\u0f49"-"\u0f6a",
         "\u0f88"-"\u0f8b",
         "\u1000"-"\u1021",
         "\u1023"-"\u1027",
         "\u1029"-"\u102a",
         "\u1050"-"\u1055",
         "\u10a0"-"\u10c5",
         "\u10d0"-"\u10f6",
         "\u1100"-"\u1159",
         "\u115f"-"\u11a2",
         "\u11a8"-"\u11f9",
         "\u1200"-"\u1206",
         "\u1208"-"\u1246",
         "\u1248",
         "\u124a"-"\u124d",
         "\u1250"-"\u1256",
         "\u1258",
         "\u125a"-"\u125d",
         "\u1260"-"\u1286",
         "\u1288",
         "\u128a"-"\u128d",
         "\u1290"-"\u12ae",
         "\u12b0",
         "\u12b2"-"\u12b5",
         "\u12b8"-"\u12be",
         "\u12c0",
         "\u12c2"-"\u12c5",
         "\u12c8"-"\u12ce",
         "\u12d0"-"\u12d6",
         "\u12d8"-"\u12ee",
         "\u12f0"-"\u130e",
         "\u1310",
         "\u1312"-"\u1315",
         "\u1318"-"\u131e",
         "\u1320"-"\u1346",
         "\u1348"-"\u135a",
         "\u13a0"-"\u13f4",
         "\u1401"-"\u166c",
         "\u166f"-"\u1676",
         "\u1681"-"\u169a",
         "\u16a0"-"\u16ea",
         "\u1780"-"\u17b3",
         "\u17db",
         "\u1820"-"\u1877",
         "\u1880"-"\u18a8",
         "\u1e00"-"\u1e9b",
         "\u1ea0"-"\u1ef9",
         "\u1f00"-"\u1f15",
         "\u1f18"-"\u1f1d",
         "\u1f20"-"\u1f45",
         "\u1f48"-"\u1f4d",
         "\u1f50"-"\u1f57",
         "\u1f59",
         "\u1f5b",
         "\u1f5d",
         "\u1f5f"-"\u1f7d",
         "\u1f80"-"\u1fb4",
         "\u1fb6"-"\u1fbc",
         "\u1fbe",
         "\u1fc2"-"\u1fc4",
         "\u1fc6"-"\u1fcc",
         "\u1fd0"-"\u1fd3",
         "\u1fd6"-"\u1fdb",
         "\u1fe0"-"\u1fec",
         "\u1ff2"-"\u1ff4",
         "\u1ff6"-"\u1ffc",
         "\u203f"-"\u2040",
         "\u207f",
         "\u20a0"-"\u20af",
         "\u2102",
         "\u2107",
         "\u210a"-"\u2113",
         "\u2115",
         "\u2119"-"\u211d",
         "\u2124",
         "\u2126",
         "\u2128",
         "\u212a"-"\u212d",
         "\u212f"-"\u2131",
         "\u2133"-"\u2139",
         "\u2160"-"\u2183",
         "\u3005"-"\u3007",
         "\u3021"-"\u3029",
         "\u3031"-"\u3035",
         "\u3038"-"\u303a",
         "\u3041"-"\u3094",
         "\u309d"-"\u309e",
         "\u30a1"-"\u30fe",
         "\u3105"-"\u312c",
         "\u3131"-"\u318e",
         "\u31a0"-"\u31b7",
         "\u3400"-"\u4db5",
         "\u4e00"-"\u9fa5",
         "\ua000"-"\ua48c",
         "\uac00"-"\ud7a3",
         "\uf900"-"\ufa2d",
         "\ufb00"-"\ufb06",
         "\ufb13"-"\ufb17",
         "\ufb1d",
         "\ufb1f"-"\ufb28",
         "\ufb2a"-"\ufb36",
         "\ufb38"-"\ufb3c",
         "\ufb3e",
         "\ufb40"-"\ufb41",
         "\ufb43"-"\ufb44",
         "\ufb46"-"\ufbb1",
         "\ufbd3"-"\ufd3d",
         "\ufd50"-"\ufd8f",
         "\ufd92"-"\ufdc7",
         "\ufdf0"-"\ufdfb",
         "\ufe33"-"\ufe34",
         "\ufe4d"-"\ufe4f",
         "\ufe69",
         "\ufe70"-"\ufe72",
         "\ufe74",
         "\ufe76"-"\ufefc",
         "\uff04",
         "\uff21"-"\uff3a",
         "\uff3f",
         "\uff41"-"\uff5a",
         "\uff65"-"\uffbe",
         "\uffc2"-"\uffc7",
         "\uffca"-"\uffcf",
         "\uffd2"-"\uffd7",
         "\uffda"-"\uffdc",
         "\uffe0"-"\uffe1",
         "\uffe5"-"\uffe6"
      ]
  >
|
  < #PART_LETTER:
      [  // all chars for which Character.isIdentifierPart is true
         "\u0000"-"\u0008",
         "\u000e"-"\u001b",
         "$",
         "0"-"9",
         "A"-"Z",
         "_",
         "a"-"z",
         "\u007f"-"\u009f",
         "\u00a2"-"\u00a5",
         "\u00aa",
         "\u00b5",
         "\u00ba",
         "\u00c0"-"\u00d6",
         "\u00d8"-"\u00f6",
         "\u00f8"-"\u021f",
         "\u0222"-"\u0233",
         "\u0250"-"\u02ad",
         "\u02b0"-"\u02b8",
         "\u02bb"-"\u02c1",
         "\u02d0"-"\u02d1",
         "\u02e0"-"\u02e4",
         "\u02ee",
         "\u0300"-"\u034e",
         "\u0360"-"\u0362",
         "\u037a",
         "\u0386",
         "\u0388"-"\u038a",
         "\u038c",
         "\u038e"-"\u03a1",
         "\u03a3"-"\u03ce",
         "\u03d0"-"\u03d7",
         "\u03da"-"\u03f3",
         "\u0400"-"\u0481",
         "\u0483"-"\u0486",
         "\u048c"-"\u04c4",
         "\u04c7"-"\u04c8",
         "\u04cb"-"\u04cc",
         "\u04d0"-"\u04f5",
         "\u04f8"-"\u04f9",
         "\u0531"-"\u0556",
         "\u0559",
         "\u0561"-"\u0587",
         "\u0591"-"\u05a1",
         "\u05a3"-"\u05b9",
         "\u05bb"-"\u05bd",
         "\u05bf",
         "\u05c1"-"\u05c2",
         "\u05c4",
         "\u05d0"-"\u05ea",
         "\u05f0"-"\u05f2",
         "\u0621"-"\u063a",
         "\u0640"-"\u0655",
         "\u0660"-"\u0669",
         "\u0670"-"\u06d3",
         "\u06d5"-"\u06dc",
         "\u06df"-"\u06e8",
         "\u06ea"-"\u06ed",
         "\u06f0"-"\u06fc",
         "\u070f"-"\u072c",
         "\u0730"-"\u074a",
         "\u0780"-"\u07b0",
         "\u0901"-"\u0903",
         "\u0905"-"\u0939",
         "\u093c"-"\u094d",
         "\u0950"-"\u0954",
         "\u0958"-"\u0963",
         "\u0966"-"\u096f",
         "\u0981"-"\u0983",
         "\u0985"-"\u098c",
         "\u098f"-"\u0990",
         "\u0993"-"\u09a8",
         "\u09aa"-"\u09b0",
         "\u09b2",
         "\u09b6"-"\u09b9",
         "\u09bc",
         "\u09be"-"\u09c4",
         "\u09c7"-"\u09c8",
         "\u09cb"-"\u09cd",
         "\u09d7",
         "\u09dc"-"\u09dd",
         "\u09df"-"\u09e3",
         "\u09e6"-"\u09f3",
         "\u0a02",
         "\u0a05"-"\u0a0a",
         "\u0a0f"-"\u0a10",
         "\u0a13"-"\u0a28",
         "\u0a2a"-"\u0a30",
         "\u0a32"-"\u0a33",
         "\u0a35"-"\u0a36",
         "\u0a38"-"\u0a39",
         "\u0a3c",
         "\u0a3e"-"\u0a42",
         "\u0a47"-"\u0a48",
         "\u0a4b"-"\u0a4d",
         "\u0a59"-"\u0a5c",
         "\u0a5e",
         "\u0a66"-"\u0a74",
         "\u0a81"-"\u0a83",
         "\u0a85"-"\u0a8b",
         "\u0a8d",
         "\u0a8f"-"\u0a91",
         "\u0a93"-"\u0aa8",
         "\u0aaa"-"\u0ab0",
         "\u0ab2"-"\u0ab3",
         "\u0ab5"-"\u0ab9",
         "\u0abc"-"\u0ac5",
         "\u0ac7"-"\u0ac9",
         "\u0acb"-"\u0acd",
         "\u0ad0",
         "\u0ae0",
         "\u0ae6"-"\u0aef",
         "\u0b01"-"\u0b03",
         "\u0b05"-"\u0b0c",
         "\u0b0f"-"\u0b10",
         "\u0b13"-"\u0b28",
         "\u0b2a"-"\u0b30",
         "\u0b32"-"\u0b33",
         "\u0b36"-"\u0b39",
         "\u0b3c"-"\u0b43",
         "\u0b47"-"\u0b48",
         "\u0b4b"-"\u0b4d",
         "\u0b56"-"\u0b57",
         "\u0b5c"-"\u0b5d",
         "\u0b5f"-"\u0b61",
         "\u0b66"-"\u0b6f",
         "\u0b82"-"\u0b83",
         "\u0b85"-"\u0b8a",
         "\u0b8e"-"\u0b90",
         "\u0b92"-"\u0b95",
         "\u0b99"-"\u0b9a",
         "\u0b9c",
         "\u0b9e"-"\u0b9f",
         "\u0ba3"-"\u0ba4",
         "\u0ba8"-"\u0baa",
         "\u0bae"-"\u0bb5",
         "\u0bb7"-"\u0bb9",
         "\u0bbe"-"\u0bc2",
         "\u0bc6"-"\u0bc8",
         "\u0bca"-"\u0bcd",
         "\u0bd7",
         "\u0be7"-"\u0bef",
         "\u0c01"-"\u0c03",
         "\u0c05"-"\u0c0c",
         "\u0c0e"-"\u0c10",
         "\u0c12"-"\u0c28",
         "\u0c2a"-"\u0c33",
         "\u0c35"-"\u0c39",
         "\u0c3e"-"\u0c44",
         "\u0c46"-"\u0c48",
         "\u0c4a"-"\u0c4d",
         "\u0c55"-"\u0c56",
         "\u0c60"-"\u0c61",
         "\u0c66"-"\u0c6f",
         "\u0c82"-"\u0c83",
         "\u0c85"-"\u0c8c",
         "\u0c8e"-"\u0c90",
         "\u0c92"-"\u0ca8",
         "\u0caa"-"\u0cb3",
         "\u0cb5"-"\u0cb9",
         "\u0cbe"-"\u0cc4",
         "\u0cc6"-"\u0cc8",
         "\u0cca"-"\u0ccd",
         "\u0cd5"-"\u0cd6",
         "\u0cde",
         "\u0ce0"-"\u0ce1",
         "\u0ce6"-"\u0cef",
         "\u0d02"-"\u0d03",
         "\u0d05"-"\u0d0c",
         "\u0d0e"-"\u0d10",
         "\u0d12"-"\u0d28",
         "\u0d2a"-"\u0d39",
         "\u0d3e"-"\u0d43",
         "\u0d46"-"\u0d48",
         "\u0d4a"-"\u0d4d",
         "\u0d57",
         "\u0d60"-"\u0d61",
         "\u0d66"-"\u0d6f",
         "\u0d82"-"\u0d83",
         "\u0d85"-"\u0d96",
         "\u0d9a"-"\u0db1",
         "\u0db3"-"\u0dbb",
         "\u0dbd",
         "\u0dc0"-"\u0dc6",
         "\u0dca",
         "\u0dcf"-"\u0dd4",
         "\u0dd6",
         "\u0dd8"-"\u0ddf",
         "\u0df2"-"\u0df3",
         "\u0e01"-"\u0e3a",
         "\u0e3f"-"\u0e4e",
         "\u0e50"-"\u0e59",
         "\u0e81"-"\u0e82",
         "\u0e84",
         "\u0e87"-"\u0e88",
         "\u0e8a",
         "\u0e8d",
         "\u0e94"-"\u0e97",
         "\u0e99"-"\u0e9f",
         "\u0ea1"-"\u0ea3",
         "\u0ea5",
         "\u0ea7",
         "\u0eaa"-"\u0eab",
         "\u0ead"-"\u0eb9",
         "\u0ebb"-"\u0ebd",
         "\u0ec0"-"\u0ec4",
         "\u0ec6",
         "\u0ec8"-"\u0ecd",
         "\u0ed0"-"\u0ed9",
         "\u0edc"-"\u0edd",
         "\u0f00",
         "\u0f18"-"\u0f19",
         "\u0f20"-"\u0f29",
         "\u0f35",
         "\u0f37",
         "\u0f39",
         "\u0f3e"-"\u0f47",
         "\u0f49"-"\u0f6a",
         "\u0f71"-"\u0f84",
         "\u0f86"-"\u0f8b",
         "\u0f90"-"\u0f97",
         "\u0f99"-"\u0fbc",
         "\u0fc6",
         "\u1000"-"\u1021",
         "\u1023"-"\u1027",
         "\u1029"-"\u102a",
         "\u102c"-"\u1032",
         "\u1036"-"\u1039",
         "\u1040"-"\u1049",
         "\u1050"-"\u1059",
         "\u10a0"-"\u10c5",
         "\u10d0"-"\u10f6",
         "\u1100"-"\u1159",
         "\u115f"-"\u11a2",
         "\u11a8"-"\u11f9",
         "\u1200"-"\u1206",
         "\u1208"-"\u1246",
         "\u1248",
         "\u124a"-"\u124d",
         "\u1250"-"\u1256",
         "\u1258",
         "\u125a"-"\u125d",
         "\u1260"-"\u1286",
         "\u1288",
         "\u128a"-"\u128d",
         "\u1290"-"\u12ae",
         "\u12b0",
         "\u12b2"-"\u12b5",
         "\u12b8"-"\u12be",
         "\u12c0",
         "\u12c2"-"\u12c5",
         "\u12c8"-"\u12ce",
         "\u12d0"-"\u12d6",
         "\u12d8"-"\u12ee",
         "\u12f0"-"\u130e",
         "\u1310",
         "\u1312"-"\u1315",
         "\u1318"-"\u131e",
         "\u1320"-"\u1346",
         "\u1348"-"\u135a",
         "\u1369"-"\u1371",
         "\u13a0"-"\u13f4",
         "\u1401"-"\u166c",
         "\u166f"-"\u1676",
         "\u1681"-"\u169a",
         "\u16a0"-"\u16ea",
         "\u1780"-"\u17d3",
         "\u17db",
         "\u17e0"-"\u17e9",
         "\u180b"-"\u180e",
         "\u1810"-"\u1819",
         "\u1820"-"\u1877",
         "\u1880"-"\u18a9",
         "\u1e00"-"\u1e9b",
         "\u1ea0"-"\u1ef9",
         "\u1f00"-"\u1f15",
         "\u1f18"-"\u1f1d",
         "\u1f20"-"\u1f45",
         "\u1f48"-"\u1f4d",
         "\u1f50"-"\u1f57",
         "\u1f59",
         "\u1f5b",
         "\u1f5d",
         "\u1f5f"-"\u1f7d",
         "\u1f80"-"\u1fb4",
         "\u1fb6"-"\u1fbc",
         "\u1fbe",
         "\u1fc2"-"\u1fc4",
         "\u1fc6"-"\u1fcc",
         "\u1fd0"-"\u1fd3",
         "\u1fd6"-"\u1fdb",
         "\u1fe0"-"\u1fec",
         "\u1ff2"-"\u1ff4",
         "\u1ff6"-"\u1ffc",
         "\u200c"-"\u200f",
         "\u202a"-"\u202e",
         "\u203f"-"\u2040",
         "\u206a"-"\u206f",
         "\u207f",
         "\u20a0"-"\u20af",
         "\u20d0"-"\u20dc",
         "\u20e1",
         "\u2102",
         "\u2107",
         "\u210a"-"\u2113",
         "\u2115",
         "\u2119"-"\u211d",
         "\u2124",
         "\u2126",
         "\u2128",
         "\u212a"-"\u212d",
         "\u212f"-"\u2131",
         "\u2133"-"\u2139",
         "\u2160"-"\u2183",
         "\u3005"-"\u3007",
         "\u3021"-"\u302f",
         "\u3031"-"\u3035",
         "\u3038"-"\u303a",
         "\u3041"-"\u3094",
         "\u3099"-"\u309a",
         "\u309d"-"\u309e",
         "\u30a1"-"\u30fe",
         "\u3105"-"\u312c",
         "\u3131"-"\u318e",
         "\u31a0"-"\u31b7",
         "\u3400"-"\u4db5",
         "\u4e00"-"\u9fa5",
         "\ua000"-"\ua48c",
         "\uac00"-"\ud7a3",
         "\uf900"-"\ufa2d",
         "\ufb00"-"\ufb06",
         "\ufb13"-"\ufb17",
         "\ufb1d"-"\ufb28",
         "\ufb2a"-"\ufb36",
         "\ufb38"-"\ufb3c",
         "\ufb3e",
         "\ufb40"-"\ufb41",
         "\ufb43"-"\ufb44",
         "\ufb46"-"\ufbb1",
         "\ufbd3"-"\ufd3d",
         "\ufd50"-"\ufd8f",
         "\ufd92"-"\ufdc7",
         "\ufdf0"-"\ufdfb",
         "\ufe20"-"\ufe23",
         "\ufe33"-"\ufe34",
         "\ufe4d"-"\ufe4f",
         "\ufe69",
         "\ufe70"-"\ufe72",
         "\ufe74",
         "\ufe76"-"\ufefc",
         "\ufeff",
         "\uff04",
         "\uff10"-"\uff19",
         "\uff21"-"\uff3a",
         "\uff3f",
         "\uff41"-"\uff5a",
         "\uff65"-"\uffbe",
         "\uffc2"-"\uffc7",
         "\uffca"-"\uffcf",
         "\uffd2"-"\uffd7",
         "\uffda"-"\uffdc",
         "\uffe0"-"\uffe1",
         "\uffe5"-"\uffe6",
         "\ufff9"-"\ufffb"
      ]
  >
}


//****************************************
// EDL Grammar
//****************************************

/**
 * Initiates the parse of an event description language (EDL) file.
 *
 * @return A {@link SemanticEventData} object encapsulating the parsed
 *     event specifications.
 */
SemanticEventData edlUnit() throws IOException :
{}
{
    ( suiteDecl() ( observablesSection() | importDecl() )+
    <EOF>
    )
    {
        // Created in suiteDecl()
        return semEventData;
    }
}

/**
 * Production for EDL import declarations.
 *
 * The imported EDL fragment is processed as if it textually appeared
 * in the importing file. The lexer is reassigned to a stream attached
 * to the imported file, without modifying any other lexer or parser
 * state. When processing of the imported file is completed, the lexer
 * stream is restored to the importing file and processing resumes.
 */
private void importDecl() throws IOException :
{
    Token fileNameTok;
}
{
    "@import" fileNameTok=<STRING_LITERAL>
    {
        String fileName = stripQuotes(fileNameTok);

        if (DEBUG) {
        	System.out.println("[import:start] " + fileName);
        }
        
        if (openFiles.contains(fileName)) {
            throw new ParseException("Circular import of file \"" +
                fileName + "\" from \"" + curFile + "\" at line " +
                fileNameTok.beginLine + ", column " + fileNameTok.beginColumn);
        }

        Reader newStream = null;
        try {
            newStream = new FileReader(fileName);
        }
        catch (IOException e) {
            throw new ParseException("Could not open file \"" +
                fileName + "\", imported from \"" + curFile + "\"" +
                " at line " + fileNameTok.beginLine + ", column " +
                fileNameTok.beginColumn + "\n    because: " + e.getMessage());
        }

        parseStack.add(new LexerStream(curFile, token_source.input_stream));
        curFile = fileName;
        openFiles.add(fileName);

        // Simply replace the source stream with the stream pointing to the
        // new file, without changing any lexer or parser state. This
        // appears to work, but is potentially sensitive to changes in
        // the code generation performed by JavaCC, since it depends on
        // generated field names and types.
        jj_input_stream = token_source.input_stream =
        	new JavaCharStream(newStream, 1, 1);

        fileNameTok = null;

        importEdlUnit(false);
    }
}

/**
 * Entry point for processing an imported EDL fragment. An imported
 * fragment cannot contain an "EDLSuite" declaration.
 *
 * This production is never referenced directly in the grammar -- it
 * is only called from the action associated with the importDecl()
 * production.
 */
protected void importEdlUnit(boolean isRootProduction) throws IOException :
{}
{
    ( observablesSection() | importDecl() )+
    <EOF>
    {
        if (DEBUG) {
        	System.out.println("[import:done] " + curFile);
        }

		if (!isRootProduction) {        
	        LexerStream importer = parseStack.remove(parseStack.size() - 1);
	        openFiles.remove(curFile);
	        curFile = importer.fileName;
	
	        // Simply swap back in the source stream from the previous file.
	        // This is potentially sensitive to changes in the code
	        // generation performed by JavaCC.
	        jj_input_stream = token_source.input_stream = importer.stream;
	    }
    }
}

/**
 * Production for the "EDLSuite" section of an EDL specification.
 *
 * A &lt;WILD_STRING&gt; is a string that can contain nearly every character
 * in the legal input character set except whitespace (the same character
 * set accepted by Java). If whitespace must appear within the token,
 * a (quoted) &lt;STRING_LITERAL&gt; should be used instead.
 */
private void suiteDecl() :
{
    Token nameTok;
    String name;
}
{
    "begin" "EDLSuite"
    ( nameTok=<STRING_LITERAL> { name = stripQuotes(nameTok); }
    | nameTok=<WILD_STRING> { name = nameTok.image; }
    )
        {
        	nameTok = null;
        	
        	if (DEBUG) {
        		System.out.println("[EDLSuite] name=" + name);
        	}
        	
            semEventData = new SemanticEventData(name);
            globalConstraints = new GlobalConstraints();
        }
    (array_element_load_bounds__decl() | array_element_store_bounds__decl())*
    "end"
}

/**
 * Production for global array element load bounds specifications in the
 * EDLSuite header section.
 *
 * A &lt;UINT&gt; is a positive integer (whole number) value, with no
 * leading zeros.
 */
private void array_element_load_bounds__decl() :
{
    Type javaType;
    Token minTok = null;
    Token maxTok = null;
}
{
    ( "array_element_load_bounds"
        ( "*" {javaType=SemanticConstants.TYPE_ANY;} | javaType=argType() )
        ( ( "min:" minTok=<UINT> ("max:" maxTok=<UINT>)? )
          | ( "max:" maxTok=<UINT> ("min:" minTok=<UINT>)? )
        )
    )
    {
        ArrayElementBounds bounds =
            processArrayElementBounds(javaType, minTok, maxTok);

        globalConstraints.arrayElementBounds[ArrayElementType.ILOAD].put(
            javaType, bounds);

        if (DEBUG) {
            System.out.println("[Global array element load bounds]");
            System.out.println("    type=" + javaType);
            System.out.print("    min=" +
                ((bounds.min != ArrayElementBounds.NO_BOUND)
                ? bounds.min : "none"));
            System.out.println(", max=" +
                ((bounds.max != ArrayElementBounds.NO_BOUND)
                ? bounds.max : "none"));
        }
    }
}

/**
 * Production for global array element store bounds specifications in the
 * EDLSuite header section.
 *
 * A &lt;UINT&gt; is a positive integer (whole number) value, with no
 * leading zeros.
 */
private void array_element_store_bounds__decl() :
{
    Type javaType;
    Token minTok = null;
    Token maxTok = null;
}
{
    ( "array_element_store_bounds"
        ( "*" {javaType=SemanticConstants.TYPE_ANY;} | javaType=argType() )
        ( ( "min:" minTok=<UINT> ("max:" maxTok=<UINT>)? )
          | ( "max:" maxTok=<UINT> ("min:" minTok=<UINT>)? )
        )
    )
    {
        ArrayElementBounds bounds =
            processArrayElementBounds(javaType, minTok, maxTok);

        globalConstraints.arrayElementBounds[ArrayElementType.ISTORE].put(
            javaType, bounds);

        if (DEBUG) {
            System.out.println("[Global array element store bounds]");
            System.out.println("    type=" + javaType);
            System.out.print("    min=" +
                ((bounds.min != ArrayElementBounds.NO_BOUND)
                ? bounds.min : "none"));
            System.out.println(", max=" +
                ((bounds.max != ArrayElementBounds.NO_BOUND)
                ? bounds.max : "none"));
        }
    }
}

/**
 * Production for "Observables" sections of an EDL specification.
 *
 * Refer to the documentation of the suiteDecl() production for a definition
 * of the &lt;WILD_STRING&gt; token.
 */
private void observablesSection() throws IOException :
{
    Token keyTok;
    String key;
}
{
    "begin" "Observables"
    ( keyTok=<STRING_LITERAL>
    	{ key = stripQuotes(keyTok); }
    | keyTok=<WILD_STRING>
    	{ key = keyTok.image; }
    )
        {
        	keyTok = null;
        	
        	if (DEBUG) {
        		System.out.println("[Observables] key=" + key);
        	}
        }
    preambleSection(key)
    (observableEvent())*
    "end"
}

/**
 * Production for the "Preamble" section of "Observable" sections.
 */
private void preambleSection(String specKey) throws IOException :
{}
{
    "begin" "Preamble" preambleDeclarations(specKey) "end"
}

/**
 * Production for the declarations permitted in a "Preamble" section.
 */
private void preambleDeclarations(String specKey) throws IOException :
{
    Token sysProgFileTok;
    Token modProgFileTok = null;
    Token dbTagTok = null;
    String sysProgFile;
    String modProgFile = null;
    String dbTag = null;
    boolean noModule = false;
}
{
    ( "System-classes:"
    	( sysProgFileTok=<STRING_LITERAL>
    		{ sysProgFile = stripQuotes(sysProgFileTok); }
    	| sysProgFileTok=<WILD_STRING>
        	{ sysProgFile = sysProgFileTok.image; }
        )
        { sysProgFileTok = null; }
    )
    (("Module-classes:"
    	( modProgFileTok=<STRING_LITERAL>
    		{ modProgFile = stripQuotes(modProgFileTok); }
    	| modProgFileTok=<WILD_STRING>
    		{ modProgFile = modProgFileTok.image; }
    	)
        { modProgFileTok = null; }
     )
     | ( "No-module:" ( <TRUE> {noModule=true;} | <FALSE> {noModule=true;} ) )
    )?
    ( "Database-tag:"
    	( dbTagTok=<STRING_LITERAL>
    		{ dbTag = stripQuotes(dbTagTok); }
    	| dbTagTok=<WILD_STRING>
    		{ dbTag = dbTagTok.image; }
    	)
        { dbTagTok = null; }
    )?
    ( preambleTypedef() )*
    {
    	if (DEBUG) {
    		System.out.println("[Preamble]");
        	System.out.println("    [System-classes] " + sysProgFile);
        	System.out.println("    [No-module] " + noModule);
        	System.out.println("    [Module-classes] " +
        		((noModule) ? "N/A" : modProgFile));
        	if (dbTag != null) {
        		System.out.println("    [Database-tag] " + dbTag);
            }
        }

        List<ProgramUnit> sysClasses = new ArrayList<ProgramUnit>(4);
        List<ProgramUnit> modClasses = new ArrayList<ProgramUnit>(4);

        /*Handler.readProgFile(sysProgFile, dbTag, sysClasses);
        if (modProgFile != null) {
            Handler.readProgFile(modProgFile, dbTag, modClasses);
        }
        else if (!noModule) {
            Handler.readProgFile(sysProgFile, dbTag, modClasses);
        }*/
       	
       	// Reset the event request rank for the new Observables
    	eventRank = 1;

        // The semantic event data and global constraints objects are
        // initialized during parsing of the EDLSuite section, which must
        // appear at the head of the file at which the parser is
        // initially pointed
        edlSpec = new EDLSpecification(specKey, sysClasses,
            modClasses, globalConstraints);
        semEventData.addEventSpecification(edlSpec, true);
    }
}

/**
 * Production for a type-alias ("Type-name:") declaration in a
 * "Preamble" section.
 *
 * Expansions of type aliases can occur in the following locations:
 *   - array element bounds event requests
 *   - argument types in method selection expressions
 *   - class names in event requests and method selection expressions
 *
 * Type aliases cannot be declared for primitive types, or associated
 * to any reserved EDL keywords.
 */
private void preambleTypedef() :
{
    Token symName;
    TokenList typeSpec = null;
    Type javaType = null;
}
{
    "Type-name:" symName=javaIdentifier()
        ( LOOKAHEAD( jniReferenceType() )
          javaType=jniReferenceType()
        | typeSpec=qualifiedName()
        )
    {
        if (typeSpec != null) {
            // (javaType must be null)
            String typeSub = tokensToString(typeSpec).toString();
            javaType = new ObjectType(typeSub);
        }

        typeNames.put(symName.image, javaType);

        if (DEBUG) {
            System.out.println("[Type-name] (" +
            	symName.image + " => " + javaType + ")");
        }
    }
}

/**
 * Production for EDL event requests.
 */
private void observableEvent() :
{}
{
    ("+" {inclusion=true;} | "-" {inclusion=false;}) eventDecl()
}

/**
 * Production for EDL event type requests.
 */
private void eventDecl() :
{}
{
  ( new_object__decl()
  | construct_object__decl()
  | construct_finish__decl()
  | get_static__decl()
  | put_static__decl()
  | get_field__decl()
  | put_field__decl()
  | constructor_call__decl()
  | static_call__decl()
  | virtual_call__decl()
  | interface_call__decl()
  | virtual_method_enter__decl()
  | virtual_method_exit__decl()
  | static_method_enter__decl()
  | static_method_exit__decl()
  | monitor_contend__decl()
  | monitor_acquire__decl()
  | monitor_pre_release__decl()
  | monitor_release__decl()
  | throw__decl()
  | catch__decl()
  | static_init_enter__decl()
  | array_element_load__decl()
  | array_element_store__decl()
  )
}

/**
 * Production for EDL new object allocation event requests.
 */
private void new_object__decl() :
{
    TokenList nameSpec = null;
    boolean isTotalWild = false;
    boolean isPkgWild = false;
}
{
    "new_object" ("*" {isTotalWild=true;}
        | (nameSpec=qualifiedName() (".*" {isPkgWild=true;})?))
        {
            processClassExpr(nameSpec, isTotalWild, isPkgWild);
            nameSpec = null;

	        if (DEBUG) {
	        	System.out.println("[" + ((inclusion) ? "+" : "-") + ",(" +
	        		eventRank + "),new_object] class=" + descClassName);
	        }

            NewObjectRequest req = edlSpec.createNewObjectRequest(descClassName,
                inclusion, eventRank++);
        }
        locationBlock(req)
    {
        edlSpec.addNewObjectRequest(req);
    }
}

/**
 * Production for EDL constructor entry event requests.
 */
private void construct_object__decl() :
{
    TokenList nameSpec = null;
    boolean isTotalWild = false;
    Type[] argTypes = null;
}
{
    "construct_object" ("*" {isTotalWild=true;}
        | (nameSpec=qualifiedName() argTypes=argsExpr()))
    {
        processClassExpr(nameSpec, isTotalWild, false);

        if (DEBUG) {
        	System.out.println("[" + ((inclusion) ? "+" : "-") + "," +
        		eventRank + ",construct_object]");
        	System.out.println("    class=" + descClassName);
            System.out.println("    argTypes=" + ((argTypes == null) ? "null"
            	: java.util.Arrays.toString(argTypes)));
        }

        edlSpec.addConstructorEntryRequest(descClassName, argTypes,
            inclusion, eventRank++);
    }
}

/**
 * Production for EDL constructor exit event requests.
 */
private void construct_finish__decl() :
{
    TokenList nameSpec = null;
    boolean isTotalWild = false;
    Type[] argTypes = null;
}
{
    "construct_finish" ("*" {isTotalWild=true;}
        | (nameSpec=qualifiedName() argTypes=argsExpr()))
    {
        processClassExpr(nameSpec, isTotalWild, false);

        if (DEBUG) {
        	System.out.println("[" + ((inclusion) ? "+" : "-") + "," +
        		eventRank + ",construct_finish]");
        	System.out.println("    class=" + descClassName);
            System.out.println("    argTypes=" + ((argTypes == null) ? "null"
            	: java.util.Arrays.toString(argTypes)));
        }

        edlSpec.addConstructorExitRequest(descClassName, argTypes,
            inclusion, eventRank++);
    }
}

/**
 * Production for EDL static field read event requests.
 *
 * Because of greedy token matching in the qualifiedName() subrule,
 * the expectation that the name of the field is given as the string
 * after the final "." in the qualified name string is not formally
 * encoded by the grammar, except in the case of wildcard requests.
 */
private void get_static__decl() :
{
	// The string following the last "." is expected to be the field name.
	// Strictly, though, this is ambiguous, and the qualifiedName()
	// production greedily consumes it as part of the class name. It would
 	// be highly complicated to parameterize qualifiedName() to behave
	// otherwise. Instead we just treat the last token in the token list
	// returned by qualifiedName() as the fieldName, unless there is a
	// wildcard (the handling of which is straightforward).

    TokenList nameSpec;
    boolean fieldIsWild = false;
}
{
    "get_static" nameSpec=qualifiedName() (".*" {fieldIsWild=true;})?
        {
            String fullFieldName = processFieldExpr(nameSpec, fieldIsWild);
            nameSpec = null;

			if (DEBUG) {
	        	System.out.println("[" + ((inclusion) ? "+" : "-") + ",(" +
	        		eventRank + "),get_static] field=" + fullFieldName);
            }

            FieldRequest req = edlSpec.createFieldRequest(fullFieldName,
                inclusion, eventRank++, FieldType.GETSTATIC);
        }
        locationBlock(req)
    {
        edlSpec.addFieldRequest(req);
    }
}

/**
 * Production for EDL static field write event requests.
 *
 * Because of greedy token matching in the qualifiedName() subrule,
 * the expectation that the name of the field is given as the string
 * after the final "." in the qualified name string is not formally
 * encoded by the grammar, except in the case of wildcard requests.
 */
private void put_static__decl() :
{
    TokenList nameSpec;
    boolean fieldIsWild = false;
}
{
    "put_static" nameSpec=qualifiedName() (".*" {fieldIsWild=true;})?
        {
            String fullFieldName = processFieldExpr(nameSpec, fieldIsWild);
            nameSpec = null;

			if (DEBUG) {
	        	System.out.println("[" + ((inclusion) ? "+" : "-") + ",(" +
	        		eventRank + "),put_static] field=" + fullFieldName);
            }

            FieldRequest req = edlSpec.createFieldRequest(fullFieldName,
                inclusion, eventRank++, FieldType.PUTSTATIC);
        }
        locationBlock(req)
    {
        edlSpec.addFieldRequest(req);
    }
}

/**
 * Production for EDL instance field read event requests.
 *
 * Because of greedy token matching in the qualifiedName() subrule,
 * the expectation that the name of the field is given as the string
 * after the final "." in the qualified name string is not formally
 * encoded by the grammar, except in the case of wildcard requests.
 */
private void get_field__decl() :
{
    TokenList nameSpec;
    boolean fieldIsWild = false;
}
{
    "get_field" nameSpec=qualifiedName() (".*" {fieldIsWild=true;})?
        {
            String fullFieldName = processFieldExpr(nameSpec, fieldIsWild);
            nameSpec = null;

			if (DEBUG) {
	        	System.out.println("[" + ((inclusion) ? "+" : "-") + ",(" +
	        		eventRank + "),get_field] field=" + fullFieldName);
            }

            FieldRequest req = edlSpec.createFieldRequest(fullFieldName,
                inclusion, eventRank++, FieldType.GETFIELD);
        }
        locationBlock(req)
    {
        edlSpec.addFieldRequest(req);
    }
}

/**
 * Production for EDL instance field write event requests.
 *
 * Because of greedy token matching in the qualifiedName() subrule,
 * the expectation that the name of the field is given as the string
 * after the final "." in the qualified name string is not formally
 * encoded by the grammar, except in the case of wildcard requests.
 */
private void put_field__decl() :
{
    TokenList nameSpec;
    boolean fieldIsWild = false;
}
{
    "put_field" nameSpec=qualifiedName() (".*" {fieldIsWild=true;})?
        {
            String fullFieldName = processFieldExpr(nameSpec, fieldIsWild);
            nameSpec = null;

			if (DEBUG) {
	        	System.out.println("[" + ((inclusion) ? "+" : "-") + ",(" +
	        		eventRank + "),put_field] field=" + fullFieldName);
            }

            FieldRequest req = edlSpec.createFieldRequest(fullFieldName,
                inclusion, eventRank++, FieldType.PUTFIELD);
        }
        locationBlock(req)
    {
        edlSpec.addFieldRequest(req);
    }
}

/**
 * Production for EDL constructor call event requests.
 *
 * Constructor calls correspond to the INVOKESPECIAL instruction in the JVM
 * bytecode instruction set.
 */
private void constructor_call__decl() :
{
    TokenList nameSpec = null;
    boolean classIsWild = false;
    Type[] argTypes = null;
}
{
    "constructor_call" ("*" {classIsWild=true;}
        | (nameSpec=qualifiedName() argTypes=argsExpr()))
        {
            processClassExpr(nameSpec, classIsWild, false);
            nameSpec = null;

			if (DEBUG) {
	        	System.out.println("[" + ((inclusion) ? "+" : "-") + ",(" +
	        		eventRank + "),interface_call]");
	        	System.out.println("    class=" + descClassName);
	            System.out.println("    argTypes=" + ((argTypes == null) ? "null"
	            	: java.util.Arrays.toString(argTypes)));
            }

            CallRequest req = edlSpec.createCallRequest(descClassName,
                "<init>", argTypes, inclusion, eventRank++,
                CallType.CONSTRUCTOR, false);
        }
        locationBlock(req)
    {
        edlSpec.addCallRequest(req);
    }
}

/**
 * Production for EDL static method call event requests.
 *
 * Because of greedy token matching in the qualifiedName() subrule,
 * the expectation that the name of the method is given as the string
 * after the final "." in the qualified name string is not formally
 * encoded by the grammar, except in the case of wildcard requests.
 *
 * Static calls correspond to the INVOKESTATIC instruction in the JVM
 * bytecode instruction set.
 */
private void static_call__decl() :
{
    TokenList nameSpec = null;
    boolean classIsWild = false;
    boolean methodIsWild = false;
    boolean useInterceptor = false;
    Type[] argTypes = null;
}
{
    "static_call" ("#INT" {useInterceptor=true;})?
        ("*" {classIsWild=true;} | (nameSpec=qualifiedName()
        ((".*" {methodIsWild=true;}) | argTypes=argsExpr())))
        {
            processClassAndMethodExpr(nameSpec, classIsWild, methodIsWild);
            nameSpec = null;

			if (DEBUG) {
	        	System.out.println("[" + ((inclusion) ? "+" : "-") + ",(" +
	        		eventRank + "),static_call]");
	        	System.out.println("    class=" + descClassName);
	        	System.out.println("    method=" + descMethodName);
	            System.out.println("    argTypes=" + ((argTypes == null) ? "null"
	            	: java.util.Arrays.toString(argTypes)));
            	System.out.println("    useInterceptor=" + useInterceptor);
            }

            CallRequest req = edlSpec.createCallRequest(descClassName,
                descMethodName, argTypes, inclusion, eventRank++,
                CallType.STATIC, useInterceptor);
        }
        locationBlock(req)
    {
        edlSpec.addCallRequest(req);
    }
}

/**
 * Production for EDL virtual (non-interface) method call event requests.
 *
 * Because of greedy token matching in the qualifiedName() subrule,
 * the expectation that the name of the method is given as the string
 * after the final "." in the qualified name string is not formally
 * encoded by the grammar, except in the case of wildcard requests.
 *
 * Virtual calls correspond to the INVOKEVIRTUAL instruction in the JVM
 * bytecode instruction set.
 */
private void virtual_call__decl() :
{
    TokenList nameSpec = null;
    boolean classIsWild = false;
    boolean methodIsWild = false;
    boolean useInterceptor = false;
    Type[] argTypes = null;
}
{
    "virtual_call" ("#INT" {useInterceptor=true;})?
        ("*" {classIsWild=true;} | (nameSpec=qualifiedName()
        ((".*" {methodIsWild=true;}) | argTypes=argsExpr())))
        {
            processClassAndMethodExpr(nameSpec, classIsWild, methodIsWild);
            nameSpec = null;

			if (DEBUG) {
	        	System.out.println("[" + ((inclusion) ? "+" : "-") + ",(" +
	        		eventRank + "),virtual_call]");
	        	System.out.println("    class=" + descClassName);
	        	System.out.println("    method=" + descMethodName);
	            System.out.println("    argTypes=" + ((argTypes == null) ? "null"
	            	: java.util.Arrays.toString(argTypes)));
            	System.out.println("    useInterceptor=" + useInterceptor);
            }

            CallRequest req = edlSpec.createCallRequest(descClassName,
                descMethodName, argTypes, inclusion, eventRank++,
                CallType.VIRTUAL, useInterceptor);
        }
        locationBlock(req)
    {
        edlSpec.addCallRequest(req);
    }
}

/**
 * Production for EDL interface method call event requests.
 *
 * Because of greedy token matching in the qualifiedName() subrule,
 * the expectation that the name of the method is given as the string
 * after the final "." in the qualified name string is not formally
 * encoded by the grammar, except in the case of wildcard requests.
 *
 * Interface calls correspond to the INVOKEINTERFACE instruction in the JVM
 * bytecode instruction set.
 */
private void interface_call__decl() :
{
    TokenList nameSpec = null;
    boolean classIsWild = false;
    boolean methodIsWild = false;
    boolean useInterceptor = false;
    Type[] argTypes = null;
}
{
    "interface_call" ("#INT" {useInterceptor=true;})?
        ("*" {classIsWild=true;} | (nameSpec=qualifiedName()
        ((".*" {methodIsWild=true;}) | argTypes=argsExpr())))
        {
            processClassAndMethodExpr(nameSpec, classIsWild, methodIsWild);
            nameSpec = null;

			if (DEBUG) {
	        	System.out.println("[" + ((inclusion) ? "+" : "-") + ",(" +
	        		eventRank + "),interface_call]");
	        	System.out.println("    class=" + descClassName);
	        	System.out.println("    method=" + descMethodName);
	            System.out.println("    argTypes=" + ((argTypes == null) ? "null"
	            	: java.util.Arrays.toString(argTypes)));
            	System.out.println("    useInterceptor=" + useInterceptor);
            }

            CallRequest req = edlSpec.createCallRequest(descClassName,
                descMethodName, argTypes, inclusion, eventRank++,
                CallType.INTERFACE, useInterceptor);
        }
        locationBlock(req)
    {
        edlSpec.addCallRequest(req);
    }
}

/**
 * Production for EDL virtual method entry event requests.
 *
 * Because of greedy token matching in the qualifiedName() subrule,
 * the expectation that the name of the method is given as the string
 * after the final "." in the qualified name string is not formally
 * encoded by the grammar, except in the case of wildcard requests.
 *
 * A virtual method for the purpose of this event is any non-constructor
 * method declared without the "static" modifier (e.g. methods dispatched
 * by either INVOKEVIRTUAL or INVOKEINTERFACE call instructions).
 */
private void virtual_method_enter__decl() :
{
    TokenList nameSpec = null;
    boolean classIsWild = false;
    boolean methodIsWild = false;
    Type[] argTypes = null;
}
{
    "virtual_method_enter" ("*" {classIsWild=true;} | (nameSpec=qualifiedName()
            ((".*" {methodIsWild=true;}) | argTypes=argsExpr())))
    {
        processClassAndMethodExpr(nameSpec, classIsWild, methodIsWild);

        if (DEBUG) {
        	System.out.println("[" + ((inclusion) ? "+" : "-") + "," +
        		eventRank + ",virtual_method_enter]");
        	System.out.println("    class=" + descClassName);
        	System.out.println("    method=" + descMethodName);
            System.out.println("    argTypes=" + ((argTypes == null) ? "null"
            	: java.util.Arrays.toString(argTypes)));
        }

        edlSpec.addMethodChangeRequest(descClassName, descMethodName,
            argTypes, inclusion, eventRank++,
            MethodAction.VIRTUAL_ENTER);
    }
}

/**
 * Production for EDL virtual method exit event requests.
 *
 * Because of greedy token matching in the qualifiedName() subrule,
 * the expectation that the name of the method is given as the string
 * after the final "." in the qualified name string is not formally
 * encoded by the grammar, except in the case of wildcard requests.
 *
 * A virtual method for the purpose of this event is any non-constructor
 * method declared without the "static" modifier (e.g. methods dispatched
 * by either INVOKEVIRTUAL or INVOKEINTERFACE call instructions).
 */
private void virtual_method_exit__decl() :
{
    TokenList nameSpec = null;
    boolean classIsWild = false;
    boolean methodIsWild = false;
    Type[] argTypes = null;
}
{
    "virtual_method_exit" ("*" {classIsWild=true;} | (nameSpec=qualifiedName()
        ((".*" {methodIsWild=true;}) | argTypes=argsExpr())))
    {
        processClassAndMethodExpr(nameSpec, classIsWild, methodIsWild);

        if (DEBUG) {
        	System.out.println("[" + ((inclusion) ? "+" : "-") + "," +
        		eventRank + ",virtual_method_exit]");
        	System.out.println("    class=" + descClassName);
        	System.out.println("    method=" + descMethodName);
            System.out.println("    argTypes=" + ((argTypes == null) ? "null"
            	: java.util.Arrays.toString(argTypes)));
        }

        edlSpec.addMethodChangeRequest(descClassName, descMethodName,
            argTypes, inclusion, eventRank++,
            MethodAction.VIRTUAL_EXIT);
    }
}

/**
 * Production for EDL static method entry event requests.
 *
 * Because of greedy token matching in the qualifiedName() subrule,
 * the expectation that the name of the method is given as the string
 * after the final "." in the qualified name string is not formally
 * encoded by the grammar, except in the case of wildcard requests.
 *
 * A static method for the purpose of this event is any non-constructor
 * method declared with the "static" modifier (e.g. methods dispatched
 * by the INVOKESTATIC call instruction).
 */
private void static_method_enter__decl() :
{
    TokenList nameSpec = null;
    boolean classIsWild = false;
    boolean methodIsWild = false;
    Type[] argTypes = null;
}
{
    "static_method_enter" ("*" {classIsWild=true;} | (nameSpec=qualifiedName()
            ((".*" {methodIsWild=true;}) | argTypes=argsExpr())))
    {
        processClassAndMethodExpr(nameSpec, classIsWild, methodIsWild);

        if (DEBUG) {
        	System.out.println("[" + ((inclusion) ? "+" : "-") + "," +
        		eventRank + ",static_method_enter]");
        	System.out.println("    class=" + descClassName);
        	System.out.println("    method=" + descMethodName);
            System.out.println("    argTypes=" + ((argTypes == null) ? "null"
            	: java.util.Arrays.toString(argTypes)));
        }

        edlSpec.addMethodChangeRequest(descClassName, descMethodName,
            argTypes, inclusion, eventRank++,
            MethodAction.STATIC_ENTER);
    }
}

/**
 * Production for EDL static method exit event requests.
 *
 * Because of greedy token matching in the qualifiedName() subrule,
 * the expectation that the name of the method is given as the string
 * after the final "." in the qualified name string is not formally
 * encoded by the grammar, except in the case of wildcard requests.
 *
 * A static method for the purpose of this event is any non-constructor
 * method declared with the "static" modifier (e.g. methods dispatched
 * by the INVOKESTATIC call instruction).
 */
private void static_method_exit__decl() :
{
    TokenList nameSpec = null;
    boolean classIsWild = false;
    boolean methodIsWild = false;
    Type[] argTypes = null;
}
{
    "static_method_exit" ("*" {classIsWild=true;} | (nameSpec=qualifiedName()
            ((".*" {methodIsWild=true;}) | argTypes=argsExpr())))
    {
        processClassAndMethodExpr(nameSpec, classIsWild, methodIsWild);

        if (DEBUG) {
        	System.out.println("[" + ((inclusion) ? "+" : "-") + "," +
        		eventRank + ",static_method_exit]");
        	System.out.println("    class=" + descClassName);
        	System.out.println("    method=" + descMethodName);
            System.out.println("    argTypes=" + ((argTypes == null) ? "null"
            	: java.util.Arrays.toString(argTypes)));
        }

        edlSpec.addMethodChangeRequest(descClassName, descMethodName,
            argTypes, inclusion, eventRank++,
            MethodAction.STATIC_EXIT);
    }
}

/**
 * Production for EDL monitor contend events.
 */
private void monitor_contend__decl() :
{
    TokenList nameSpec = null;
    boolean isTotalWild = false;
    boolean isPkgWild = false;
}
{
    "monitor_contend" ("*" {isTotalWild=true;} |
    		(nameSpec=qualifiedName() (".*" {isPkgWild=true;})?))
        {
            processClassExpr(nameSpec, isTotalWild, isPkgWild);
            nameSpec = null;

            if (DEBUG) {
            	System.out.println("[" + ((inclusion) ? "+" : "-") + ",(" +
            		eventRank + "),monitor_contend] class=" + descClassName);
            }

            MonitorRequest req = edlSpec.createMonitorRequest(descClassName,
                inclusion, eventRank++, MonitorType.CONTEND);
        }
        locationBlock(req)
    {
        edlSpec.addMonitorRequest(req);
    }
}

/**
 * Production for EDL monitor acquired events.
 */
private void monitor_acquire__decl() :
{
    TokenList nameSpec = null;
    boolean isTotalWild = false;
    boolean isPkgWild = false;
}
{
    "monitor_acquire" ("*" {isTotalWild=true;} |
    		(nameSpec=qualifiedName() (".*" {isPkgWild=true;})?))
        {
            processClassExpr(nameSpec, isTotalWild, isPkgWild);
            nameSpec = null;

            if (DEBUG) {
            	System.out.println("[" + ((inclusion) ? "+" : "-") + ",(" +
            		eventRank + "),monitor_acquire] class=" + descClassName);
            }

            MonitorRequest req = edlSpec.createMonitorRequest(descClassName,
                inclusion, eventRank++, MonitorType.ACQUIRE);
        }
        locationBlock(req)
    {
        edlSpec.addMonitorRequest(req);
    }
}

/**
 * Production for EDL monitor pending release events.
 */
private void monitor_pre_release__decl() :
{
    TokenList nameSpec = null;
    boolean isTotalWild = false;
    boolean isPkgWild = false;
}
{
    "monitor_pre_release" ("*" {isTotalWild=true;} |
    		(nameSpec=qualifiedName() (".*" {isPkgWild=true;})?))
        {
            processClassExpr(nameSpec, isTotalWild, isPkgWild);
            nameSpec = null;

            if (DEBUG) {
            	System.out.println("[" + ((inclusion) ? "+" : "-") + ",(" +
            		eventRank + "),monitor_pre_release] class=" +
            		descClassName);
            }

            MonitorRequest req = edlSpec.createMonitorRequest(descClassName,
                inclusion, eventRank++, MonitorType.PRE_RELEASE);
        }
        locationBlock(req)
    {
        edlSpec.addMonitorRequest(req);
    }
}

/**
 * Production for EDL monitor released events.
 */
private void monitor_release__decl() :
{
    TokenList nameSpec = null;
    boolean isTotalWild = false;
    boolean isPkgWild = false;
}
{
    "monitor_release" ("*" {isTotalWild=true;} |
    		(nameSpec=qualifiedName() (".*" {isPkgWild=true;})?))
        {
            processClassExpr(nameSpec, isTotalWild, isPkgWild);
            nameSpec = null;

            if (DEBUG) {
            	System.out.println("[" + ((inclusion) ? "+" : "-") + ",(" +
            		eventRank + "),monitor_release] class=" + descClassName);
            }

            MonitorRequest req = edlSpec.createMonitorRequest(descClassName,
                inclusion, eventRank++, MonitorType.RELEASE);
        }
        locationBlock(req)
    {
        edlSpec.addMonitorRequest(req);
    }
}

/**
 * Production for EDL exception raised events.
 */
private void throw__decl() :
{
    TokenList nameSpec = null;
    boolean classIsWild = false;
    boolean subclasses = false;
}
{
    "throw" ("*" {classIsWild=true;} | (nameSpec=qualifiedName()
    		("+s" {subclasses=true;})?))
        {
            processClassExpr(nameSpec, classIsWild, false);
            nameSpec = null;

            if (DEBUG) {
            	System.out.println("[" + ((inclusion) ? "+" : "-") + ",(" +
            		eventRank + "),throw] class=" + descClassName);
            	System.out.println("    andSubclasses=" + subclasses);
            }

            ThrowRequest req = edlSpec.createThrowRequest(descClassName,
                subclasses, inclusion, eventRank++);
        }
        locationBlock(req)
    {
        edlSpec.addThrowRequest(req);
    }
}

/**
 * Production for EDL exception caught events.
 */
private void catch__decl() :
{
    TokenList nameSpec = null;
    boolean classIsWild = false;
    boolean subclasses = false;
}
{
    "catch" ("*" {classIsWild=true;} | (nameSpec=qualifiedName() ("+s" {subclasses=true;})?))
        {
            processClassExpr(nameSpec, classIsWild, false);
            nameSpec = null;

			if (DEBUG) {
            	System.out.println("[" + ((inclusion) ? "+" : "-") + ",(" +
            		eventRank + "),catch] class=" + descClassName);
            	System.out.println("    andSubclasses=" + subclasses);
           	}

            CatchRequest req = edlSpec.createCatchRequest(descClassName,
                subclasses, inclusion, eventRank++);
        }
        locationBlock(req)
    {
        edlSpec.addCatchRequest(req);
    }
}

/**
 * Production for EDL static initializer entry event requests.
 */
private void static_init_enter__decl() :
{
    TokenList nameSpec = null;
    boolean isTotalWild = false;
    boolean isPkgWild = false;
}
{
    "static_init_enter" ("*" {isTotalWild=true;} |
    	(nameSpec=qualifiedName() (".*" {isPkgWild=true;})?))
    {
        processClassExpr(nameSpec, isTotalWild, isPkgWild);

       	if (DEBUG) {
        	System.out.println("[" + ((inclusion) ? "+" : "-") + "," +
        		eventRank + ",static_init_enter] class=" + descClassName);
        }

        edlSpec.addStaticInitializerEntryRequest(descClassName, inclusion,
            eventRank++);
    }
}

/**
 * Production for EDL array element read event requests.
 *
 * A &lt;UINT&gt; is a positive integer (whole number) value, with no
 * leading zeros.
 */
private void array_element_load__decl() :
{
    Type javaType;
    Token minTok = null;
    Token maxTok = null;
}
{
    "array_element_load"
    		("*" {javaType=SemanticConstants.TYPE_ANY;} | javaType=argType())
    		("min:" minTok=<UINT>)? ("max:" maxTok=<UINT>)?
        {
            ArrayElementBounds bounds =
                processArrayElementBounds(javaType, minTok, maxTok);
            minTok = maxTok = null;

            if (DEBUG) {
                System.out.println("[" + ((inclusion) ? "+" : "-") + ",(" +
                	eventRank + "),array_element_load]");
                System.out.println("    type=" + javaType);
                System.out.print("    min=" +
                    ((bounds.min != ArrayElementBounds.NO_BOUND)
                    ? bounds.min : "none"));
                System.out.println(", max=" +
                    ((bounds.max != ArrayElementBounds.NO_BOUND)
                    ? bounds.max : "none"));
            }

            ArrayElementRequest req = edlSpec.createArrayElementRequest(
                bounds, inclusion, eventRank++, ArrayElementType.LOAD);
        }
        locationBlock(req)
    {
        edlSpec.addArrayElementRequest(req);
    }
}

/**
 * Production for EDL array element write event requests.
 *
 * A &lt;UINT&gt; is a positive integer (whole number) value, with no
 * leading zeros.
 */
private void array_element_store__decl() :
{
    Type javaType;
    Token minTok = null;
    Token maxTok = null;
}
{
    "array_element_store"
    		("*" {javaType=SemanticConstants.TYPE_ANY;} | javaType=argType())
    		("min:" minTok=<UINT>)? ("max:" maxTok=<UINT>)?
        {
            ArrayElementBounds bounds =
                processArrayElementBounds(javaType, minTok, maxTok);
            minTok = maxTok = null;

            if (DEBUG) {
                System.out.println("[" + ((inclusion) ? "+" : "-") + ",(" +
                	eventRank + "),array_element_store]");
                System.out.println("    type=" + javaType);
                System.out.print("    min=" +
                    ((bounds.min != ArrayElementBounds.NO_BOUND)
                    ? bounds.min : "none"));
                System.out.println(", max=" +
                    ((bounds.max != ArrayElementBounds.NO_BOUND)
                    ? bounds.max : "none"));
            }

            ArrayElementRequest req = edlSpec.createArrayElementRequest(
                bounds, inclusion, eventRank++, ArrayElementType.STORE);
        }
        locationBlock(req)
    {
        edlSpec.addArrayElementRequest(req);
    }
}

/**
 * Production for EDL location constraint blocks for event requests.
 *
 * Because of greedy token matching in the qualifiedName() subrule,
 * the expectation that the name of a method may be given as the string
 * after the final "." in the qualified name string is not formally
 * encoded by the grammar, except in the case of wildcard requests.
 */
private void locationBlock(EGEventRequest req) throws ParseException :
{
    // It is ambiguous whether the string following the last "." is a final
    // component of the class name, or the method name. The qualifiedName()
    // production greedily consumes it as part of the class name, and it
    // would be highly complicated to parameterize that production to behave
    // otherwise. It is simpler to just inspect the last token in the list
    // returned by qualifiedName() and deduce the appropriate semantics
    // manually; therefore there is no explicit production for a method
    // expression. The grammar still makes it illegal to specify argument
    // types for a wildcard selection of methods, in any case.
 
    TokenList nameSpec = null;
    boolean isInCondition = false;
    boolean classIsWild = false;
    boolean methodIsWild = false;
    Type[] argTypes = null;

    EventConditions ecs = req.conditions();
}
{
    "{"
    (("in" {isInCondition=true;} | "not" {isInCondition=false;})
        ("*" {classIsWild=true;}
        | (nameSpec=qualifiedName()
            ((".*" {methodIsWild=true;}) | argTypes=argsExpr())
          )
        )
      {
        processClassAndMethodExpr(nameSpec, classIsWild, methodIsWild);
        nameSpec = null;

        if (isInCondition) {
        	if (DEBUG) {
            	System.out.println("    [" + eventRank + ",in] ");
            }

            ecs.addInCondition(descClassName, descMethodName, argTypes,
                inclusion, eventRank++);
        }
        else {
        	if (DEBUG) {
            	System.out.println("    [" + eventRank + ",not] ");
            }

            ecs.addNotCondition(descClassName, descMethodName, argTypes,
                inclusion, eventRank++);
        }

        if (DEBUG) {
        	System.out.println("      class=" + descClassName);
        	System.out.println("      method=" + descMethodName);
            System.out.println("      argTypes=" + ((argTypes == null) ? "null"
            	: java.util.Arrays.toString(argTypes)));
        }
        
        argTypes = null;
      }
    )*
    "}"
}

/**
 * Production for method argument expressions used in method selection
 * expressions (e.g. for specifying method signatures for matching
 * methods).
 */
private Type[] argsExpr() :
{
    // An array return type is used, instead of a list, to make it more
    // convenient to interface with BCEL.
    
    List<Type> argTypes = null;
    Type curType = null;
}
{
    ("*"   // null is the marker for this
    | curType=voidArg()
        { argTypes = new ArrayList<Type>(1);
          argTypes.add(curType);
        }
    | (curType=argType()
        { argTypes = new ArrayList<Type>(4);
          argTypes.add(curType); }
        ("," curType=argType() { argTypes.add(curType); })*)
    | { Type[] argTypesArr; }
      argTypesArr=jniMethodSignature()
      { return argTypesArr; }
    )
    {
        if (argTypes != null) {
            return (Type[]) argTypes.toArray(new Type[argTypes.size()]);
        }
        else {
            return null;
        }
    }
}

/**
 * Production for the "void" argument type.
 *
 * The void argument type is really a placeholder expression to express
 * a specific match only with a method taking no arguments. It cannot
 * be combined with any other argument types, thus a separate production.
 */
private Type voidArg() :
{}
{
    ("void" | "V")
    { return Type.VOID; }
}

/**
 * Production for an argument type declaration.
 */
private Type argType() :
{
    Type javaType = null;
    TokenList nameSpec = null;
}
{
    // The shorthand tokens -- for common type names and JNI primitive
    // type codes -- are ambiguous with a general qualified name.
    // Lookahead gives preference to the shorthand tokens (and the
    // associated fast mapping to type constants). Technically the
    // parser won't fail without these lookaheads.
    // The predictor for the JNI object type rule is also ambiguous
    // with a qualified name, so lookahead is used to ensure the
    // correct match. The parser will fail without this lookahead.
    ( LOOKAHEAD( basicTypeName() )    javaType=basicTypeName()
    | LOOKAHEAD( jniPrimitiveType() ) javaType=jniPrimitiveType()
    | ( LOOKAHEAD( jniObjectType() )
        javaType=jniObjectType()
      | javaType=jniArrayType()
      | nameSpec=qualifiedName()
      )
    )
    {
        if (nameSpec != null) {
            // (javaType must be null)

            String typeStr = tokensToString(nameSpec).toString();
            //System.out.println("argType: qualifiedName=" + typeStr);

            Type typeSub = typeNames.get(typeStr);
            if (typeSub != null) {
                javaType = typeSub;
                //System.out.println("    substitution=" + typeSub);
            }
            else {
                javaType = new ObjectType(typeStr);
            }
        }

        return javaType;
    }
}

/**
 * Production for basic type names, provided by EDL for
 * convenience/readability.
 *
 * Note that "string" corresponds internally to "java.lang.String".
 */
private Type basicTypeName() :
{
    Type javaType;
}
{
    ( "byte"    { javaType = Type.BYTE; }
    | "char"    { javaType = Type.CHAR; }
    | "double"  { javaType = Type.DOUBLE; }
    | "float"   { javaType = Type.FLOAT; }
    | "int"     { javaType = Type.INT; }
    | "long"    { javaType = Type.LONG; }
    | "boolean" { javaType = Type.BOOLEAN; }
    | "short"   { javaType = Type.SHORT; }
    | "string"  { javaType = Type.STRING; }
    )
    { return javaType; }
}

/**
 * Production for JNI format primitive type codes.
 *
 * The type code for <code>void</code> ("V") is omitted for the reason
 * described in the voidArg() production.
 */
private Type jniPrimitiveType() :
{
    Type javaType;
}
{
    ( "B" { javaType = Type.BYTE; }
    | "C" { javaType = Type.CHAR; }
    | "D" { javaType = Type.DOUBLE; }
    | "F" { javaType = Type.FLOAT; }
    | "I" { javaType = Type.INT; }
    | "J" { javaType = Type.LONG; }
    | "Z" { javaType = Type.BOOLEAN; }
    | "S" { javaType = Type.SHORT; }
    )
    { return javaType; }
}

/**
 * Union production for all reference type declarations in JNI format
 * (object and array types).
 */
private Type jniReferenceType() :
{
    Type javaType;
}
{
    (javaType=jniArrayType() | javaType=jniObjectType())
    { return javaType; }
}

/**
 * Production for array type declarations in JNI format.
 */
private Type jniArrayType() :
{
    Type elemType;
    int dims = 0;
}
{
    ("[" { dims++; })+ (LOOKAHEAD(2) elemType=jniPrimitiveType()
		| elemType=jniObjectType())
    {
        return new ArrayType(elemType, dims);
    }
}

/**
 * Production for object type declarations in JNI format.
 *
 * The expected "L" prefix is not explicitly enforced by the grammar
 * because of the difficulty in differentiating it from an
 * identifier in the lexer, due to the "maximal munch" rule.
 */
private Type jniObjectType() :
{
    Token start;
}
{
    { Token head = getToken(1); }
    start=javaIdentifier() ("/" javaIdentifier())* ";"
    {
        // Because of the maximal munch rule, the lexer wants to
        // consume the (required) leading L as part of a JAVA_ID.
        // It appears that fixing this would require that we:
        //   * factor 'L' out of the regex for the first letter
        //     of a JAVA_ID
        //   * write a grammar rule for Java IDs to express the
        //     validity of L at the start of an identifier
        //   * replace all uses of the JAVA_ID lexer token with
        //     the grammar rule
        //   * use lookahead wherever we need to disambiguate
        //     between a Java ID and a JNI type signature
        // The complexity of the above doesn't seem justified just
        // to avoid the following slightly hackish solution (note
        // that this action can only be triggered after the input
        // has matched the whole rule/template for a JNI type
        // signature, which cannot be ambiguous with any other
        // input that we would expect to see).
        if (start.image.charAt(0) != 'L') {
            throw new ParseException("Invalid JNI type signature: " +
                "encountered \"" + start.image.charAt(0) + "\" at line " +
                start.beginLine + ", column " + start.beginColumn + ".\n" +
                "Was expecting:\n    \"L\"");
        }

        String typeStr = tokensToString(head, getToken(0));
        return Type.getType(typeStr);
    }
}

/**
 * Production for a method signature declaration in JNI format.
 *
 * The formal specification for the JNI method signature format is as
 * follows:
 *
 * "(" ( jniObjectType() | jniArrayType() | jniPrimitiveType() )* ")"
 *     ( jniObjectType() | jniArrayType() | jniPrimitiveType() | "V" )
 *
 * Due to the considerable complexity in both lexer and parser of
 * disambiguating the various token types and subrules, particularly
 * in the presence of the additional shorthand notations provided by
 * EDL, this production accepts essentially freeform inputs consisting
 * of the characters that may legally appear in a JNI signature. The
 * task of validating the signature is deferred (normally to BCEL).
 *
 * At the current time, EDL ignores the return type component of the
 * signature. It is accepted, however, to reduce the burden for
 * tools that might mechanically generate EDL and would likely want
 * to generate signatures in their full, standard format.
 */
private Type[] jniMethodSignature() :
{}
{
    // This accepts essentially freeform input for the type strings,
    // as long as the input at least consists of characters
    // that can legally comprise some part of a JNI type signature.
    // The determination of whether it is (even remotely) well formed
    // is left to the BCEL parsing routine, since the maximal munch
    // rule in the lexer makes a mess of trying to describe the full
    // legal structure of a JNI method signature (in light of the
    // other ways we accept input for specifying argument types).

    { Token head = getToken(1); }
    "(" (javaIdentifier() | "[" | "/" | ";")* ")"
    	(javaIdentifier() | "V" | "[" | "/" | ";")+
    {
        String typeStr = tokensToString(head, getToken(0));
        try {
            return Type.getArgumentTypes(typeStr);
        }
        catch (org.apache.bcel.classfile.ClassFormatException e) {
            throw new ParseException("Invalid JNI method signature at " +
                head.beginLine + ", column " + head.beginColumn + " (" +
                "\"" + typeStr + "\")");
        }
    }
}

/**
 * Production for a package-qualified Java class (type) name.
 */
private TokenList qualifiedName() :
{}
{
    { Token head = getToken(1); }
    (javaIdentifier() ("." javaIdentifier())*)
    {
        return new TokenList(head, getToken(0));
    }
}

/**
 * Production for a basic (unqualified) Java identifier.
 *
 * To improve the efficiency of the parser, the productions
 * basicTypeName() and jniPrimitiveType() are defined. These productions
 * induce distinct token types that take precedence in the lexer over the
 * Java identifier token matching in some contexts. However, they are
 * (at least theoretically) still legal Java identifiers (or constituents
 * of a package name, for which the production is defined in terms
 * of Java identifiers). To ensure that EDL accepts them as Java
 * identifiers in productions that do not involve basicTypeName() and/or
 * jniPrimitiveType() subrules, this production must be provided and
 * used.
 * 
 * In cases where combinations of the ambiguous productions are
 * permitted, syntactic lookead is used to resolve in favor of the
 * more specialized productions (basicTypeName(), jniPrimitiveType()).
 */
private Token javaIdentifier() :
{
    // In the parts of the grammar that handle parsing of argument types,
    // it is efficient to let certain shorthand inputs be mapped directly
    // to corresponding BCEL Type constants by the generated parser code
    // (using actions; see the jniPrimitiveType() rule, for example).
    // To support this, those shorthand inputs have to be processed as
    // literal tokens in the lexer, which takes precedence over their
    // inclusion as part of a JAVA_ID. However, some are still technically
    // valid identifier characters/strings, so to support proper parsing of
    // JAVA_ID tokens they have to be "reintroduced" as legal components of
    // an identifier here, in the grammar. This avoids the need for
    // special handling where the grammar permits a qualifiedName
    // but not any of the shorthand notations (the common case).
    //
    // When parsing argument types, lookahead is used to resolve the
    // ambiguity that results from the possibility of using both
    // qualified names and shorthand inputs to specify the types.

    Token tok;
}
{
    ( tok="string"
    | tok="B"
    | tok="C"
    | tok="D"
    | tok="F"
    | tok="I"
    | tok="J"
    | tok="Z"
    | tok="S"
    | tok=<JAVA_ID>
    )
    { return tok; }
}





