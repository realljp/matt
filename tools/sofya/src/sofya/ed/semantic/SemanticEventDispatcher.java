/*
 * Copyright 2003-2007, Regents of the University of Nebraska
 *
 *  Licensed under the University of Nebraska Open Academic License,
 *  Version 1.0 (the "License"); you may not use this file except in
 *  compliance with the License. The License must be provided with
 *  the distribution of this software; if the license is absent from
 *  the distribution, please report immediately to galileo@cse.unl.edu
 *  and indicate where you obtained this software.
 *
 *  You may also obtain a copy of the License at:
 *
 *      http://sofya.unl.edu/LICENSE-1.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */

package sofya.ed.semantic;

import java.io.*;
import java.util.*;
import java.util.concurrent.Semaphore;
import java.net.Socket;
import java.net.ServerSocket;
import java.net.InetAddress;
import java.net.BindException;
import java.net.UnknownHostException;

import com.sun.jdi.*;

/*#ifdef FAST_JDI
import edu.unl.jdi.Bootstrap;
import edu.unl.jdi.ClassType;
import edu.unl.jdi.ObjectReference;
import edu.unl.jdi.ThreadReference;
import edu.unl.jdi.VirtualMachine;
import edu.unl.jdi.VirtualMachineManager;
import edu.unl.jdi.connect.*;
import edu.unl.jdi.event.*;
import edu.unl.jdi.request.*;
/*#else*/
import com.sun.jdi.connect.*;
import com.sun.jdi.event.*;
import com.sun.jdi.request.*;
/*#endif*/

import sofya.base.ProjectDescription;
import sofya.base.StreamRedirector;
import sofya.base.StreamReplicator;
import sofya.ed.semantic.EventSpecification.*;
import sofya.ed.semantic.EventListener.*;
import sofya.ed.semantic.FieldInterceptorData.FieldInterceptor;
import static sofya.ed.semantic.SemanticConstants.*;
import static sofya.ed.semantic.InstrumentationMetadata.*;
import static sofya.ed.semantic.JDIEventManager.REQUEST_ID;
import static sofya.ed.semantic.JDIEventManager.FIELD_DATA;

import gnu.trove.THashSet;
import gnu.trove.TLongHashSet;
import gnu.trove.THashMap;


/**
 * Class which generates the stream of observable events occurring in a
 * traced program. Events are dispatched to registered listeners,
 * which can be used to set up a filtering chain and eventually reach
 * an event target class which processes or stores the events
 * in some way.</p>
 *
 * @author Alex Kinneer
 * @version 01/17/2007
 */
@SuppressWarnings("unchecked")
public class SemanticEventDispatcher {
    /** Semantic event dispatch data generated by the instrumentor. */
    private SemanticEventData edData;
    /** Event specification, normally extracted from the event data file. */
    private EventSpecification[] eventSpecs;
    /** The main class used to launch the system. */
    private String mainClass;
    /** Arguments to the system. */
    private List<String> classArgs = new ArrayList<String>();
    /** Maximum memory to make available to the VM in which the
        subject will run. */
    private String maxMem = "768m";

    /** Registered event listeners. An array is used because events are
        dispatched to all listeners, and this tool will normally observe
        a **lot** of events. In any case, we don't expect listeners to
        be added or removed mid-run in normal use, so the overhead associated
        with managing the array manually is considered to be mitigated. */
    private EventListener[] listeners = new EventListener[4];
    /** Number of listeners currently registered. */
    private int listenerCount = 0;

    /** Mirror of the virtual machine in which the system is running. */
    protected VirtualMachine vm;

    /** String table obtained from the module data file. */
    private String[] stringTable;

    /** Information on all of the method interceptors present in the subject,
        used to set breakpoints. Obtained from the module data file. */
    @SuppressWarnings("unused")
    private Map<Object, Object> interceptors;

    /** Thread ID map. */ 
    private Map<ThreadReference, ThreadData> threads = new THashMap();
    /** Next available thread ID. */
    private int nextThreadId = 1;

    /** Flag which indicates that the start event has occurred, so that it
        won't be issued again. */
    private boolean startEventReceived = false;

    /** Stores a reference to the type representation of the probe class,
        used to set the flag field that releases preparing threads
        on class prepare events. */
    private ClassType probeClassTyperef;
    /** Cached copy of the field used to indicate to the dynamic
        instrumentation thread the class loader that loaded a
        class for which a bytestream has been requested. */
    private Field probeClassLoaderField;

    //=============== Start - New variables, for cleanup =================
    private static final StreamReplicator stdin =
        new StreamReplicator(System.in, System.err);
    private static Thread stdinThread;
    private Integer stdinId;
    private boolean interactiveStdin = true;

    private long numEvents = 0;
    public static final boolean COUNT_EVENTS = true;
    
    private JDIEventManager jdiEventManager;
    private final Set<String> liveKeys = new THashSet();

    private Process proc;
    private volatile long lastEventTime;
    private final Semaphore messageLock = new Semaphore(1, true);
    private boolean launched = false;
    private int interruptFlag = 0;
    private volatile boolean isRunning = false;
    
    private List<Object> instManagerRequestors = new LinkedList<Object>();

    //private ThreadGroupReference systemThreadGroup;
    private ThreadGroupReference mainThreadGroup;
    private Field detachedFlagField;
    private ModificationWatchpointRequest signalFieldWatchpoint;

    private LinkConnector instLink;
    private InstrumentationManager instManager;
    private ThreadReference instManagerThread;
    private String defaultClassLoader;

    private final Set<String> systemClasses = new THashSet();
    
    Field badField = null;

    private ThreadData[] knownThreads;
    
    private static final int INTERRUPT_REDEFINE = 1;
    private static final int INTERRUPT_DETACH = 2;
    private static final int INTERRUPT_HALT = 3;

    // Convert to configuration options later.
    // First flag is a misnomer, to be corrected later. It really just
    // enables/disables the creation of the agent jar and activation
    // in the target program, which is no longer necessary here but
    // being retained for reference to assist in future implementation
    // of dynamic instrumentation the structural event dispatchers
    private static final boolean USE_DEADLOCK_DETECTION = false;
    public static final long DEADLOCK_TIMEOUT = 30000;
    private static final long INTERRUPT_TIMEOUT = 25;
    private static final boolean ASSERTS = false;

    //=============== End - New variables, for cleanup =================

    // For repeated comparison against a constant string, experiments show
    // that comparing against the stored hash code of the constant string
    // before calling equals() yields between 50% and 100% speedup, since
    // the more expensive equals() method only needs to be called when the
    // comparison string is actually the same or in the much less frequent
    // case of a hash collision.

    /** Cached copy of the hash code for the string name of
        <code>java.util.Class</code>. */
    private static final int classStrHash = "java.lang.Class".hashCode();
    /** Cached copy of the hash code for the string name of the probe class. */
    private static final int probeStrHash =
            SemanticInstrumentor.PROBE_CLASS.hashCode();

    private static final int signalFieldNameHash =
            SIGNAL_FIELD_NAME.hashCode();
    /** Cached copy of the hash code for the string name of the thread started
        by the probe class to send class bytes to the event dispatcher for
        adaptive instrumentation. Speeds the matching required to prevent
        dispatch of a thread started event for this thread. */
    private static final int probeMngThreadNameHash =
            InstrumentationManager.THREAD_NAME.hashCode();

    /**
     * Creates an uninitialized new event dispatcher.
     *
     * <p>When using this constructor, at a minimum you must call
     * {@link #setMainClass} and {@link #setEDData} before attempting to
     * call {@link #startDispatcher}.</p>
     */
    public SemanticEventDispatcher() { }

    /**
     * Creates a ready to run event dispatcher.
     *
     * @param edData Event dispatch data, as read from an event dispatch
     * data file produced by the instrumentor.
     * @param mainClassName Name of the main class from which the system is
     * launched.
     * @param args Arguments to be passed in when the system is launched
     * (may be zero-length, but not <code>null</code>).
     */
    public SemanticEventDispatcher(SemanticEventData edData,
            String mainClassName, String[] args) {
        if ((edData == null) || (mainClassName == null) || (args == null)) {
            throw new NullPointerException();
        }

        setEDData(edData);
        setMainClass(mainClassName);
        for (int i = 0; i < args.length; i++) {
            addArgument(args[i]);
        }
    }

    /**
     * Creates a ready to run event dispatcher.
     *
     * @param edData Event dispatch data, as read from an event dispatch
     * data file produced by the instrumentor.
     * @param interactiveStdin Specifies whether the standard input stream
     * is connected to an interactive source, such as a console (see
     * {@link #interactiveStandardInput(boolean)}).
     * @param mainClassName Name of the main class from which the system is
     * launched.
     * @param args Arguments to be passed in when the system is launched
     * (may be zero-length, but not <code>null</code>).
     */
    public SemanticEventDispatcher(SemanticEventData edData,
            boolean interactiveStdin, String mainClassName, String[] args) {
        if ((edData == null) || (mainClassName == null) || (args == null)) {
            throw new NullPointerException();
        }

        this.interactiveStdin = interactiveStdin;
        setEDData(edData);
        setMainClass(mainClassName);
        for (int i = 0; i < args.length; i++) {
            addArgument(args[i]);
        }
    }

    /**
     * Gets the event dispatch data object which the event dispatcher is
     * currently using.
     *
     * @return The event dispatch data currently in use by the
     * event dispatcher.
     */
    public SemanticEventData getEDData() {
        return edData;
    }

    /**
     * Sets the event dispatch data to be used by the event dispatcher.
     *
     * @param edData Event dispatch data object, as read from an event
     * dispatch data file produced by the instrumentor.
     */
    public void setEDData(SemanticEventData edData) {
        if (isRunning) {
            throw new IllegalStateException("Cannot change event data " +
                "while event dispatcher is running");
        }
        this.edData = edData;
        this.eventSpecs = edData.getEventSpecificationsArray(true);
    }
    
    private final void processEventData() {
        this.stringTable = edData.getStringTable();
        this.interceptors = edData.getCallInterceptors();

        this.systemClasses.clear();
        int startIdx = eventSpecs.length - 1;
        for (int i = startIdx; i >= 0; i--) {
            this.eventSpecs[i].getSystemClassNames(this.systemClasses);
        }
        
        /*System.out.println("interceptors:");
        int clCount = interceptors.size();
        Iterator clIter = interceptors.keySet().iterator();
        for (int i = clCount; i-- > 0; ) {
            String className = (String) clIter.next();
            System.out.println("    " + className);

            Set methods = (Set) interceptors.get(className);
            Iterator nameIter = methods.iterator();
            int nameCount = methods.size();
            for (int j = nameCount; j-- > 0; ) {
                System.out.println("        " + (String) nameIter.next());
            }
        }*/
    }

    /**
     * Gets the main class which this module tracer will use or has used to
     * launch the system.
     *
     * @return The class which the module tracer has been instructed to use
     * as the launching class of the system.
     */
    public String getMainClass() {
        return mainClass;
    }

    /**
     * Sets the main class which will be used by the module tracer to launch
     * the system.
     *
     * @param mainClass The class which the module tracer has been instructed
     * to used as the launching class of the system.
     */
    public void setMainClass(String mainClass) {
        this.mainClass = mainClass;
    }

    /**
     * Gets the arguments to be passed to the system when launched.
     *
     * @return An unmodifiable list of the arguments which will be or have
     * been passed to the system when launched.
     */
    public List<String> getArguments() {
        return Collections.unmodifiableList(classArgs);
    }

    /**
     * Gets an argument from the argument list.
     *
     * @param index Index of the argument to be retrieved.
     *
     * @return The argument at the given index in the arguments list.
     */
    public String getArgument(int index) {
        return (String) classArgs.get(index);
    }

    /**
     * Adds an argument to list of arguments to be passed to the system when
     * launched.
     *
     * @param arg Argument to be added to the argument list.
     */
    public void addArgument(String arg) {
        classArgs.add(arg);
    }

    /**
     * Removes an argument from the argument list.
     *
     * @param index Index of the argument to be removed from the arguments list.
     *
     * @return The argument at the given index in the arguments list.
     */
    public String removeArgument(int index) {
        return (String) classArgs.remove(index);
    }

    /**
     * Removes an argument from the argument list.
     *
     * @param arg Argument to be removed from the argument list.
     *
     * @return <code>true</code> if a matching argument was successfully
     * removed from the arguments list.
     */
    public boolean removeArgument(String arg) {
        Iterator iterator = classArgs.iterator();
        int size = classArgs.size();
        for (int i = size; i-- > 0; ) {
            String curArg = (String) iterator.next();
            if (curArg.equals(arg)) {
                iterator.remove();
                return true;
            }
        }
        return false;
    }

    /**
     * Removes all arguments from the argument list.
     */
    public void clearArguments() {
        classArgs.clear();
    }

    /**
     * Registers a listener for observable events with the event dispatcher.
     *
     * @param listener Object that wishes to receive notifications of
     * events related to observables in the system.
     */
    public void addEventListener(EventListener listener) {
        if (listenerCount == listeners.length) {
            EventListener[] temp = new EventListener[listeners.length + 4];
            System.arraycopy(listeners, 0, temp, 0, listeners.length);
            listeners = temp;
        }
        listeners[listenerCount++] = listener;
    }

    /**
     * Unregisters a listener for observable events from the event dispatcher.
     *
     * @param listener Object that no longer wishes to receive notifications
     * of events related to observables in the system.
     */
    public void removeEventListener(EventListener listener) {
        listenerCount -= 1;
        if (listeners[listenerCount] == listener) {
            listeners[listenerCount] = null; // For GC
            return;
        }

        for (int i = listenerCount - 1; i >= 0; i--) {
            if (listeners[i] == listener) {
                int lastIndex = listeners.length - 1;
                System.arraycopy(listeners, i + 1, listeners, i,
                                 lastIndex - i);
                listeners[lastIndex] = null;  // For GC
                return;
            }
        }
    }

    /**
     * Registers or unregisters a listener to receive a reference
     * to the instrumentation manager before the object program begins
     * executing.
     *
     * @param requestor Listener to be registered to receive the
     * instrumentation manager.
     * @param enable <code>true</code> if the listener is to be
     * registered, <code>false</code> if the listener is to be
     * unregistered.
     */
    public void requestInstrumentationManager(
            InstrumentationManagerRequestor requestor, boolean enable) {
        if (enable) {
            instManagerRequestors.add(requestor);
        }
        else {
            instManagerRequestors.remove(requestor);
        }
    }

    /**
     * Gets the instrumentation manager interface to this event dispatcher.
     *
     * <p>This method returns <code>null</code> if called before
     * {@link SemanticEventDispatcher#launchTarget}.</p>
     *
     * @return The instrumentation manager that can be used to control
     * adaptive instrumentation in program being executed by this event
     * dispatcher, if supported.
     */
    public InstrumentationManager getInstrumentationManager() {
        return instManager;
    }
    
    /**
     * Specifies whether the standard input stream is connected to an
     * interactive source (such as a console).
     * 
     * <p>This determines whether the event dispatcher enables special
     * command handling on standard input.</p>
     * 
     * @param state <code>true</code> to enable special command handling
     * on standard input, <code>false</code> to disable and guarantee
     * that received input is forwarded verbatim.
     * 
     * @return The previous state of this setting.
     */
    public boolean interactiveStandardInput(boolean state) {
        boolean wasAlready = interactiveStdin;
        interactiveStdin = state;
        return wasAlready;
    }
    
    public long getEventCount() {
        if (COUNT_EVENTS) {
            return numEvents;
        }
        else {
            throw new UnsupportedOperationException();
        }
    }

    private void findRunnableTargetField(ThreadReference t) {
        ReferenceType threadType = t.referenceType();

        // Try the common case: Sun implementation
        try {
            Field threadTargetField = threadType.fieldByName("target");
            if (threadTargetField != null) {
                System.out.println("Thread runnable target field: " +
                    threadTargetField);
                EventListener.ThreadData.setTargetField(vm, threadTargetField);
                return;
            }
        }
        catch (ClassNotPreparedException e) {
            // Obviously the thread class must be prepared before any
            // threads can run...
            InternalError ie = new InternalError("Could not query thread " +
                "class");
            ie.initCause(e);
            throw ie;
        }

        List threadFields = null;
        try {
            threadFields = threadType.allFields();
        }
        catch (ClassNotPreparedException e) {
            // Obviously the thread class must be prepared before any
            // threads can run...
            InternalError ie = new InternalError("Could not query thread " +
                "class");
            ie.initCause(e);
            throw ie;
        }

        int size = threadFields.size();
        Iterator iterator = threadFields.iterator();
        for (int i = size; i-- > 0; ) {
            Field curField = (Field) iterator.next();
            if (curField.typeName().equals("java.lang.Runnable")) {
                System.out.println("Thread runnable target field: " +
                    curField);
                EventListener.ThreadData.setTargetField(vm, curField);
                return;
            }
        }
        
        throw new AssertionError("Could not find thread runnable field");
    }

    /**
     * Internal handler for the virtual machine start event.
     */
    protected void vmStarted(ThreadReference t) {
        findRunnableTargetField(t);

        mainThreadGroup = t.threadGroup();
        //systemThreadGroup = mainThreadGroup.parent();

        for (int i = 0; i < listenerCount; i++) {
            listeners[i].systemStarted();
        }
    }

    /**
     * Internal handler for the start of user code execution event.
     */
    protected void enteredUserCode() {
        for (int i = 0; i < listenerCount; i++) {
            listeners[i].executionStarted();
        }
    }

    /**
     * Internal handler for thread start events.
     *
     * @param tse JDI event raised by the thread starting.
     */
    protected void threadStarted(ThreadStartEvent tse) {
        ThreadReference threadRef = tse.thread();
        String threadName = threadRef.name();

        if (threadName.hashCode() == probeMngThreadNameHash) {
            if (threadName.equals(InstrumentationManager.THREAD_NAME)) {
                instManagerThread = threadRef;
                return;
            }
        }

        ThreadData td = new ThreadData(vm, nextThreadId, threadRef);
        nextThreadId++;
        
        threads.put(threadRef, td);

        for (int i = 0; i < listenerCount; i++) {
            listeners[i].threadStartEvent(td);
        }
    }

    /**
     * Internal handler for thread termination events.
     *
     * @param tde JDI event raised by the thread terminating.
     */
    protected void threadDied(ThreadDeathEvent tde) {
        ThreadReference threadRef = tde.thread();
        String threadName = threadRef.name();

        if (threadName.hashCode() == probeMngThreadNameHash) {
            if (threadRef.equals(instManagerThread)) {
                return;
            }
        }
        
        ThreadData td = threads.remove(threadRef);

        for (int i = 0; i < listenerCount; i++) {
            listeners[i].threadDeathEvent(td);
        }
    }

    protected void classPrepared(ThreadReference t, ReferenceType rType)
            throws InternalException {
        String className = rType.name();
        // System.out.println("class prepared[2]: " + className);

        jdiEventManager.requestFieldEvents(rType);

        if (!(rType instanceof InterfaceType)) {
            jdiEventManager.requestBreakpoints(rType);
        }

        liveKeys.clear();
        int startIdx = eventSpecs.length - 1;
        for (int i = startIdx; i >= 0; i--) {
            if (eventSpecs[i].witnessThrow(className)) {
                liveKeys.add(eventSpecs[i].getKey());
            }
        }
        if (liveKeys.size() > 0) {
            jdiEventManager.enableExceptionEvent(liveKeys, rType);
        }

        ThreadData td = threads.get(t);

        for (int i = 0; i < listenerCount; i++) {
            listeners[i].classPrepareEvent(td, className);
        }

        try {
            // System.out.println("Setting prepared flag");
            Field clPreparedFlagField =
                jdiEventManager.getClassPreparedFlagField(rType);
            // Null if interface
            if (clPreparedFlagField != null) {
                ClassType clTypeRef = (ClassType) rType;
                clTypeRef.setValue(clPreparedFlagField, vm.mirrorOf((byte) 1));
            }
        }
        catch (Exception e) {
            throw new InternalException("Could not set class prepared " +
                "release flag", e);
        }
    }

    /**
     * Internal handler for monitor contention events.
     *
     * @param t JDI reference to the thread which is contending for
     * the monitor.
     * @param obj Reference to the object which owns the monitor
     * under contention.
     * @param loc JDI location of the monitor contention event.
     */
    protected void monitorContend(ThreadReference t, ObjectReference obj,
            Location loc) {
        ThreadData td = threads.get(t);
        ObjectData od = new ObjectData(obj);
        MonitorData md = new MonitorData(loc);

        for (int i = 0; i < listenerCount; i++) {
            listeners[i].monitorContendEvent(td, od, md);
        }
    }

    /**
     * Internal handler for monitor acquisition events.
     *
     * @param t JDI reference to the thread which acquired the monitor.
     * @param obj Reference to the object which owns the acquired monitor.
     * @param loc JDI location of the monitor acquisition event.
     */
    protected void monitorAcquire(ThreadReference t, ObjectReference obj,
            Location loc) {
        ThreadData td = threads.get(t);
        ObjectData od = new ObjectData(obj);
        MonitorData md = new MonitorData(loc);

        for (int i = 0; i < listenerCount; i++) {
            listeners[i].monitorAcquireEvent(td, od, md);
        }
    }

    /**
     * Internal handler for monitor will be released events.
     *
     * @param t JDI reference to the thread which is about to release a
     * monitor.
     * @param obj Reference to the object which owns the monitor
     * about to be released.
     * @param loc JDI location of the monitor releasing event.
     */
    protected void monitorReleasing(ThreadReference t, ObjectReference obj,
            Location loc) {
        ThreadData td = threads.get(t);
        ObjectData od = new ObjectData(obj);
        MonitorData md = new MonitorData(loc);

        for (int i = 0; i < listenerCount; i++) {
            listeners[i].monitorPreReleaseEvent(td, od, md);
        }
    }

    /**
     * Internal handler for monitor release events.
     *
     * @param t JDI reference to the thread which is has released
     * the monitor.
     * @param obj Reference to the object which owns the monitor
     * that was released.
     * @param loc JDI location of the monitor release event.
     */
    protected void monitorReleased(ThreadReference t, ObjectReference obj,
            Location loc) {
        ThreadData td = threads.get(t);
        ObjectData od = new ObjectData(obj);
        MonitorData md = new MonitorData(loc);

        for (int i = 0; i < listenerCount; i++) {
            listeners[i].monitorReleaseEvent(td, od, md);
        }
    }

    /**
     * Internal handler for new object allocation events.
     *
     * @param t JDI reference to the thread in which the new object allocation
     * occurred.
     * @param className Name of the class of the newly allocated object.
     * @param loc JDI location of the new object allocation event.
     */
    protected void newAllocation(ThreadReference t, String className,
            Location loc) {
        ThreadData td = threads.get(t);
        NewAllocationData nad = new NewAllocationData(className, loc);

        for (int i = 0; i < listenerCount; i++) {
            listeners[i].newAllocationEvent(td, nad);
        }
    }

    /**
     * Internal handler for object construction events.
     *
     * @param t JDI reference to the thread in which the object construction
     * occurred.
     * @param signature Parsable signature of the constructor which was invoked.
     * @param loc JDI location of the constructor invocation.
     */
    protected void constructorInvoked(ThreadReference t, String signature,
            Location loc) {
        ThreadData td = threads.get(t);
        CallData cd = new CallData(signature, loc);

        for (int i = 0; i < listenerCount; i++) {
            listeners[i].constructorCallEvent(td, cd);
        }
    }

    /**
     * Internal handler for constructor entry events.
     *
     * @param t JDI reference to the thread which entered the constructor.
     * @param obj JDI reference to the object for which the constructor
     * was invoked.
     * @param signature Parsable signature of the entered constructor.
     */
    protected void constructorEntered(BreakpointEvent event, ThreadReference t,
            /*#ifdef FAST_JDI List<? extends edu.unl.jdi.StackFrame> frames,
            /*#endif*/
            ObjectReference obj, String signature)
            throws InternalException {
        ThreadData td = threads.get(t);
        ObjectData od = new ObjectData(obj);
        /*#ifdef FAST_JDI
        edu.unl.jdi.StackFrame methodFrame = frames.get(1);
        Arguments args = new Arguments(methodFrame.thisObject(event),
            methodFrame.getValues(event));
        /*#else*/
        Arguments args = getArguments(t);
        /*#endif*/
        MethodData md = new MethodData(signature, args);

        for (int i = 0; i < listenerCount; i++) {
            listeners[i].constructorEnterEvent(td, od, md);
        }
    }

    /**
     * Internal handler for constructor exit events.
     *
     * @param t JDI reference to the thread which exited the constructor.
     * @param obj JDI reference to the object for which the constructor
     * was invoked.
     * @param signature Parsable signature of the exited constructor.
     */
    protected void constructorExited(ThreadReference t, ObjectReference obj,
            String signature, int flagBits) {
        boolean isExceptional = (flagBits & 0x00100000) > 0;
        
        ThreadData td = threads.get(t);
        ObjectData od = new ObjectData(obj);
        MethodData md = new MethodData(signature);

        for (int i = 0; i < listenerCount; i++) {
            listeners[i].constructorExitEvent(td, od, md, isExceptional);
        }
    }

    /**
     * Internal handler for field access events.
     *
     * @param awe JDI event raised by the field access.
     */
    protected void fieldAccessed(AccessWatchpointEvent awe)
            throws InternalException {
        Field field = awe.field();
        String fieldName = field.declaringType().name() + "." + field.name();
        boolean isStatic = field.isStatic();
        FieldType fType = (isStatic) ? FieldType.GETSTATIC : FieldType.GETFIELD;
        
        Type javaType = null;
        try {
            javaType = field.type();
        }
        catch (ClassNotLoadedException e) {
            throw new InternalException("Could not obtain Java type for " +
                "accessed field");
        }

        Location loc = awe.location();
        String className = loc.declaringType().name();
        String methodName = loc.method().name();
        String methodSig = loc.method().signature();

        checkEnabled: {
            int startIdx = eventSpecs.length - 1;
            for (int i = startIdx; i >= 0; i--) {
                if (eventSpecs[i].witnessField(fieldName, fType, javaType,
                        className, methodName, methodSig)) {
                    break checkEnabled;
                }
            }
            return;
        }

        ThreadReference thread = awe.thread();
        ThreadData td = threads.get(thread);
        Value val = awe.valueCurrent();
        FieldData fd = new FieldData(field, awe.location(), val);

        if (isStatic) {
            for (int i = 0; i < listenerCount; i++) {
                listeners[i].staticFieldAccessEvent(td, fd);
            }
        }
        else {
            ObjectData od = new ObjectData(awe.object());
            for (int i = 0; i < listenerCount; i++) {
                listeners[i].instanceFieldAccessEvent(td, od, fd);
            }
        }
    }
    
    protected void staticFieldAccessed(BreakpointEvent event,
            ThreadReference t, Field field,
            Value val, Location loc) {
        ThreadData td = threads.get(t);

        FieldData fd = new FieldData(field, loc, val);
        
        /*#ifdef FAST_JDI
        // The following is contingent on the assumption of single
        // threaded access
        td.setTransactionEvent(event);
        /*#endif*/
        
        for (int i = 0; i < listenerCount; i++) {
            listeners[i].staticFieldAccessEvent(td, fd);
        }
        
        /*#ifdef FAST_JDI
        td.clearTransactionEvent();
        /*#endif*/
    }
    
    protected void instanceFieldAccessed(BreakpointEvent event,
            ThreadReference t, ObjectReference obj, Field field,
            Value val, Location loc) {
        ThreadData td = threads.get(t);

        FieldData fd = new FieldData(field, loc, val);
        ObjectData od = new ObjectData(obj);
        
        /*#ifdef FAST_JDI
        // The following is contingent on the assumption of single
        // threaded access
        td.setTransactionEvent(event);
        /*#endif*/
        
        for (int i = 0; i < listenerCount; i++) {
            listeners[i].instanceFieldAccessEvent(td, od, fd);
        }
        
        /*#ifdef FAST_JDI
        td.clearTransactionEvent();
        /*#endif*/
    }
    
    /**
     * Internal handler for array element access events.
     *
     * <p>The default implementation dispatches array element access events
     * as regular field access events. Technically, these are more like
     * pseudo-events, where the field information corresponds to the
     * individual element of the array in question. The field name is
     * taken to be the name of the field holding the array reference,
     * annoted by the index of the element. The effect is that array
     * elements are transparently treated as individual fields accessible
     * at the same scope as the field holding the array reference, which
     * is of course the semantics of arrays in Java. This makes the
     * treatment of array elements transparent to analyses that are,
     * strictly speaking, only interested in memory locations (which is
     * true of most analyses). Note that the access to the field holding
     * the array reference will be dispatched as a field access event
     * prior to events corresponding to individual elements of the array.</p>
     *
     * @param t JDI reference to the thread that read from the array.
     * @param array Reference to the array that is being accessed.
     * @param index Index of the array element that is being accessed.
     * @param loc JDI location of the array element access event.
     */
    protected void arrayElementAccessed(BreakpointEvent event,
            ThreadReference t, ArrayReference array, Value elemValue,
            int index, Location loc) {
        ThreadData td = threads.get(t);
        ObjectData od = new ObjectData(array);
        ArrayType arrayType = (ArrayType) array.type();
        
        /*Value elemValue = null;
        try {
            elemValue = array.getValue(index);
        }
        catch (IndexOutOfBoundsException e) {
            Type componentType = null;
            try {
                componentType = arrayType.componentType();
            }
            catch (ClassNotLoadedException e2) {
                // Null will be handled by the value object
            }
            elemValue = new BadArrayIndexValue(index, componentType,
                array.virtualMachine());
        }*/
        FieldData fd = new ArrayElementData(arrayType, index, loc, elemValue);

        /*#ifdef FAST_JDI
        // The following is contingent on the assumption of single
        // threaded access
        td.setTransactionEvent(event);
        /*#endif*/
        
        for (int i = 0; i < listenerCount; i++) {
            listeners[i].instanceFieldAccessEvent(td, od, fd);
        }
        
        /*#ifdef FAST_JDI
        td.clearTransactionEvent();
        /*#endif*/
    }

    /**
     * Internal handler for field write events.
     *
     * @param mwe JDI event raised for the field write.
     */
    protected void fieldWritten(ModificationWatchpointEvent mwe)
            throws InternalException {
        Field field = mwe.field();
        String fieldName = field.declaringType().name() + "." + field.name();
        boolean isStatic = field.isStatic();
        FieldType fType = (isStatic) ? FieldType.PUTSTATIC : FieldType.PUTFIELD;
        
        Type javaType = null;
        try {
            javaType = field.type();
        }
        catch (ClassNotLoadedException e) {
            throw new InternalException("Could not obtain Java type for " +
                "accessed field");
        }

        Location loc = mwe.location();
        String className = loc.declaringType().name();
        String methodName = loc.method().name();
        String methodSig = loc.method().signature();

        checkEnabled: {
            int startIdx = eventSpecs.length - 1;
            for (int i = startIdx; i >= 0; i--) {
                if (eventSpecs[i].witnessField(fieldName, fType, javaType,
                        className, methodName, methodSig)) {
                    break checkEnabled;
                }
            }
            return;
        }

        ThreadReference thread = mwe.thread();
        ThreadData td = threads.get(thread);
        FieldData fd = new FieldData(field, mwe.location(),
            mwe.valueCurrent(), mwe.valueToBe());

        if (isStatic) {
            for (int i = 0; i < listenerCount; i++) {
                listeners[i].staticFieldWriteEvent(td, fd);
            }
        }
        else {
            ObjectData od = new ObjectData(mwe.object());
            for (int i = 0; i < listenerCount; i++) {
                listeners[i].instanceFieldWriteEvent(td, od, fd);
            }
        }
    }
    
    protected void staticFieldWritten(BreakpointEvent event,
            ThreadReference t, Field field,
            Value valueCurrent, Value valueToBe, Location loc) {
        ThreadData td = threads.get(t);
        FieldData fd = new FieldData(field, loc, valueCurrent, valueToBe);

        /*#ifdef FAST_JDI
        // The following is contingent on the assumption of single
        // threaded access
        td.setTransactionEvent(event);
        /*#endif*/
        
       for (int i = 0; i < listenerCount; i++) {
            listeners[i].staticFieldWriteEvent(td, fd);
        }
        
        /*#ifdef FAST_JDI
        td.clearTransactionEvent();
        /*#endif*/
    }
    
    protected void instanceFieldWritten(BreakpointEvent event,
            ThreadReference t, ObjectReference obj, Field field,
            Value valueCurrent, Value valueToBe, Location loc) {
        ThreadData td = threads.get(t);
        FieldData fd = new FieldData(field, loc, valueCurrent, valueToBe);
        ObjectData od = new ObjectData(obj);

        /*#ifdef FAST_JDI
        // The following is contingent on the assumption of single
        // threaded access
        td.setTransactionEvent(event);
        /*#endif*/

        for (int i = 0; i < listenerCount; i++) {
            listeners[i].instanceFieldWriteEvent(td, od, fd);
        }
        
        /*#ifdef FAST_JDI
        td.clearTransactionEvent();
        /*#endif*/
    }

    /**
     * Internal handler for array element write events.
     *
     * <p>The default implementation dispatches array element write events
     * as regular field write events. Technically, these are more like
     * pseudo-events, where the field information corresponds to the
     * individual element of the array affected. The field name is taken
     * to be the name of the field holding the array reference, annoted
     * by the index of the element. The effect is that array elements
     * are transparently treated as individual fields accessible at the
     * same scope as the field holding the array reference, which is of
     * course the semantics of arrays in Java. This makes the treatment
     * of array elements transparent to analyses that are, strictly
     * speaking, only interested in memory locations (which is true
     * of most analyses). Note that the access to the field holding
     * the array reference will be dispatched as a field access event
     * prior to events corresponding to individual elements of the array.</p>
     *
     * @param t JDI reference to the thread that wrote to the array.
     * @param array Reference to the array that is being written.
     * @param index Index of the array element that is being written.
     * @param valueToBe Value that is to be written to the array element.
     * @param loc JDI location of the array element write event.
     */
    protected void arrayElementWritten(BreakpointEvent event,
            ThreadReference t, ArrayReference array, Value currentValue,
            int index, Value valueToBe, Location loc) {
        ThreadData td = threads.get(t);
        ObjectData od = new ObjectData(array);
        ArrayType arrayType = (ArrayType) array.type();
        
        /*Value currentValue = null;
        try {
            currentValue = array.getValue(index);
        }
        catch (IndexOutOfBoundsException e) {
            Type componentType = null;
            try {
                componentType = arrayType.componentType();
            }
            catch (ClassNotLoadedException e2) {
                // Null will be handled by the value object
            }
            currentValue = new BadArrayIndexValue(index, componentType,
                array.virtualMachine());
        }*/
        
        FieldData fd = new ArrayElementData(arrayType, index, loc,
            currentValue, valueToBe);

        /*#ifdef FAST_JDI
        // The following is contingent on the assumption of single
        // threaded access
        td.setTransactionEvent(event);
        /*#endif*/

        for (int i = 0; i < listenerCount; i++) {
            listeners[i].instanceFieldWriteEvent(td, od, fd);
        }
        
        /*#ifdef FAST_JDI
        td.clearTransactionEvent();
        /*#endif*/
    }

    /**
     * Gets the values of the actual arguments passed to a method,
     * either from a call interceptor or on entry to a monitored
     * method.
     *
     * @param t Thread in which the call or method entry occurred.
     * @param loc Location associated with the bytecode probe that
     * raised the event.
     *
     * @return The {@link EventListener} wrapper object for
     * accessing the argument values.
     *
     * @throws InternalException If the thread state or JDI state
     * prevent access to the argument values.
     */
    private final Arguments getArguments(ThreadReference t)
            throws InternalException {
        StackFrame frameHere = null;
        try {
            frameHere = t.frame(1);
        }
        catch (IncompatibleThreadStateException e) {
            throw new InternalException("Thread not suspended", e);
        }

        List<LocalVariable> argVars = null;
        try {
             argVars = frameHere.visibleVariables();
        }
        catch (AbsentInformationException e) {
            throw new InternalException("Argument values not available", e);
        }

        // It appears that intermittently, this may cause an internal
        // exception, because the frame in the debugee has already been
        // popped by the time the callback request for argument
        // information has been received. This is a bug in the JDI --
        // apparently a problem with an unreliable implementation of
        // the suspend_all policy for event requests -- and
        // so sadly there is no apparent fix at this time.
        return new Arguments(frameHere.thisObject(), argVars,
            frameHere.getValues(argVars));
    }
    
    /**
     * Internal handler for static call events.
     *
     * @param t JDI reference to the thread in which the static call occurred.
     * @param signature Parsable signature of the called method.
     * @param loc JDI location of the method call.
     * @param flagBits Flag bitmask extracted from the probe.
     */
    protected void staticCall(ThreadReference t, String signature,
            Location loc, int flagBits) throws InternalException {
        //int threadId = threads.get(t);
        boolean isIntercept = (flagBits & 0x00100000) > 0;
        boolean isNative = (flagBits & 0x00200000) > 0;

        Arguments args;
        if (isIntercept) {
            StackFrame frameHere = null;
            StackFrame frameCaller = null;
            try {
                frameHere = t.frame(1);
                frameCaller = t.frame(2);
            }
            catch (IncompatibleThreadStateException e) {
                throw new InternalException("Thread not suspended", e);
            }

            List<LocalVariable> argVars = null;
            try {
                argVars = frameHere.visibleVariables();
            }
            catch (AbsentInformationException e) {
                throw new InternalException("Argument values " +
                    "not available", e);
            }

            args = new Arguments(true, argVars, frameHere.getValues(argVars));

            if (args == null) {
                System.err.println("WARNING: Argument information not " +
                    "available for intercepted method");
                isIntercept = false;
            }

            Location trueLoc = frameCaller.location();
            if (trueLoc != null) {
                loc = trueLoc;
            }
        }
        else {
            args = null;
        }

        ThreadData td = threads.get(t);

        //ThreadData td = new ThreadData(threadId, t);
        CallData cd = new CallData(signature, loc, args,
            isIntercept, isNative);

        for (int i = 0; i < listenerCount; i++) {
            listeners[i].staticCallEvent(td, cd);
        }
    }

    /**
     * Internal handler for virtual call events.
     *
     * @param t JDI reference to the thread in which the virtual call occurred.
     * @param signature Parsable signature of the called method.
     * @param loc JDI location of the method call.
     * @param flagBits Flag bitmask extracted from the probe.
     */
    protected void virtualCall(ThreadReference t, String signature,
            Location loc, int flagBits) throws InternalException {
        //int threadId = threads.get(t);
        boolean isIntercept = (flagBits & 0x00100000) > 0;

        Arguments args;
        if (isIntercept) {
            StackFrame frameHere = null;
            StackFrame frameCaller = null;
            try {
                frameHere = t.frame(1);
                frameCaller = t.frame(2);
            }
            catch (IncompatibleThreadStateException e) {
                throw new InternalException("Thread not suspended", e);
            }

            List<LocalVariable> argVars = null;
            try {
                argVars = frameHere.visibleVariables();
            }
            catch (AbsentInformationException e) {
                throw new InternalException("Argument values " +
                    "not available", e);
            }

            args = new Arguments(false, argVars, frameHere.getValues(argVars));

            if (args == null) {
                System.err.println("WARNING: Argument information not " +
                    "available for intercepted method");
                isIntercept = false;
            }

            Location trueLoc = frameCaller.location();
            if (trueLoc != null) {
                loc = trueLoc;
            }
        }
        else {
            args = null;
        }

        ThreadData td = threads.get(t);

        //ThreadData td = new ThreadData(threadId, t);
        CallData cd = new CallData(signature, loc, args, isIntercept);

        for (int i = 0; i < listenerCount; i++) {
            listeners[i].virtualCallEvent(td, cd);
        }
    }

    /**
     * Internal handler for interface call events.
     *
     * @param t JDI reference to the thread in which the interface call
     * occurred.
     * @param signature Parsable signature of the called method.
     * @param loc JDI location of the method call.
     * @param flagBits Flag bitmask extracted from the probe.
     */
    protected void interfaceCall(ThreadReference t, String signature,
            Location loc, int flagBits) throws InternalException {
        //int threadId = threads.get(t);
        boolean isIntercept = (flagBits & 0x00100000) > 0;

        Arguments args;
        if (isIntercept) {
            StackFrame frameHere = null;
            StackFrame frameCaller = null;
            try {
                frameHere = t.frame(1);
                frameCaller = t.frame(2);
            }
            catch (IncompatibleThreadStateException e) {
                throw new InternalException("Thread not suspended", e);
            }

            List<LocalVariable> argVars = null;
            try {
                argVars = frameHere.visibleVariables();
            }
            catch (AbsentInformationException e) {
                throw new InternalException("Argument values " +
                    "not available", e);
            }

            args = new Arguments(false, argVars, frameHere.getValues(argVars));


            if (args == null) {
                System.err.println("WARNING: Argument information not " +
                    "available for intercepted method");
                isIntercept = false;
            }

            Location trueLoc = frameCaller.location();
            if (trueLoc != null) {
                loc = trueLoc;
            }
        }
        else {
            args = null;
        }

        ThreadData td = threads.get(t);

        //ThreadData td = new ThreadData(threadId, t);
        CallData cd = new CallData(signature, loc, args, isIntercept);

        for (int i = 0; i < listenerCount; i++) {
            listeners[i].interfaceCallEvent(td, cd);
        }
    }

    /**
     * Internal handler for method call return events.
     *
     * @param t JDI reference to the thread in which the call return
     * occurred.
     * @param signature Parsable signature of the method from which the
     * return occurred.
     * @param loc JDI location of the method call from which the
     * return occurred.
     * @param flagBits Flag bitmask extracted from the probe.
     */
    protected void callReturned(ThreadReference t, String signature,
            Location loc, int flagBits) {
        //int threadId = threads.get(t);
        boolean isExceptional = (flagBits & 0x00100000) > 0;

        ThreadData td = threads.get(t);

        //ThreadData td = new ThreadData(threadId, t);
        CallData cd = new CallData(signature, loc);

        for (int i = 0; i < listenerCount; i++) {
            listeners[i].callReturnEvent(td, cd, isExceptional);
        }
    }

    /**
     * Internal handler for virtual method entry events.
     *
     * @param t JDI reference to the thread which entered the virtual method.
     * @param obj JDI reference to the object on which the virtual method
     * was invoked.
     * @param signature Parsable signature of the entered method.
     */
    protected void virtualMethodEntered(BreakpointEvent event,
            /*#ifdef FAST_JDI List<? extends edu.unl.jdi.StackFrame> frames,
            /*#endif*/
            ThreadReference t, ObjectReference obj,
            Location loc, String signature) throws InternalException {
        ThreadData td = threads.get(t);
        ObjectData od = new ObjectData(obj);
        /*#ifdef FAST_JDI
        edu.unl.jdi.StackFrame methodFrame = frames.get(1);
        Arguments args = new Arguments(methodFrame.thisObject(event),
            methodFrame.getValues(event));
        /*#else*/
        Arguments args = null;
        try {
            args = getArguments(t);
        }
        catch (com.sun.jdi.InternalException e) {
            System.out.println(loc);
            throw e;
        }
        /*#endif*/
        MethodData md = new MethodData(signature, args);

        for (int i = 0; i < listenerCount; i++) {
            listeners[i].virtualMethodEnterEvent(td, od, md);
        }
    }

    /**
     * Internal handler for virtual method exit events.
     *
     * @param t JDI reference to the thread which exited the virtual method.
     * @param obj JDI reference to the object on which the virtual method
     * was invoked.
     * @param signature Parsable signature of the exited method.
     */
    protected void virtualMethodExited(ThreadReference t, ObjectReference obj,
            String signature, int flagBits) {
        //int threadId = threads.get(t);
        boolean isExceptional = (flagBits & 0x00100000) > 0;
        
        ThreadData td = threads.get(t);

        //ThreadData td = new ThreadData(threadId, t);
        ObjectData od = new ObjectData(obj);
        MethodData md = new MethodData(signature);

        for (int i = 0; i < listenerCount; i++) {
            listeners[i].virtualMethodExitEvent(td, od, md, isExceptional);
        }
    }

    /**
     * Internal handler for static method entry events.
     *
     * @param t JDI reference to the thread which entered the static method.
     * @param signature Parsable signature of the entered method.
     */
    protected void staticMethodEntered(ThreadReference t, String signature)
            throws InternalException {
        //int threadId = threads.get(t);
        
        ThreadData td = threads.get(t);

        //ThreadData td = new ThreadData(threadId, t);
        Arguments args = getArguments(t);
        // This ensures that the arguments cannot return a
        // value for the 'this' reference
        args.setStatic(true);
        MethodData md = new MethodData(signature, args);

        for (int i = 0; i < listenerCount; i++) {
            listeners[i].staticMethodEnterEvent(td, md);
        }
    }

    /**
     * Internal handler for static method exit events.
     *
     * @param t JDI reference to the thread which exited the static method.
     * @param signature Parsable signature of the exited method.
     */
    protected void staticMethodExited(ThreadReference t, String signature,
            int flagBits) {
        //int threadId = threads.get(t);
        boolean isExceptional = (flagBits & 0x00100000) > 0;
        
        ThreadData td = threads.get(t);

        //ThreadData td = new ThreadData(threadId, t);
        MethodData md = new MethodData(signature);

        for (int i = 0; i < listenerCount; i++) {
            listeners[i].staticMethodExitEvent(td, md, isExceptional);
        }
    }

    /**
     * Internal handler for exception throw events.
     *
     * @param ee JDI event raised by the exception throw.
     */
    protected void exceptionThrown(ExceptionEvent ee) {
        ReferenceType exceptionType = ee.exception().referenceType();
        Location loc = ee.location();

        String className = loc.declaringType().name();
        String methodName = loc.method().name();
        String methodSig = loc.method().signature();

        checkEnabled: {
            int startIdx = eventSpecs.length - 1;
            for (int i = startIdx; i >= 0; i--) {
                if (eventSpecs[i].witnessThrow(exceptionType.name(),
                        className, methodName, methodSig)) {
                    break checkEnabled;
                }
            }
            return;
        }

        ThreadReference thread = ee.thread();
        //int threadId = threads.get(thread);
        
        ThreadData td = threads.get(thread);

        //ThreadData td = new ThreadData(threadId, thread);
        ExceptionData ed =
            new ExceptionData(exceptionType, loc);

        for (int i = 0; i < listenerCount; i++) {
            listeners[i].exceptionThrowEvent(td, ed);
        }
    }

    /**
     * Internal handler for exception catch events.
     *
     * @param t JDI reference to the thread in which the exception catch
     * occurred.
     * @param type Type of the caught exception.
     * @param loc JDI location of the caught exception.
     */
    protected void exceptionCaught(ThreadReference t,
            Type type, Location loc) {
        //int threadId = threads.get(t);
        
        ThreadData td = threads.get(t);

        //ThreadData td = new ThreadData(threadId, t);
        ExceptionData ed = new ExceptionData(type, loc);

        for (int i = 0; i < listenerCount; i++) {
            listeners[i].exceptionCatchEvent(td, ed);
        }
    }

    /**
     * Internal handler for static initializer entry events.
     *
     * @param t JDI reference to the thread in which has entered
     * the static initializer.
     * @param signature Parsable signature of the entered method
     * (useful for determining which class initializer is being run).
     */
    protected void staticInitializerEntered(ThreadReference t,
            String signature) {
        //int threadId = threads.get(t);
        
        ThreadData td = threads.get(t);

        //ThreadData td = new ThreadData(threadId, t);
        MethodData md = new MethodData(signature);

        for (int i = 0; i < listenerCount; i++) {
            listeners[i].staticInitializerEnterEvent(td, md);
        }
    }

    /**
     * Internal handler for the virtual machine death event.
     */
    protected void vmExited() {
        for (int i = 0; i < listenerCount; i++) {
            listeners[i].systemExited();
        }
    }

    /**
     * Processes an event recorded by a probe.
     *
     * @param be JDI breakpoint event.
     *
     * @throws InternalException If the probe code received is unrecognized.
     */
    protected void processProbe(BreakpointEvent be) throws InternalException {
        ThreadReference thread = be.thread();

        /*#ifdef FAST_JDI
        List<? extends edu.unl.jdi.StackFrame> frames = thread.frames(be);
        /*#else*/
        StackFrame frame = null;
        try {
            frame = thread.frame(0);
        }
        catch (IncompatibleThreadStateException e) {
            throw new InternalException("Thread not suspended", e);
        }
        /*#endif*/
        
        // A possible future optimization could be to cache the location
        // and argVars list somewhere, since they should be constant
        Location loc = be.location();

        /*#ifdef FAST_JDI
        Value[] argValues = frames.get(0).getValues(be);
        /*#else*/
        List<LocalVariable> argVars = null;
        try {
            //System.out.println(loc);
            argVars = loc.method().arguments();
        }
        catch (AbsentInformationException e) {
            throw new InternalException("Argument values not available", e);
        }
        
        // For the curious (performance implications...)
        // System.out.print(argVars.getClass());
        // System.out.println(":random_access:" +
        //     (argVars instanceof RandomAccess));

        Map<LocalVariable, Value> argValues = null;
        //try {
        argValues = frame.getValues(argVars);
        //}
        //catch (IllegalArgumentException e) {
        //    if (e.getMessage().indexOf("different than variable's method") != -1) {
        //        System.err.println("bkpt_loc=" + loc);
        //        System.err.println("argVars=" + argVars);
        //        Location frameLoc = frame.location();
        //        System.out.println("frame[0]=" + frameLoc);
        //        System.out.println("  method=" + frameLoc.method() + "+"
        //            + frameLoc.codeIndex());
        //    }
        //    throw e;
        //}
        /*#endif*/
        
        EventRequest request = be.request();
        TriggerKey reqId = (TriggerKey) request.getProperty(REQUEST_ID);
        switch (reqId.keyIndex) {
        case TriggerKey.ISTATIC_PACKET: {
            /*#ifdef FAST_JDI
            IntegerValue packet = (IntegerValue) argValues[0];
            /*#else*/
            IntegerValue packet = (IntegerValue) argValues.get(argVars.get(0));
            /*#endif*/
            int packetData = packet.value();
            int typeCode = packetData & 0xC0000000;

            switch (typeCode) {
            case TYPE_EVENT:
                int eventCode = (packetData & 0x3FFFFFFF) >>> 22;
                int strIndex = packetData & 0x000FFFFF;
                String strData = stringTable[strIndex];
                int flagBits;

                switch (eventCode) {
                case EVENT_START:
                    if (!startEventReceived) {
                        enteredUserCode();
                        startEventReceived = true;
                    }
                    break;
                case EVENT_NEW_OBJ:
                    newAllocation(thread, strData, loc);
                    break;
                case EVENT_CONSTRUCTOR:
                    constructorInvoked(thread, strData, loc);
                    break;
                case EVENT_STATIC_CALL:
                    flagBits = packetData & 0x00300000;
                    staticCall(thread, strData, loc, flagBits);
                    break;
               case EVENT_VIRTUAL_CALL:
                    flagBits = packetData & 0x00300000;
                    virtualCall(thread, strData, loc, flagBits);
                    break;
                case EVENT_INTERFACE_CALL:
                    flagBits = packetData & 0x00300000;
                    interfaceCall(thread, strData, loc, flagBits);
                    break;
                case EVENT_CALL_RETURN:
                    flagBits = packetData & 0x00300000;
                    callReturned(thread, strData, loc, flagBits);
                    break;
                case EVENT_SMETHOD_ENTER:
                    staticMethodEntered(thread, strData);
                    break;
                case EVENT_SMETHOD_EXIT:
                    flagBits = packetData & 0x00300000;
                    staticMethodExited(thread, strData, flagBits);
                    break;
                case EVENT_STATIC_INIT_ENTER:
                    staticInitializerEntered(thread, strData);
                    break;
                default:
                    throw new InternalException("Unknown event code: " +
                        eventCode);
                }
            case TYPE_ASSERT:
                break;
            default:
                break;
            }
            break;
        }
        case TriggerKey.IOBJECT_PACKET: {
            /*#ifdef FAST_JDI
            ObjectReference objRef = (ObjectReference) argValues[0];
            IntegerValue packet = (IntegerValue) argValues[1];
            /*#else*/
            ObjectReference objRef =
                (ObjectReference) argValues.get(argVars.get(0));
            IntegerValue packet = (IntegerValue) argValues.get(argVars.get(1));
            /*#endif*/
            int packetData = packet.value();
            int typeCode = packetData & 0xC0000000;

            switch (typeCode) {
            case TYPE_EVENT:
                int eventCode = (packetData & 0x3FFFFFFF) >>> 22;
                int strIndex = packetData & 0x000FFFFF;
                String strData = stringTable[strIndex];
                int flagBits;

                switch (eventCode) {
                case EVENT_VMETHOD_ENTER:
                    virtualMethodEntered(be,
                        /*#ifdef FAST_JDI frames, /*#endif*/ thread, objRef,
                        loc, strData);
                    break;
                case EVENT_VMETHOD_EXIT:
                    flagBits = packetData & 0x00300000;
                    virtualMethodExited(thread, objRef, strData, flagBits);
                    break;
                case EVENT_CONSTRUCTOR_ENTER:
                    constructorEntered(be, thread,
                        /*#ifdef FAST_JDI frames, /*#endif*/
                        objRef, strData);
                    break;
                case EVENT_CONSTRUCTOR_EXIT:
                    flagBits = packetData & 0x00300000;
                    constructorExited(thread, objRef, strData, flagBits);
                    break;
                default:
                    throw new InternalException("Unknown event code: " +
                        eventCode);
                }
            case TYPE_ASSERT:
                break;
            default:
                break;
            }
            break;
        }
        case TriggerKey.IMONITOR_PACKET: {
            /*#ifdef FAST_JDI
            ObjectReference objRef = (ObjectReference) argValues[0];
            /*#else*/
            ObjectReference objRef =
                (ObjectReference) argValues.get(argVars.get(0));
            /*#endif*/

            String objClassName = objRef.referenceType().name();
            if (objClassName.hashCode() == classStrHash) {
                if (objClassName.equals("java.lang.Class")) {
                    objClassName =
                        ((ClassObjectReference) objRef).reflectedType().name();
                }
            }

            int startIdx;
            /*#ifdef FAST_JDI
            ByteValue eventType = (ByteValue) argValues[1];
            /*#else*/
            ByteValue eventType = (ByteValue) argValues.get(argVars.get(1));
            /*#endif*/
            switch (eventType.intValue()) {
            case EVENT_MONITOR_CONTEND:
                startIdx = eventSpecs.length - 1;
                for (int i = startIdx; i >= 0; i--) {
                    if (eventSpecs[i].witnessMonitor(objClassName,
                            MonitorType.CONTEND)) {
                        monitorContend(thread, objRef, loc);
                        break;
                    }
                }
                break;
            case EVENT_MONITOR_ACQUIRE:
                startIdx = eventSpecs.length - 1;
                for (int i = startIdx; i >= 0; i--) {
                    if (eventSpecs[i].witnessMonitor(objClassName,
                            MonitorType.ACQUIRE)) {
                        monitorAcquire(thread, objRef, loc);
                        break;
                    }
                }
                break;
            case EVENT_MONITOR_PRE_RELEASE:
                startIdx = eventSpecs.length - 1;
                for (int i = startIdx; i >= 0; i--) {
                    if (eventSpecs[i].witnessMonitor(objClassName,
                            MonitorType.PRE_RELEASE)) {
                        monitorReleasing(thread, objRef, loc);
                        break;
                    }
                }
                break;
            case EVENT_MONITOR_RELEASE:
                startIdx = eventSpecs.length - 1;
                for (int i = startIdx; i >= 0; i--) {
                    if (eventSpecs[i].witnessMonitor(objClassName,
                            MonitorType.RELEASE)) {
                        monitorReleased(thread, objRef, loc);
                        break;
                    }
                }
                break;
            }
            break;
        }
        case TriggerKey.ICATCH_PACKET: {
            /*#ifdef FAST_JDI
            ClassObjectReference cor = (ClassObjectReference) argValues[0];
            /*#else*/
            ClassObjectReference cor =
                (ClassObjectReference) argValues.get(argVars.get(0));
            /*#endif*/
            exceptionCaught(thread, cor.reflectedType(), loc);
            break;
        }
        case TriggerKey.IFIELD_BREAKPOINT: {
            FieldInterceptor icpt =
                (FieldInterceptor) request.getProperty(FIELD_DATA);
            Field fld = icpt.field;
            
            /*#ifdef FAST_JDI
            loc = ((StackFrame) frames.get(1)).location();
            /*#else*/
            try {
                // Map back to "real" location (caller of trigger method)
                loc = thread.frame(1).location();
            }
            catch (IncompatibleThreadStateException e) {
                throw new InternalException("Thread not suspended", e);
            }
            /*#endif*/
            
            switch (icpt.eventCode) {
            case EVENT_GETSTATIC: {
                /*#ifdef FAST_JDI
                edu.unl.jdi.ReferenceType rType =
                    ((edu.unl.jdi.Field) fld).declaringType();
                Value val = rType.getValues(be).get(0);
                /*#else*/
                ReferenceType rType = fld.declaringType();
                Value val = rType.getValue(fld);
                /*#endif*/
                
                //System.out.println("GETSTATIC:" + fld + ", value=" + val);
                staticFieldAccessed(be, thread, fld, val, loc);
                break;
            }
            case EVENT_PUTSTATIC: {
                /*#ifdef FAST_JDI
                edu.unl.jdi.ReferenceType rType =
                    ((edu.unl.jdi.Field) fld).declaringType();
                Value curVal = rType.getValues(be).get(0);
                Value newVal = argValues[0];
                /*#else*/
                ReferenceType rType = fld.declaringType();
                Value curVal = rType.getValue(fld);
                Value newVal = argValues.get(argVars.get(0));
                /*#endif*/
                
                //System.out.println("PUTSTATIC:" + fld + ", " + curVal +
                //    " -> " + newVal);
                staticFieldWritten(be, thread, fld, curVal, newVal, loc);
                break;
            }
            case EVENT_GETFIELD: {
                /*#ifdef FAST_JDI
                ObjectReference rcvrObj = (ObjectReference) argValues[0];
                Value val = rcvrObj.getValues(be).get(0);
                /*#else*/
                ObjectReference rcvrObj =
                    (ObjectReference) argValues.get(argVars.get(0));
                Value val = rcvrObj.getValue(fld);
                /*#endif*/
                
                //System.out.println("GETFIELD:" + fld + ", obj=" + rcvrObj +
                //    ", value=" + val);
                instanceFieldAccessed(be, thread, rcvrObj, fld, val, loc);
                break;
            }
            case EVENT_PUTFIELD: {
                /*#ifdef FAST_JDI
                ObjectReference rcvrObj = (ObjectReference) argValues[0];
                Value curVal = rcvrObj.getValues(be).get(0);
                Value newVal = argValues[1];
                /*#else*/
                ObjectReference rcvrObj =
                        (ObjectReference) argValues.get(argVars.get(0));
                Value curVal = rcvrObj.getValue(fld);
                Value newVal = argValues.get(argVars.get(1));
                /*#endif*/
                
                //System.out.println("PUTFIELD:" + fld + ", obj=" + rcvrObj +
                //    ", " + curVal + " -> " + newVal);
                instanceFieldWritten(be, thread, rcvrObj, fld,
                    curVal, newVal, loc);
                break;
            }
            default:
                throw new InternalException("Unexpected event code: " +
                     icpt.eventCode);
            }
            
            break;
        }
        case TriggerKey.IARRAY_LOAD_BREAKPOINT: {
            /*#ifdef FAST_JDI
            loc = ((StackFrame) frames.get(1)).location();
            arrayElementAccessed(be, thread, (ArrayReference) argValues[0],
                argValues[1], ((IntegerValue) argValues[2]).intValue(), loc);
            /*#else*/
            arrayElementAccessed(be, thread,
                (ArrayReference) argValues.get(argVars.get(0)),
                argValues.get(argVars.get(1)),
                ((IntegerValue) argValues.get(argVars.get(2))).intValue(),
                loc);
            /*#endif*/
            break;
        }
        case TriggerKey.IARRAY_STORE_BREAKPOINT: {
            /*#ifdef FAST_JDI
            loc = ((StackFrame) frames.get(1)).location();
            arrayElementWritten(be, thread, (ArrayReference) argValues[0],
                argValues[1], ((IntegerValue) argValues[2]).intValue(),
                argValues[3], loc);
            /*#else*/
            arrayElementWritten(be, thread,
                (ArrayReference) argValues.get(argVars.get(0)),
                argValues.get(argVars.get(1)),
                ((IntegerValue) argValues.get(argVars.get(2))).intValue(),
                argValues.get(argVars.get(3)),
                loc);
            /*#endif*/
            break;
        }}
    }

    private final void processSignal(int signal) {
        switch (signal) {
        case SIGNAL_CONNECTED:
            int reqCount = instManagerRequestors.size();
            Iterator reqs = instManagerRequestors.iterator();
            for (int i = reqCount; i-- > 0; ) {
                InstrumentationManagerRequestor requestor =
                    (InstrumentationManagerRequestor) reqs.next();
                requestor.setInstrumentationManager(instManager);
            }
            jdiEventManager.releaseSignalFieldWatchpoint(
                signalFieldWatchpoint);
            signalFieldWatchpoint = null;
            instManagerRequestors = null;
            break;
        default:
            break;
        }
    }
    
    /**
     * Starts the threads to redirect the system's stdin, stdout, and
     * stderr streams.
     *
     * @param process Process object associated with the launched system.
     */
    protected void startIOThreads(Process process
            /*#ifdef FAST_JDI , Integer pid /*#endif*/) {
        StreamRedirector stdout, stderr;
        Thread thread;

        /*#ifdef FAST_JDI
        stdinId = pid;
        boolean connected =
            stdin.connectStream(process.getOutputStream(), true, true, pid);
        if (ASSERTS) {
            assert connected;
        }
        /*#else*/
        stdinId = stdin.connectStream(process.getOutputStream(), true, true);
        /*#endif*/
        stdin.broadcast(true);
        
        stdout = new StreamRedirector(process.getInputStream(), System.out,
                                      false, System.err);
        stderr = new StreamRedirector(process.getErrorStream(), System.err,
                                      false, System.err);
        if (stdinThread == null) {
            stdinThread = new Thread(stdin, "stdin"
                /*#ifdef FAST_JDI + "::" + pid /*#endif*/);
            stdinThread.setDaemon(true);
            stdinThread.start();
        }
        /*#ifdef FAST_JDI
        else {
            stdinThread.setName("stdin::" + pid);
        }
        /*#endif*/
        
        thread = new Thread(stdout, "stdout"
                /*#ifdef FAST_JDI + "::" + pid /*#endif*/);
        thread.start();
        thread = new Thread(stderr, "stderr"
                /*#ifdef FAST_JDI + "::" + pid /*#endif*/);
        thread.start();
    }

    /*************************************************************************
     * Copies a class loaded by the classloader to an output stream.
     *
     * @param cl Class to be copied.
     * @param stream Output stream to which the class bytes should be
     * written.
     * @param buffer Buffer which will be used to perform the copy
     * operation.
     *
     * @throws IOException If there is any error reading the class bytes
     * or writing to the stream.
     */
    @SuppressWarnings("unused")
    private void copyClassToStream(Class cl, OutputStream stream,
                                   byte[] buffer)
            throws IOException {
        ClassLoader cloader = cl.getClassLoader();
        if (cloader == null) {
            cloader = ClassLoader.getSystemClassLoader();
        }

        String className = cl.getName().replace('.', '/') + ".class";
        InputStream is =  cloader.getResourceAsStream(className);

        if (is == null) {
            throw new IOException("Could not find class '" + className +
                                  " on classpath");
        }

        try {
            int readCount;
            while ((readCount = is.read(buffer)) != -1) {
                stream.write(buffer, 0, readCount);
            }
        }
        finally {
            is.close();
        }
    }

    private int getOpenPort() throws InternalException {
        ServerSocket ss = null;
        try {
            ss = new ServerSocket(0);
            return ss.getLocalPort();
        }
        catch (IOException e) {
            // We'll try a linear search next
        }
        finally {
            if (ss != null) {
                try { ss.close(); } catch (IOException e) { }
            }
        }

        int cur_port = 1025;
        for ( ; cur_port <= 65535; cur_port++) {
            try {
                ss = new ServerSocket(cur_port, 1,
                    InetAddress.getByName("localhost"));
                break;
            }
            catch (BindException e) { }
            catch (UnknownHostException e) {
                throw new InternalException("Could not resolve " +
                    "\"localhost\"");
            }
            catch (IOException e) { }
        }

        if (cur_port > 65535) {
            throw new InternalException("Could not find open port");
        }
        if (ss != null) {
            try { ss.close(); } catch (IOException e) { }
        }

        return cur_port;
    }

    @SuppressWarnings("unused")
    private void dumpThreads(String loc) {
        System.out.println(loc);
        /*#ifdef FAST_JDI
        List threads = vm.<ThreadReference>allThreads();
        /*#else*/
        List threads = vm.allThreads();
        /*#endif*/
        Iterator tmpIter = threads.iterator();
        while (tmpIter.hasNext()) {
            ThreadReference tr = (ThreadReference) tmpIter.next();
            System.out.println(tr.name() + ": " + tr.status());
        }
    }

    private final void findReceivingFields(ReferenceType rType) {
        boolean foundPreparedFlagField = false;
        boolean foundClassLoaderField = false;

        List<Field> probeFields = rType.fields();
        Iterator<Field> iterator = probeFields.iterator();
        int size = probeFields.size();
        for (int i = size; i-- > 0; ) {
            Field f = iterator.next();
            String fName = f.name();

            if (!foundPreparedFlagField
                    && fName.equals(CPE_FLAG_FIELD_NAME)) {
                detachedFlagField = f;
                foundPreparedFlagField = true;
            }
            else if (!foundClassLoaderField
                    && fName.equals(CL_LOAD_FIELD_NAME)) {
                probeClassLoaderField = f;
                foundClassLoaderField = true;
            }

            if (foundPreparedFlagField && foundClassLoaderField) {
                return;
            }
        }
    }
    
    /**
     * Main event loop which receives events raised by the JDI and dispatches
     * them to the appropriate internal handlers.
     *
     * @param queue JDI event queue obtained from the mirrored JVM in which
     * the system is running.
     */
    private void eventLoop(EventQueue queue) throws InternalException {
        EventSet es = null;

        while (true) {
            try {
                switch (interruptFlag) {
                case INTERRUPT_REDEFINE:
                    es = queue.remove(INTERRUPT_TIMEOUT);
                    if (es == null) {
                        synchronized(this) {
                            interruptFlag = 0;
                            notify();
                        }
                        continue;
                    }
                    break;
                case INTERRUPT_DETACH:
                case INTERRUPT_HALT:
                    return;
                default:
                    es = queue.remove();
                    break;
                }

                lastEventTime = System.currentTimeMillis();
            }
            catch (InterruptedException e) {
                System.err.println("WARNING: Interrupt received in event " +
                    "loop; ignoring.");
                continue;
            }
            catch (VMDisconnectedException e) {
                throw new InternalException("Subject VM disconnected " +
                    "unexpectedly", e);
            }
            
            EventIterator iterator = es.eventIterator();
            int size = es.size();

            for (int i = size; i-- > 0; ) {
                Event event = iterator.nextEvent();
                
                if (COUNT_EVENTS) {
                    numEvents += 1;
                }

                if (event instanceof BreakpointEvent) {
                    processProbe((BreakpointEvent) event);
                }
                else if (event instanceof ModificationWatchpointEvent) {
                    ModificationWatchpointEvent mwe =
                        (ModificationWatchpointEvent) event;

                    Field fld = mwe.field();
                    String fieldName = fld.name();
                    if (fieldName.hashCode() == signalFieldNameHash) {
                        if (fld.declaringType().name().equals(
                                SemanticInstrumentor.PROBE_CLASS)) {
                            int signal = ((IntegerValue)
                                mwe.valueToBe()).value();
                            processSignal(signal);
                        }
                        continue;
                    }

                    fieldWritten(mwe);
                }
                else if (event instanceof AccessWatchpointEvent) {
                    fieldAccessed((AccessWatchpointEvent) event);
                }
                else if (event instanceof ClassPrepareEvent) {
                    ClassPrepareEvent cpe = (ClassPrepareEvent) event;

                    // See note on ClassPrepareEvent in JDI JavaDocs
                    if (cpe.thread() == null) {
                        continue;
                    }

                    ReferenceType rType = cpe.referenceType();
                    String className = rType.name();

                    ClassLoaderReference clLoader = rType.classLoader();
                    String loaderName = null;
                    if (clLoader != null) {
                        loaderName = clLoader.referenceType().name();
                    }

                    if ((className.hashCode() == probeStrHash)
                            && className.equals(SemanticInstrumentor.PROBE_CLASS)) {
                        probeClassTyperef = (ClassType) rType;
                        findReceivingFields(rType);
                        
                        jdiEventManager.requestProbeBreakpoints(
                            probeClassTyperef);
                        
                        signalFieldWatchpoint = jdiEventManager.
                            requestSignalFieldWatchpoint(probeClassTyperef);

                        // We're going to assume that whatever class loader
                        // loads the probe class is the default class
                        // loader. Since the probe will be loaded before
                        // any user code, and by the same thread that will
                        // execute main, this is a reasonable assumption.
                        if (ASSERTS) assert loaderName != null;
                        defaultClassLoader = loaderName;
                        //System.out.println("default class loader= " +
                        //    defaultClassLoader);
                    }
                    else if ("sun.reflect.UnsafeStaticFieldAccessorImpl".equals(
                            className)) {
                        // Contains a dangerous field that exposes a
                        // reference to a VM internal (non-Java object)
                        // data structure. Attempting to access it from the
                        // JDI causes the VM to crash. Published as a
                        // convenience to any components (with a reference
                        // to the event dispatcher) that might encounter
                        // the field and thus need to screen it out.
                        List<Field> fields = null;
                        try {
                            fields = rType.fields();
                        }
                        catch (ClassNotPreparedException e) {
                            // We're in the class prepared event handler!
                            throw new AssertionError(e);
                        }
                        int sz = fields.size();
                        Iterator<Field> iter = fields.iterator();
                        for (int k = 0; k < sz; k++) {
                            Field fld = iter.next();
                            if ("base".equals(fld.name())) {
                                badField = fld;
                                break;
                            }
                        }
                    }
                    else {
                        if (systemClasses.contains(className)) {
                            classPrepared(cpe.thread(), rType);
                        }
                    }
                }
                else if (event instanceof ThreadStartEvent) {
                    threadStarted((ThreadStartEvent) event);
                }
                else if (event instanceof ThreadDeathEvent) {
                    threadDied((ThreadDeathEvent) event);
                }
                else if (event instanceof ExceptionEvent) {
                    exceptionThrown((ExceptionEvent) event);
                    continue;
                }
                else if (event instanceof VMStartEvent) {
                    VMStartEvent vmse = (VMStartEvent) event;
                    ThreadReference t = vmse.thread();
                    vmStarted(t);
                }
                else if (event instanceof VMDeathEvent) {
                    //jdiEventManager.dumpBreakpoints();
                    vmExited();
                    es.resume();
                    return;
                }
                else if (event instanceof VMDisconnectEvent) {
                    es.resume();
                    return;
                }
            }

            es.resume();
        }
    }

    /**
     * Initializes the event dispatcher for a new run.
     */
    private void initialize() {
        nextThreadId = 1;
        startEventReceived = false;
        numEvents = 0;
        processEventData();
    }
    
    /**
     * Starts and connects the event dispatcher to the target VM.
     *
     * <p>The target program will not begin executing until
     * {@link #startDispatcher()} is called. After calling this method,
     * it is possible to retrieve a reference to the instrumentation
     * handler.</p>
     *
     * @throws InternalException If an unexpected error occurs during the
     * launch process.
     */
    public void launchTarget() throws InternalException {
        if (edData == null) {
            throw new IllegalStateException("Module data not available");
        }
        if (mainClass == null) {
            throw new IllegalStateException("Main class not specified");
        }

        initialize();

        //System.out.println("SED:2285=" + Bootstrap.class);
        VirtualMachineManager manager = Bootstrap.virtualMachineManager();
        com.sun.jdi.connect.LaunchingConnector connector = null;

        int connectorID = 0;
        
        /*#ifdef FAST_JDI
        List<? extends LaunchingConnector> lConnectors =
            manager.<LaunchingConnector>launchingConnectors();
        /*#else*/
        List<LaunchingConnector> lConnectors = manager.launchingConnectors();
        /*#endif*/
        for (Iterator i = lConnectors.iterator(); i.hasNext(); ) {
            LaunchingConnector lc = (LaunchingConnector) i.next();
            if (lc.name().equals("edu.unl.jdi.impl.NIOSocketLaunch")) {
            // TODO: Better handling in future
            //if (lc.name().equals("edu.unl.jdi.impl.NamedPipeLaunch")) {
                connector = lc;
                connectorID = 2;
                break;
            }
            if (lc.name().equals("com.sun.jdi.RawCommandLineLaunch")) {
                connector = lc;
                connectorID = 1;
            }
        }

        // Establish link for dynamic instrumention commands. This is also
        // used to send the arguments to be passed to the program being
        // monitored.
        instLink = new LinkConnector(this);
        try {
            instLink.bind();
        }
        catch (IOException e) {
            throw new InternalException("Could not bind communications " +
                "socket", e);
        }

        Map<String, com.sun.jdi.connect.Connector.Argument> args = null;
        switch (connectorID) {
        case 0: {
            // Couldn't find either preferred connector
            System.err.println("INFO: Unable to find a preferred " +
                "launching connector (you may experience " +
                "problems with your firewall)");
            
            StringBuilder launchArgs = new StringBuilder();

            // Copy the classpath through to the subject. This is mainly
            // a convenience so that the user gets consistent behavior if
            // they specify a '-classpath' option to the SemanticTracer.
            launchArgs.append("-classpath ");
            launchArgs.append("\"");
            launchArgs.append(System.getProperty("java.class.path","."));
            launchArgs.append("\"");

            launchArgs.append(" -mx");  // Expand max memory
            launchArgs.append(maxMem);
            
            launchArgs.append(" -Xnoagent ");
            
            connector = manager.defaultConnector();
            args = connector.defaultArguments();
            
            Connector.Argument arg = (Connector.Argument) args.get("options");
            arg.setValue(launchArgs.toString());
            
            arg = (Connector.Argument) args.get("main");
            arg.setValue(buildInvocationCommand(instLink));
            break;
        }
        case 1: {
            // The raw command line launch
            args = connector.defaultArguments();
            String transportName = connector.transport().name();
            
            StringBuilder launchArgs = new StringBuilder("java ");

            // Copy the classpath through to the subject. This is mainly
            // a convenience so that the user gets consistent behavior if
            // they specify a '-classpath' option to the SemanticTracer.
            launchArgs.append("-classpath ");
            launchArgs.append("\"");
            launchArgs.append(System.getProperty("java.class.path","."));
            launchArgs.append("\"");

            launchArgs.append(" -mx");  // Expand max memory
            launchArgs.append(maxMem);
            
            //launchArgs.append(" -XX:+PrintCompilation");
            
            launchArgs.append(" -Xnoagent ");
            launchArgs.append("-Xdebug -Xrunjdwp:transport=");

            Connector.Argument arg = (Connector.Argument) args.get("command");

            String transportAddress = null;
            if ("dt_socket".equals(transportName)) {
                launchArgs.append(transportName);
                transportAddress = "localhost:" + getOpenPort();
            }
            else if ("dt_shmem".equals(transportName)) {
                launchArgs.append(transportName);
                transportAddress = mainClass.replace('.', '_');
            }
            else {
                throw new InternalException("Unknown JDI transport");
            }

            launchArgs.append(",address=");
            launchArgs.append(transportAddress);
            launchArgs.append(",suspend=y ");

            launchArgs.append(buildInvocationCommand(instLink));

            arg.setValue(launchArgs.toString());

            arg = (Connector.Argument) args.get("address");
            arg.setValue(transportAddress);
            break;
        }
        case 2: {
            // Our preferred connector
            args = connector.defaultArguments();
            
            Connector.SelectedArgument vmArgsArg =
                (Connector.SelectedArgument) args.get("vm_args");
            List<String> vmArgs = vmArgsArg.choices();
            
            // Copy the classpath through to the subject. This is mainly
            // a convenience so that the user gets consistent behavior if
            // they specify a '-classpath' option to the SemanticTracer.
            vmArgs.add("-classpath");
            vmArgs.add(System.getProperty("java.class.path","."));

            vmArgs.add("-mx" + maxMem);  // Expand max memory
            
            Connector.StringArgument mainClassArg =
                (Connector.StringArgument) args.get("main_class");
            mainClassArg.setValue(SemanticInstrumentor.PROBE_CLASS);
            
            Connector.SelectedArgument mainArgsArg =
                (Connector.SelectedArgument) args.get("main_args");
            List<String> mainArgs = mainArgsArg.choices();
            mainArgs.add(String.valueOf(instLink.getPort()));
            mainArgs.add(mainClass);
            break;
        }
        default:
            throw new AssertionError("Unexpected connector ID");
        }

        // Iterator argKeys = args.keySet().iterator();
        // while (argKeys.hasNext()) {
        //    Object key = argKeys.next();
        //    System.out.println(key + " -> " + args.get(key));
        // }
        
        System.out.println("Active EDL specifications:");
        int len = eventSpecs.length;
        for (int i = 0; i < len; i++) {
            System.out.println("    " + eventSpecs[i].getKey());
        }
        
        isRunning = true;
        try {
            /*#ifdef FAST_JDI
            // The cast will fail if no fast-JDI connectors could
            // be loaded! That's what we want, though...
            vm = ((LaunchingConnector) connector).launch(args);
            /*#else*/
            vm = connector.launch(args);
            /*#endif*/
        }
        catch (Exception e) {
            isRunning = false;
            throw new InternalException("Error during setup", e);
        }

        System.out.println("Launched: " + vm.toString());
        
        proc = vm.process();
        
        /*#ifdef FAST_JDI
        Integer pid = null;
        try {
            pid = Integer.valueOf(vm.pid());
        }
        catch (UnsupportedOperationException e) {
            // No matter
        }
        startIOThreads(proc, pid);
        /*#else*/
        startIOThreads(proc);
        /*#endif*/
        
        EventRequestManager erm = vm.eventRequestManager();
        jdiEventManager = new JDIEventManager(erm, edData, eventSpecs);

        instLink.connect();  // Returns asynchronously

        vm.resume();

        launched = true;
    }

    /**
     * Launches the system, beginning the trace collection.
     *
     * @throws InternalException If an unexpected error occurs during the
     * launch process or in the event dispatch queue.
     */
    public void startDispatcher() throws InternalException {
        startDispatcher(0l);
    }

    /**
     * Launches the system, beginning the trace collection.
     *
     * @param timeout Amount of time, in milliseconds, after which to
     * forcibly terminate the subject system. If zero or negative,
     * no timeout is enforced.
     *
     * @throws InternalException If an unexpected error occurs during the
     * launch process or in the event dispatch queue.
     */
    public void startDispatcher(long timeout) throws InternalException {
        if (!launched) {
            launchTarget();
        }

        Runtime runtime = Runtime.getRuntime();

        KillProcess killSubject = null;
        if (timeout > 0) {
            new Thread(new KillProcess(proc, timeout, false)).start();
        }
        else {
            killSubject = new KillProcess(proc, true);
            runtime.addShutdownHook(killSubject);
        }

        if (USE_DEADLOCK_DETECTION) {
            DeadlockDetector dd = new DeadlockDetector(proc);
            dd.setDaemon(true);
            dd.start();
        }

          //vm.setDebugTraceMode(VirtualMachine.TRACE_EVENTS
          //    | VirtualMachine.TRACE_SENDS
          //    | VirtualMachine.TRACE_RECEIVES);

        try {
            eventLoop(vm.eventQueue());
            
            if (interruptFlag == INTERRUPT_DETACH) {
                handleDetachedExit(proc);
            }
        }
        catch (Throwable e) {
            proc.destroy();
            throw new InternalException("ERROR: Exception in event " +
                "processing", e);
        }
        finally {
            launched = false;
            isRunning = false;
            
            if (killSubject != null) {
                runtime.removeShutdownHook(killSubject);
            }
            
            boolean res = stdin.disconnectStream(stdinId, true);
            if (ASSERTS) {
                assert res;
            }
        }
    }

    void detach() {
        interruptFlag = INTERRUPT_DETACH;

        try {
            probeClassTyperef.setValue(detachedFlagField,
                vm.mirrorOf((byte) 1));
        }
        catch (Exception e) {
            // If we cannot signal the probe, class prepare events
            // will cause the object program to hang, so just
            // abort the operation
            System.err.println("ERROR: Failed to send detachment " + 
                "signal to probe, aborting");
            return;
        }

        int tCnt = threads.size();
        knownThreads = new ThreadData[tCnt];
        //TObjectIntIterator ts = threads.iterator();
        //for (int i = 0; i < tCnt; i++) {
        //    ts.advance();
        //    knownThreads[i] = new SafeThreadData(
        //        ts.value(), (ThreadReference) ts.key());
        //    ts.remove();
        //}
        
        Iterator<ThreadReference> iter = threads.keySet().iterator();
        for (int i = 0; i < tCnt; i++) {
            ThreadReference td = iter.next();
            knownThreads[i] = new SafeThreadData(vm,
                threads.get(td).getId(), td);
            iter.remove();
        }

        vm.dispose();
    }
    
    void haltTarget() {
        proc.destroy();
    }

    private final void handleDetachedExit(Process proc) throws Throwable {
        proc.waitFor();

        // The known threads are cached from a hash at the time of
        // detachment, which means there is no guaranteed order, so
        // we may as well use the fast loop condition (compare
        // against zero).
        for (int i = knownThreads.length - 1; i >= 0; i--) {
            // System.out.println(" known thread exiting: " +
            //     knownThreads[i].getName());
            for (int j = 0; j < listenerCount; j++) {
                listeners[j].threadDeathEvent(knownThreads[i]);
            }
        }

        vmExited();
    }

    /**
     * Constructs the part of the <code>exec</code> invocation specifying
     * what class and arguments are to be used to launch the target VM.
     *
     * <p>The probe class is the entry point for the target VM, which
     * in turn reflectively invokes the entry point for the specified
     * main class of the object program.</p>
     *
     * @param instLink Connector responsible for establishing the link
     * between the dispatcher and the probe class in the target VM, used
     * to support adaptive instrumentation. The port on which the
     * connector is listening will be passed to the probe to be used
     * in establishing the link.
     *
     * @return The constructed string to be used in the <code>exec</code>
     * command.
     */
    private final String buildInvocationCommand(LinkConnector instLink) {
        StringBuilder invokeStr = new StringBuilder();
        invokeStr.append(SemanticInstrumentor.PROBE_CLASS);
        invokeStr.append(" ");
        invokeStr.append(instLink.getPort());
        invokeStr.append(" ");
        invokeStr.append(mainClass);
        return invokeStr.toString();
    }

    /**
     * Callback used by the link connection thread to notify the dispatcher
     * that the target program has successfully connected the communication
     * channel required for adaptive instrumentation.
     *
     * <p>The instrumentation manager can be initialized at this point.
     * The event dispatcher will then send the arguments for the object
     * program, which will allow the program to be launched. The probe
     * class in the target VM will insert a special event into the JDI
     * event queue that will be read and processed before the object
     * program is launched. This event will be dispatched to registered
     * listeners to provide access to the instrumentation manager object
     * before the object program begins executing.</p>
     *
     * @param targetIn Input stream connected to the probe class in the
     * target VM.
     * @param targetOut Output stream connected to the probe class in the
     * target VM.
     *
     * @throws IOException If there is a failure attempting to send the
     * arguments to the object program.
     */
    void targetConnected(BufferedInputStream targetIn,
            BufferedOutputStream targetOut)
            throws IOException, InternalException {
        instManager = new InstrumentationManager(this, targetIn, targetOut,
            jdiEventManager, vm, defaultClassLoader);
        instManager.initialize();

        sendLaunchArguments(new DataOutputStream(targetOut));

        // Free memory
        instLink = null;
    }

    /**
     * Sends the command line parameters to be passed to the object
     * program. Sending the parameters this way avoids problems with
     * the single-string approach that is required by the launching
     * connector(s) for the JDI.
     *
     * @param out Connection to the probe class in the target VM,
     * which will receive the arguments and use them to invoke the
     * main method on the entry point class for the object program.
     *
     * @throws IOException If there is an error sending the arguments.
     */
    private final void sendLaunchArguments(DataOutputStream out)
            throws IOException {
        Iterator iterator = classArgs.iterator();
        int size = classArgs.size();
        out.writeShort((short) size);
        for (int i = size; i-- > 0; ) {
            out.writeUTF((String) iterator.next());
        }
        out.flush();
    }

    /**
     * Sets the probe field used by the event dispatcher to identify the
     * class loader that should be used by the probe class to retreive
     * the bytes for a class for which instrumentation changes are to
     * be applied.
     *
     * @param f The field to which the event dispatcher will write the
     * class loader to be used to load the bytes for a class on which
     * instrumentation changes have been requested.
     */
    void setClassLoaderField(Field f) {
        this.probeClassLoaderField = f;
    }

//     private void createAgentJar() throws IOException {
//         File agentJarFile = new File(ProjectDescription.dbDir +
//             File.separatorChar + "ProbeManager.jar");
//         if (agentJarFile.exists()) {
//             //System.out.println(agentJarFile + " exists");
//             return;
//         }
//         //System.out.println("Creating " + agentJarFile);
// 
//         // Create manifest
//         StringBuilder sb = new StringBuilder();
//         sb.append("Manifest-Version: 1.0\n");
//         sb.append("Can-Redefine-Classes: true\n");
//         sb.append("Premain-class: sofya.ed.semantic.ProbeManager\n");
//         sb.append("Boot-Class-Path: ");
//         sb.append(ProjectDescription.dbDir);
//         sb.append(File.separatorChar);
//         sb.append("ProbeManager.jar:");
//         sb.append(System.getProperty("java.class.path","."));
// 
//         ByteArrayInputStream in = new ByteArrayInputStream(
//             sb.toString().getBytes("UTF-8"));
//         Manifest manifest = new Manifest(in);
// 
//         JarOutputStream agentJar =
//             new JarOutputStream(
//             new BufferedOutputStream(
//             new FileOutputStream(agentJarFile)), manifest);
// 
//         try {
//             agentJar.putNextEntry(
//                 new JarEntry("sofya/ed/semantic/ProbeManager.class"));
//             copyClassToStream(ProbeManager.class, agentJar, new byte[4096]);
//             agentJar.closeEntry();
//         }
//         finally {
//             agentJar.close();
//         }
//     }

    /**
     * Notifies the event dispatcher to suspend the target VM in preparation
     * for a class redefinition to update instrumentation.
     */
    void suspendTarget() {
        mainThreadGroup.suspend();
        interruptFlag = INTERRUPT_REDEFINE;
    }

    /**
     * Notifies the event dispatcher that class redefinition is beginning.
     *
     * @param synchronous If <code>true</code>, this method will not
     * return until the event dispatcher finishes processing any events
     * pending in the event queue.
     */
    void startClassRedefinition(boolean synchronous) {
        // We use a semaphore to serialize any concurrent instrumentation
        // update requests, since they are dispatched asynchronously.
        messageLock.acquireUninterruptibly();

        if (synchronous) {
            synchronized(this) {
                if (interruptFlag == INTERRUPT_REDEFINE) {
                    try {
                        wait();
                    }
                    catch (InterruptedException e) {
                    }
                }
            }
        }
    }

    /**
     * Notifies the event dispatcher that class redefinition is complete.
     *
     * @param synchronous If <code>true</code>, the dispatcher performs
     * any cleanup actions required to permit the target VM to resume
     * execution.
     */
    void endClassRedefinition(boolean synchronous) {
        processEventData();
        
        if (synchronous) {
            mainThreadGroup.resume();
        }
        
        messageLock.release();
    }

    /**
     * Causes the event dispatcher to set the reference in the probe
     * class identifying the named class loader used to load the
     * named class. This is used to retrieve the bytes for a class
     * loaded by the given class loader to be used in updating the
     * instrumentation for that class.
     *
     * @param clLoader Name of the class loader for which to retrieve
     * and set the reference in the probe class.
     * @param clName Name of the class loaded by the named class loader.
     *
     * @throws IllegalStateException If no class loader by the given
     * name has been used in the object program, or if the named class
     * loader was not used to load a class with the given name.
     * @throws InternalException If there is an error writing the
     * class loader reference to the probe field using the JDI.
     */
    void markClassLoader(ClassLoaderReference clLoaderRef)
            throws IllegalStateException, InternalException {
        try {
            //System.out.println("Setting class loader field");
            //System.out.flush();
            probeClassTyperef.setValue(probeClassLoaderField,
                clLoaderRef);
        }
        catch (Exception e) {
            throw new InternalException("Could not signal for class " +
                "redefinition", e);
        }
    }

    /**
     * Utility method to convert an event request suspend policy
     * enumeration value to a string, for use in debugging.
     */
    @SuppressWarnings("unused")
    private static final String getPolicyString(int policy) {
        switch (policy) {
        case EventRequest.SUSPEND_ALL:
            return "SUSPEND_ALL";
        case EventRequest.SUSPEND_EVENT_THREAD:
            return "SUSPEND_EVENT_THREAD";
        case EventRequest.SUSPEND_NONE:
            return "SUSPEND_NONE";
        default:
            throw new AssertionError("No such policy: " + policy);
        }
    }

    /**
     * The callback interface used to pass the instrumentation manager
     * to interested consumers at a safe point in the target
     * launch process.
     * 
     * <p>Analyses that wish to make use of adaptive instrumentation
     * features should register an object implementing this interface
     * with the event dispatcher prior to launching the target
     * program. The callback method will be invoked at a safe point
     * in the process of starting the target program, at which time
     * the analysis can obtain and store the reference to the
     * instrumentation manager.</p>
     */
    public static interface InstrumentationManagerRequestor {
        /** Callback that is invoked by the event dispatcher when
            the instrumentation manager is initialized and available. */
        void setInstrumentationManager(InstrumentationManager instManager);
    }

    /**
     * Variant of the field data facade that permits array elements to
     * be treated as fields.
     */
    private class ArrayElementData extends EventListener.FieldData {
        private ArrayType arrayType;
        private int index;

        ArrayElementData(ArrayType arrayType, int index, Location l,
                Value valueCurrent) {
            super(null, l, valueCurrent);
            this.arrayType = arrayType;
            this.index = index;
        }

        ArrayElementData(ArrayType arrayType, int index, Location l,
                Value valueCurrent, Value valueToBe) {
            super(null, l, valueCurrent, valueToBe);
            this.arrayType = arrayType;
            this.index = index;
        }
        
        public String getName() {
            return "[" + index + "]";
        }

        public String getFullName() {
            return getType() + "[" + index + "]";
        }

        @Override
        public String getType() {
            try {
                return arrayType.componentType().name();
            }
            catch (ClassNotLoadedException e) {
                return "<UnknownType>";
            }
        }

        public int getElementIndex() {
            return index;
        }
    }

    public static final class BadArrayIndexValue implements Value {
        private final Type type;
        private final int badIndex;
        private final VirtualMachine vm;

        private BadArrayIndexValue() {
            this.type = null;
            this.badIndex = -1;
            this.vm = null;
        }

        BadArrayIndexValue(int badIndex, Type componentType,
                VirtualMachine vm) {
            this.badIndex = badIndex;
            this.type = componentType;
            this.vm = vm;
        }

        public int index() {
            return badIndex;
        }

        public Type type() {
            return type;
        }

        public VirtualMachine virtualMachine() {
            return vm;
        }

        public String toString() {
            if (type == null) {
                return "<UnknownType>[bad_index<" + badIndex + ">]";
            }
            else {
                return type.name() + "[bad_index<" + badIndex + ">]";
            }
        }
    }

    private static class SafeThreadData extends ThreadData {
        private String name;
        private static final ObjectData[] EMPTY_MONITORS = new ObjectData[0];
        private static final TLongHashSet EMPTY_IDS = new TLongHashSet();

        SafeThreadData(VirtualMachine vm, int id, ThreadReference threadRef) {
            super(vm, id, threadRef);
            this.name = threadRef.name();
        }

        public String getName() {
            return name;
        }

        public ThreadStatus getStatus() {
            return ThreadStatus.ZOMBIE;
        }

        public ObjectData getRunnableTarget() {
            return null;
        }

        public ObjectData getObject() {
            return null;
        }

        public ObjectData[] ownedMonitors() {
            return EMPTY_MONITORS;
        }

        public TLongHashSet ownedMonitorIds() {
            return EMPTY_IDS;
        }
    }

    private final class KillProcess extends Thread {
        private Process doomedProc;
        private boolean wait;
        private long timeout = 0;

        private KillProcess() {
        }

        KillProcess(Process doomedProc, boolean wait) {
            this.doomedProc = doomedProc;
            this.wait = wait;
        }

        KillProcess(Process doomedProc, long timeout, boolean wait) {
            this(doomedProc, wait);
            this.timeout = timeout;
        }

        public void run() {
            if (timeout > 0) {
                try {
                    synchronized(this) {
                        wait(timeout);
                    }
                }
                catch (InterruptedException e) {
                    System.err.println("Kill thread interrupted");
                }
            }

            doomedProc.destroy();

            if (wait) {
                try {
                    doomedProc.waitFor();
                }
                catch (InterruptedException e) {
                }
            }
        }
    }

    /**
     * Exception which indicates that an unexpected or internal configuration
     * error occurred during startup or monitoring of the system.
     */
    public static class InternalException extends Exception {
        private static final long serialVersionUID = 6545445803520245621L;
        
        private Throwable cause;

        public InternalException() {
            super();
        }

        public InternalException(String msg) {
            super(msg);
        }

        public InternalException(String msg, Throwable cause) {
            super(msg);
            this.cause = cause;
        }

        public Throwable getCause() {
            return cause;
        }
    }

    private static final class LinkConnector implements Runnable {
        private SemanticEventDispatcher dispatcher;
        private ServerSocket hostSocket;
        private int port;

        private LinkConnector() {
            throw new AssertionError("Illegal constructor");
        }

        LinkConnector(SemanticEventDispatcher dispatcher) {
            this.dispatcher = dispatcher;
        }

        int getPort() {
            return port;
        }

        void bind() throws IOException {
            hostSocket = new ServerSocket(0);
            this.port = hostSocket.getLocalPort();
        }

        void connect() {
            (new Thread(this)).start();
        }

        public void run() {
            Socket cmdSocket = null;
            try {
                cmdSocket = hostSocket.accept();
            }
            catch (IOException e) {
                e.printStackTrace();
                System.err.println("ERROR: Failure accepting connection " +
                    "from target");
                return;
            }

            BufferedInputStream connIn = null;
            BufferedOutputStream connOut = null;
            try {
                connIn = new BufferedInputStream(cmdSocket.getInputStream());
                connOut = new BufferedOutputStream(
                    cmdSocket.getOutputStream());

                dispatcher.targetConnected(connIn, connOut);
            }
            catch (Throwable e) {
                e.printStackTrace();
                
                if (connIn != null) {
                    try {
                        connIn.close();
                    }
                    catch (IOException e2) {
                        // Nothing to do
                    }
                }
                if (connOut != null) {
                    try {
                        connOut.close();
                    }
                    catch (IOException e2) {
                        // Nothing to do
                    }
                }
                try {
                    cmdSocket.close();
                }
                catch (IOException e2) {
                    // Whatever
                }
            }
        }
    }

    private final class DeadlockDetector extends Thread {
        private final Process proc;

        private DeadlockDetector() {
            this.proc = null;
        }

        DeadlockDetector(Process proc) {
            this.proc = proc;
        }

        public void run() {
            long oldEventTime;
            try {
                while (true) {
                    oldEventTime = lastEventTime;
                    sleep(DEADLOCK_TIMEOUT);
                    if (oldEventTime == lastEventTime) {
                        System.err.println("Deadlock detected");
                        proc.destroy();
                        return;
                    }
                }
            }
            catch (InterruptedException e) {
                return;
            }
        }
    }

    // Retaining as alternative mechanism
    @SuppressWarnings("unused")
    private void createLaunchArgumentsFile() throws InternalException {
        String argsFileName = ".launchArgs";
        DataOutputStream out = null;
        try {
            File argsFile = new File(ProjectDescription.dbDir +
                File.separatorChar + argsFileName);
            argsFile.deleteOnExit();
            out = new DataOutputStream(
                new BufferedOutputStream(new FileOutputStream(argsFile)));
            Iterator iterator = classArgs.iterator();
            int size = classArgs.size();
            out.writeShort((short) size);
            for (int i = size; i-- > 0; ) {
                out.writeUTF((String) iterator.next());
            }
        }
        catch (IOException e) {
            throw new InternalException("Could not send launch " +
                "arguments", e);
        }
        finally {
            try {
                if (out != null) out.close();
            }
            catch (IOException e) { }
        }
    }
}
