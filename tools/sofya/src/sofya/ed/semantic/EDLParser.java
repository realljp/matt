/* Generated By:JavaCC: Do not edit this line. EDLParser.java */
/*
 * Copyright 2003-2007, Regents of the University of Nebraska
 *
 *  Licensed under the University of Nebraska Open Academic License,
 *  Version 1.0 (the "License"); you may not use this file except in
 *  compliance with the License. The License must be provided with
 *  the distribution of this software; if the license is absent from
 *  the distribution, please report immediately to galileo@cse.unl.edu
 *  and indicate where you obtained this software.
 *
 *  You may also obtain a copy of the License at:
 *
 *      http://sofya.unl.edu/LICENSE-1.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */

package sofya.ed.semantic;

import java.io.Reader;
import java.io.FileReader;
import java.io.IOException;
import java.util.Map;
import java.util.HashMap;
import java.util.Set;
import java.util.HashSet;
import java.util.List;
import java.util.ArrayList;

import org.apache.bcel.generic.ArrayType;
import org.apache.bcel.generic.Type;
import org.apache.bcel.generic.ReferenceType;
import org.apache.bcel.generic.ObjectType;

import sofya.base.Handler;
import sofya.base.ProgramUnit;
import sofya.ed.semantic.SemanticConstants;
import sofya.ed.semantic.EventSpecification.ArrayElementType;
import sofya.ed.semantic.EventSpecification.ArrayElementBounds;
import sofya.ed.semantic.EventSpecification.CallType;
import sofya.ed.semantic.EventSpecification.FieldType;
import sofya.ed.semantic.EventSpecification.MonitorType;
import sofya.ed.semantic.EventSpecification.MethodAction;
import sofya.ed.semantic.EDLSpecification.*;

/* Implementation note: type alias substitutions can occur at the
   following places:
       - global array element bounds
       - array element bounds event
       - argument types in method selection expressions
       - class names in event specifications and method selection expressions
 */

/**
 * Parses event description language (EDL) files.
 *
 * <p>The parser constructs a corresponding abstract data type that is used
 * to control the instrumentor and event dispatcher to collect the
 * observations of the specified events.</p>
 *
 * <p>The underlying parser engine is generated by JavaCC.</p>
 *
 * @author Alex Kinneer
 * @version 10/04/2007
 */
@SuppressWarnings("unused")
public class EDLParser implements EDLParserConstants {
        /** The type alias table, containing mappings for shorthand type names
	    defined in <code>Preamble Type-name:</code> declarations. */
    private final Map<String, Type> typeNames = new HashMap<String, Type>();


        /** The name of the file currently being parsed. */
    private String curFile;

    /** Stack of files currently open for parsing, but waiting for a
        return from an &quot;<code>@import</code>&quot;ed file. */
    private final List<LexerStream> parseStack = new ArrayList<LexerStream>(4);

    /** Set of open file names, for detecting circular imports. */
    private final Set<String> openFiles = new HashSet<String>();


        /** The semantic event data object that will record the specification
		ADT's parsed from the EDL file; a new instance will be created on
		each call to the parser entry point. */
    private SemanticEventData semEventData;

    /** Data structure recording globally scoped EDL declarations, which
        are declared in the <code>EDLSuite</code> section and apply to
        all <code>Observables</code> sections, including those that
        are imported. */
    private GlobalConstraints globalConstraints;

    /** The event specification ADT currently being constructed by the
        parser; each <code>Observables</code> section results in a new
        instance of this type (a single global variable is safe because
        parsing of one section must fully complete before parsing can
        begin on another. */
    private EDLSpecification edlSpec;


    // Values that are potentially modified per event specification in an
    // Observables section

    /** The rank (or precedence) of the current event specification. This
        is incremented linearly per each event specification parsed in
        the Observables section. It is also incremented by location
        constraints, to enforce precedence resolution of conflicting
        constraints across multiple event specifications. */
    private int eventRank = 1;

    /** Flag indicating whether the current event specification is selecting
        or excluding the particular event (under the given constraints,
        if any). */
    private boolean inclusion = false;


        // The following fields are global to avoid the need to create
        // extremely short lived objects simply to return multiple values
        // from a production. They should always be consumed before
        // entering another production that potentially overwrites them.

    /** Class name parsed from a method selection expression. */
    private String descClassName;

    /** Method name parsed from a method selection expression,
    	if applicable. */
    private String descMethodName;


        /** Constant representing the character that is used for
	    wildcard selection. */
    public static final String WILDCARD = "*";

        /** Compile time flag to control whether the parser emits a trace
	    of its EDL matching; possibly useful for debugging. This is
	    slightly higher level than the JavaCC provided tracing of
	    grammar productions and or lexer processing, which must be
	    enabled with the appropriate JavaCC grammar options. */
    private static final boolean DEBUG = false;

    /**
     * Simple data structure used to record an active parse of an EDL file
     * in the EDL import stack.
     */
    private static final class LexerStream {
        /** Name of the file being parsed. */
        final String fileName;

                /** The JavaCC input stream attached to the file being parsed. */
        final JavaCharStream stream;
        // The type may have to be adjusted if the grammar options are
        // modified to change the type of input that is handled

        private LexerStream() {
            throw new AssertionError("Illegal constructor");
        }

        LexerStream(String fileName, JavaCharStream stream) {
            this.fileName = fileName;
            this.stream = stream;
        }
    }

        /**
	 * Simple data structure to mark off a subsection of the token chain
	 * for special handling.
	 */
    private static final class TokenList {
        public final Token head;
        public final Token tail;

        private TokenList() {
            throw new AssertionError("Illegal constructor");
        }

        TokenList(Token head, Token tail) {
            this.head = head;
            this.tail = tail;
        }
    }

    private EDLParser() {
        throw new AssertionError("Illegal constructor");
    }

        /**
	 * Constructs a parser that is prepared to parse from the given file.
	 */
    public EDLParser(String fileName) throws IOException {
        this(new FileReader(fileName));
        curFile = fileName;
        openFiles.add(fileName);
    }

    /**
     * Constructs a parser to parse from a provided stream associated
     * with the given file.
     *
     * @param fileName The name of the file to parse, which should be the
     *     same file from which <code>input</code> is reading.
     * @param input The stream attached to the file given by
     *     <code>fileName</code>.
     */
    public EDLParser(String fileName, Reader input) throws IOException {
                this(input);
                curFile = fileName;
                openFiles.add(fileName);
    }

    /**
     * Constructs a parser to parse from a provided stream associated
     * with the given file, merging the results into an existing
     * {@link SemanticEventData} object.
     *
     * <p>NOTE: If the parser is constructed in this manner, it should
     * be invoked using {@link #importEdlUnit(boolean)} as the root
     * production with the parameter value <code>true</code>, or a
     * new <code>SemanticEventData</code> object will be constructed.</p>
     *
     * @param fileName The name of the file to parse, which should be the
     *     same file from which <code>input</code> is reading.
     * @param input The stream attached to the file given by
     *     <code>fileName</code>.
     * @param mergeEventData The {@link SemanticEventData} object into
     *     which the parsed EDL specification will be merged.
     * @param priorGC The existing global constraints extracted from the
     *     the {@link SemanticEventData} into which the current EDL
     *     will be merged.
     */
    EDLParser(String fileName, Reader input, SemanticEventData mergeEventData,
                GlobalConstraints priorGC) throws IOException {
                this(fileName, input);
                this.semEventData = mergeEventData;
                this.globalConstraints = priorGC;
        }

        /**
	 * Entry point for testing.
	 */
    public static void main(String[] argv) throws IOException, Exception {
        EDLParser parser = new EDLParser(argv[0]);

        try {
            SemanticEventData sed = parser.edlUnit();
        }
        catch (ParseException e) {
            if (DEBUG) {
                e.printStackTrace();
            }
            else {
                System.err.println(e.getMessage());
            }
            System.err.println("Encountered errors during parse.");
        }
    }

    /**
     * Combines a sequence of tokens (inclusive) into a string.
     */
    private final String tokensToString(Token start, Token end) {
        StringBuilder str = new StringBuilder();

        for (Token t = start; true; t = t.next) {
            str.append(t.image);
            if (t == end) break;
        }

        return str.toString();
    }

        /**
	 * Combines a list of tokens into a string.
	 *
	 * @return A <code>StringBuilder</code> containing the result of
	 *     appending the sequence of tokens together.
	 *     A <code>StringBuilder</code> is provided to enable the caller
	 *     to efficiently make additional modifications to the result.
	 */
    private final StringBuilder tokensToString(TokenList tokens) {
        StringBuilder str = new StringBuilder();

        for (Token t = tokens.head; true; t = t.next) {
            str.append(t.image);
            if (t == tokens.tail) break;
        }

        return str;
    }

        /**
	 * Constructs a string from the subset of tokens in a token list that
	 * are most likely to correspond to a qualified class name.
	 *
	 * <p>This method is designed with the expectation that the input
	 * token list will be of the pattern:</p>
	 * <pre>
	 *     javaId ("." javaId)*
	 * </pre>
	 * <p>It will ignore the final '<code>"." javaId</code>',
	 * on the assumption that the final component is likely to be a
	 * field or method name. It is up to the caller to further modify
	 * the returned string based on whether that assumption is correct.</p>
	 *
	 * @param tokens List of tokens, expected to match a pattern of the
	 *     form <code>javaId ("." javaId)*)</code>.
	 *
	 * @return A <code>StringBuilder</code> containing the result of
	 *     appending the sequence of tokens together as described.
	 *     A <code>StringBuilder</code> is provided to enable the caller
	 *     to efficiently make additional modifications to the result.
	 */
    private final StringBuilder classTokensToString(TokenList tokens) {
        StringBuilder str = new StringBuilder();
        for (Token t = tokens.head; t.next != tokens.tail; t = t.next) {
            str.append(t.image);
        }
        return str;
    }

    /**
     * Processes a token list to construct a qualified class name string
     * in the format expected by {@link EDLSpecification} event request
     * methods.
     *
     * <p>
     * Post-conditions: The parser variable <code>descClassName</code>
     *     will be set to a new value. No guarantees are made about
     *     any other parser variables.
     * </p>
     *
     * @param nameSpec List of tokens from which the class name will be
     *     constructed.
     * @param isTotalWild Flag that signifies whether the parser rule
     *     determined that the base class name is a wildcard.
     * @param isPkgWild Flag that signifies whether the parser rule
     *     determined that some package qualification is available,
     *     but that the specific class name is a wildcard.
     */
    private final void processClassExpr(TokenList nameSpec,
            boolean isTotalWild, boolean isPkgWild) {
        if (isTotalWild) {
            descClassName = WILDCARD;
        }
        else {
            StringBuilder klass = tokensToString(nameSpec);

            if (isPkgWild) {
                klass.append(".");
                klass.append(WILDCARD);
                descClassName = klass.toString();
            }
            else {
                descClassName = klass.toString();
                Type typeSub = typeNames.get(descClassName);
                if (typeSub != null) {
                    descClassName = typeSub.toString();
                }
            }
        }
    }

    /**
     * Processes a token list to construct the qualified class name, and
     * method name, strings in the format expected by {@link EDLSpecification}
     * event request methods.
     *
     * <p>
     * Post-conditions: The parser variables <code>descClassName</code>
     *     and <code>descMethodName</code> will be set to new values.
     *     No guarantees are made about any other parser variables.
     * </p>
     *
     * @param nameSpec List of tokens from which the class and method
     *     names will be constructed.
     * @param classIsWild Flag that signifies whether the parser rule
     *     determined that the class name is a wildcard.
     * @param methodIsWild Flag that signifies whether the parser rule
     *     determined that the method name is a wildcard.
     *
     * @throws ParseException If it is determined that the class name is
     *     not a wildcard, but no method name is available.
     */
    private final void processClassAndMethodExpr(TokenList nameSpec,
            boolean classIsWild, boolean methodIsWild) throws ParseException {
        if (classIsWild) {
            descClassName = WILDCARD;
            descMethodName = WILDCARD;
        }
        else {
            if (methodIsWild) {
                descClassName = tokensToString(nameSpec).toString();
                descMethodName = WILDCARD;
            }
            else {
                if (nameSpec.head == nameSpec.tail) {
                    throw new ParseException("Missing method name at line " +
                        nameSpec.head.endLine + ", column " +
                        (nameSpec.head.endColumn + 1));
                }

                descClassName = classTokensToString(nameSpec).toString();
                descMethodName = nameSpec.tail.image;
            }

            Type typeSub = typeNames.get(descClassName);
            if (typeSub != null) {
                descClassName = typeSub.toString();
            }
        }
    }

    /**
     * Processes a token list to construct the qualified class and field
     * name string in the format expected by {@link EDLSpecification}
     * event request methods.
     *
     * @param nameSpec List of tokens from which the class and field
     *     name string will be constructed.
     * @param fieldIsWild Flag that signifies whether the parser rule
     *     determined that the field name is a wildcard.
     *
     * @return A string representing the combined qualified class and
     *     field name constructed from the token list.
     *
     * @throws ParseException If it is determined that the class name is
     *     not a wildcard, but no field name is available.
     */
    private final String processFieldExpr(TokenList nameSpec,
            boolean fieldIsWild) throws ParseException {
        StringBuilder klass;
        String fieldStr = null;

        if (fieldIsWild) {
            klass = tokensToString(nameSpec);
            fieldStr = WILDCARD;
        }
        else {
            if (nameSpec.head == nameSpec.tail) {
                throw new ParseException("Missing field name at line " +
                    nameSpec.head.endLine + ", column " +
                    (nameSpec.head.endColumn + 1));
            }

            klass = classTokensToString(nameSpec);
            fieldStr = nameSpec.tail.image;
        }

        Type typeSub = typeNames.get(klass.toString());
        if (typeSub != null) {
            klass = new StringBuilder(typeSub.toString());
        }

        return klass.append(".").append(fieldStr).toString();
    }

    /**
     * Utility method to construct an {@link ArrayElementBounds} object
     * required by associated {@link EDLSpecification} event request
     * method.
     *
     * @param javaType The element type to which the bounds will apply.
     * @param minTok The lexer token containing the minimum bound; the
     *     lexer should guarantee that the format is parsable as a
     *     numeric value.
     * @param maxTok The lexer token containing the maximum bound; the
     *     lexer should guaranteed that the format is parsable as a
     *     numeric value.
     *
     * @return The {@link ArrayElementBounds} object encapsulating the
     *     parsed bounds information.
     */
    private final ArrayElementBounds processArrayElementBounds(Type javaType,
            Token minTok, Token maxTok) {
        ArrayElementBounds bounds = new ArrayElementBounds(javaType);
        try {
            if (minTok != null) {
                bounds.min = Integer.parseInt(minTok.image);
            }
            if (maxTok != null) {
                bounds.max = Integer.parseInt(maxTok.image);
            }
        }
        catch (NumberFormatException e) {
            // Should not happen -- lexer should enforce valid input
            throw new AssertionError("Lexer error: <UINT> permitted invalid " +
                "numeric input");
        }
        return bounds;
    }

    /**
     * Utility method to remove the double quotes from a string literal
     * token returned by the lexer.
     *
     * <p>Once the string is in memory, the double quotes are no longer
     * needed to delineate the start and end of the string.</p>
     */
    private final String stripQuotes(Token stringLiteralTok) {
        return stringLiteralTok.image.substring(1,
                stringLiteralTok.image.length() - 1);
    }

//****************************************
// EDL Grammar
//****************************************

/**
 * Initiates the parse of an event description language (EDL) file.
 *
 * @return A {@link SemanticEventData} object encapsulating the parsed
 *     event specifications.
 */
  final public SemanticEventData edlUnit() throws ParseException, IOException {
    suiteDecl();
    label_1:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case BEGIN:
        observablesSection();
        break;
      case IMPORT:
        importDecl();
        break;
      default:
        jj_la1[0] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case IMPORT:
      case BEGIN:
        ;
        break;
      default:
        jj_la1[1] = jj_gen;
        break label_1;
      }
    }
    jj_consume_token(0);
        // Created in suiteDecl()
        {if (true) return semEventData;}
    throw new Error("Missing return statement in function");
  }

  final private void importDecl() throws ParseException, IOException {
    Token fileNameTok;
    jj_consume_token(IMPORT);
    fileNameTok = jj_consume_token(STRING_LITERAL);
        String fileName = stripQuotes(fileNameTok);

        if (DEBUG) {
                System.out.println("[import:start] " + fileName);
        }

        if (openFiles.contains(fileName)) {
            {if (true) throw new ParseException("Circular import of file \"" +
                fileName + "\" from \"" + curFile + "\" at line " +
                fileNameTok.beginLine + ", column " + fileNameTok.beginColumn);}
        }

        Reader newStream = null;
        try {
            newStream = new FileReader(fileName);
        }
        catch (IOException e) {
            {if (true) throw new ParseException("Could not open file \"" +
                fileName + "\", imported from \"" + curFile + "\"" +
                " at line " + fileNameTok.beginLine + ", column " +
                fileNameTok.beginColumn + "\n    because: " + e.getMessage());}
        }

        parseStack.add(new LexerStream(curFile, token_source.input_stream));
        curFile = fileName;
        openFiles.add(fileName);

        // Simply replace the source stream with the stream pointing to the
        // new file, without changing any lexer or parser state. This
        // appears to work, but is potentially sensitive to changes in
        // the code generation performed by JavaCC, since it depends on
        // generated field names and types.
        jj_input_stream = token_source.input_stream =
                new JavaCharStream(newStream, 1, 1);

        fileNameTok = null;

        importEdlUnit(false);
  }

  final protected void importEdlUnit(boolean isRootProduction) throws ParseException, IOException {
    label_2:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case BEGIN:
        observablesSection();
        break;
      case IMPORT:
        importDecl();
        break;
      default:
        jj_la1[2] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case IMPORT:
      case BEGIN:
        ;
        break;
      default:
        jj_la1[3] = jj_gen;
        break label_2;
      }
    }
    jj_consume_token(0);
        if (DEBUG) {
                System.out.println("[import:done] " + curFile);
        }

                if (!isRootProduction) {
                LexerStream importer = parseStack.remove(parseStack.size() - 1);
                openFiles.remove(curFile);
                curFile = importer.fileName;

                // Simply swap back in the source stream from the previous file.
                // This is potentially sensitive to changes in the code
                // generation performed by JavaCC.
                jj_input_stream = token_source.input_stream = importer.stream;
            }
  }

  final private void suiteDecl() throws ParseException {
    Token nameTok;
    String name;
    jj_consume_token(BEGIN);
    jj_consume_token(EDLSUITE);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case STRING_LITERAL:
      nameTok = jj_consume_token(STRING_LITERAL);
                                 name = stripQuotes(nameTok);
      break;
    case WILD_STRING:
      nameTok = jj_consume_token(WILD_STRING);
                              name = nameTok.image;
      break;
    default:
      jj_la1[4] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
                nameTok = null;

                if (DEBUG) {
                        System.out.println("[EDLSuite] name=" + name);
                }

            semEventData = new SemanticEventData(name);
            globalConstraints = new GlobalConstraints();
    label_3:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case ARRAY_ELEM_LOAD_BOUNDS:
      case ARRAY_ELEM_STORE_BOUNDS:
        ;
        break;
      default:
        jj_la1[5] = jj_gen;
        break label_3;
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case ARRAY_ELEM_LOAD_BOUNDS:
        array_element_load_bounds__decl();
        break;
      case ARRAY_ELEM_STORE_BOUNDS:
        array_element_store_bounds__decl();
        break;
      default:
        jj_la1[6] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    }
    jj_consume_token(END);
  }

  final private void array_element_load_bounds__decl() throws ParseException {
    Type javaType;
    Token minTok = null;
    Token maxTok = null;
    jj_consume_token(ARRAY_ELEM_LOAD_BOUNDS);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case 70:
      jj_consume_token(70);
               javaType=SemanticConstants.TYPE_ANY;
      break;
    case BYTE:
    case CHAR:
    case DOUBLE:
    case FLOAT:
    case INT:
    case LONG:
    case BOOLEAN:
    case SHORT:
    case STRING:
    case JNI_BYTE:
    case JNI_CHAR:
    case JNI_DOUBLE:
    case JNI_FLOAT:
    case JNI_INT:
    case JNI_LONG:
    case JNI_BOOLEAN:
    case JNI_SHORT:
    case JNI_ARRAY:
    case JAVA_ID:
      javaType = argType();
      break;
    default:
      jj_la1[7] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case 71:
      jj_consume_token(71);
      minTok = jj_consume_token(UINT);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case 72:
        jj_consume_token(72);
        maxTok = jj_consume_token(UINT);
        break;
      default:
        jj_la1[8] = jj_gen;
        ;
      }
      break;
    case 72:
      jj_consume_token(72);
      maxTok = jj_consume_token(UINT);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case 71:
        jj_consume_token(71);
        minTok = jj_consume_token(UINT);
        break;
      default:
        jj_la1[9] = jj_gen;
        ;
      }
      break;
    default:
      jj_la1[10] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
        ArrayElementBounds bounds =
            processArrayElementBounds(javaType, minTok, maxTok);

        globalConstraints.arrayElementBounds[ArrayElementType.ILOAD].put(
            javaType, bounds);

        if (DEBUG) {
            System.out.println("[Global array element load bounds]");
            System.out.println("    type=" + javaType);
            System.out.print("    min=" +
                ((bounds.min != ArrayElementBounds.NO_BOUND)
                ? bounds.min : "none"));
            System.out.println(", max=" +
                ((bounds.max != ArrayElementBounds.NO_BOUND)
                ? bounds.max : "none"));
        }
  }

  final private void array_element_store_bounds__decl() throws ParseException {
    Type javaType;
    Token minTok = null;
    Token maxTok = null;
    jj_consume_token(ARRAY_ELEM_STORE_BOUNDS);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case 70:
      jj_consume_token(70);
               javaType=SemanticConstants.TYPE_ANY;
      break;
    case BYTE:
    case CHAR:
    case DOUBLE:
    case FLOAT:
    case INT:
    case LONG:
    case BOOLEAN:
    case SHORT:
    case STRING:
    case JNI_BYTE:
    case JNI_CHAR:
    case JNI_DOUBLE:
    case JNI_FLOAT:
    case JNI_INT:
    case JNI_LONG:
    case JNI_BOOLEAN:
    case JNI_SHORT:
    case JNI_ARRAY:
    case JAVA_ID:
      javaType = argType();
      break;
    default:
      jj_la1[11] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case 71:
      jj_consume_token(71);
      minTok = jj_consume_token(UINT);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case 72:
        jj_consume_token(72);
        maxTok = jj_consume_token(UINT);
        break;
      default:
        jj_la1[12] = jj_gen;
        ;
      }
      break;
    case 72:
      jj_consume_token(72);
      maxTok = jj_consume_token(UINT);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case 71:
        jj_consume_token(71);
        minTok = jj_consume_token(UINT);
        break;
      default:
        jj_la1[13] = jj_gen;
        ;
      }
      break;
    default:
      jj_la1[14] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
        ArrayElementBounds bounds =
            processArrayElementBounds(javaType, minTok, maxTok);

        globalConstraints.arrayElementBounds[ArrayElementType.ISTORE].put(
            javaType, bounds);

        if (DEBUG) {
            System.out.println("[Global array element store bounds]");
            System.out.println("    type=" + javaType);
            System.out.print("    min=" +
                ((bounds.min != ArrayElementBounds.NO_BOUND)
                ? bounds.min : "none"));
            System.out.println(", max=" +
                ((bounds.max != ArrayElementBounds.NO_BOUND)
                ? bounds.max : "none"));
        }
  }

  final private void observablesSection() throws ParseException, IOException {
    Token keyTok;
    String key;
    jj_consume_token(BEGIN);
    jj_consume_token(OBSERVABLES);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case STRING_LITERAL:
      keyTok = jj_consume_token(STRING_LITERAL);
          key = stripQuotes(keyTok);
      break;
    case WILD_STRING:
      keyTok = jj_consume_token(WILD_STRING);
          key = keyTok.image;
      break;
    default:
      jj_la1[15] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
                keyTok = null;

                if (DEBUG) {
                        System.out.println("[Observables] key=" + key);
                }
    preambleSection(key);
    label_4:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case 74:
      case 75:
        ;
        break;
      default:
        jj_la1[16] = jj_gen;
        break label_4;
      }
      observableEvent();
    }
    jj_consume_token(END);
  }

  final private void preambleSection(String specKey) throws ParseException, IOException {
    jj_consume_token(BEGIN);
    jj_consume_token(PREAMBLE);
    preambleDeclarations(specKey);
    jj_consume_token(END);
  }

  final private void preambleDeclarations(String specKey) throws ParseException, IOException {
    Token sysProgFileTok;
    Token modProgFileTok = null;
    Token dbTagTok = null;
    String sysProgFile;
    String modProgFile = null;
    String dbTag = null;
    boolean noModule = false;
    jj_consume_token(SYSTEM_CLASSES);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case STRING_LITERAL:
      sysProgFileTok = jj_consume_token(STRING_LITERAL);
                  sysProgFile = stripQuotes(sysProgFileTok);
      break;
    case WILD_STRING:
      sysProgFileTok = jj_consume_token(WILD_STRING);
                  sysProgFile = sysProgFileTok.image;
      break;
    default:
      jj_la1[17] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
          sysProgFileTok = null;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case MODULE_CLASSES:
    case 73:
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case MODULE_CLASSES:
        jj_consume_token(MODULE_CLASSES);
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case STRING_LITERAL:
          modProgFileTok = jj_consume_token(STRING_LITERAL);
                  modProgFile = stripQuotes(modProgFileTok);
          break;
        case WILD_STRING:
          modProgFileTok = jj_consume_token(WILD_STRING);
                  modProgFile = modProgFileTok.image;
          break;
        default:
          jj_la1[18] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
          modProgFileTok = null;
        break;
      case 73:
        jj_consume_token(73);
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case TRUE:
          jj_consume_token(TRUE);
                                noModule=true;
          break;
        case FALSE:
          jj_consume_token(FALSE);
                                                           noModule=true;
          break;
        default:
          jj_la1[19] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
        break;
      default:
        jj_la1[20] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      break;
    default:
      jj_la1[21] = jj_gen;
      ;
    }
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case DATABASE_TAG:
      jj_consume_token(DATABASE_TAG);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case STRING_LITERAL:
        dbTagTok = jj_consume_token(STRING_LITERAL);
                  dbTag = stripQuotes(dbTagTok);
        break;
      case WILD_STRING:
        dbTagTok = jj_consume_token(WILD_STRING);
                  dbTag = dbTagTok.image;
        break;
      default:
        jj_la1[22] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
          dbTagTok = null;
      break;
    default:
      jj_la1[23] = jj_gen;
      ;
    }
    label_5:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case TYPE_NAME:
        ;
        break;
      default:
        jj_la1[24] = jj_gen;
        break label_5;
      }
      preambleTypedef();
    }
        if (DEBUG) {
                System.out.println("[Preamble]");
                System.out.println("    [System-classes] " + sysProgFile);
                System.out.println("    [No-module] " + noModule);
                System.out.println("    [Module-classes] " +
                        ((noModule) ? "N/A" : modProgFile));
                if (dbTag != null) {
                        System.out.println("    [Database-tag] " + dbTag);
            }
        }

        List<ProgramUnit> sysClasses = new ArrayList<ProgramUnit>(4);
        List<ProgramUnit> modClasses = new ArrayList<ProgramUnit>(4);

        /*Handler.readProgFile(sysProgFile, dbTag, sysClasses);
        if (modProgFile != null) {
            Handler.readProgFile(modProgFile, dbTag, modClasses);
        }
        else if (!noModule) {
            Handler.readProgFile(sysProgFile, dbTag, modClasses);
        }*/

        // Reset the event request rank for the new Observables
        eventRank = 1;

        // The semantic event data and global constraints objects are
        // initialized during parsing of the EDLSuite section, which must
        // appear at the head of the file at which the parser is
        // initially pointed
        edlSpec = new EDLSpecification(specKey, sysClasses,
            modClasses, globalConstraints);
        semEventData.addEventSpecification(edlSpec, true);
  }

  final private void preambleTypedef() throws ParseException {
    Token symName;
    TokenList typeSpec = null;
    Type javaType = null;
    jj_consume_token(TYPE_NAME);
    symName = javaIdentifier();
    if (jj_2_1(2147483647)) {
      javaType = jniReferenceType();
    } else {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case STRING:
      case JNI_BYTE:
      case JNI_CHAR:
      case JNI_DOUBLE:
      case JNI_FLOAT:
      case JNI_INT:
      case JNI_LONG:
      case JNI_BOOLEAN:
      case JNI_SHORT:
      case JAVA_ID:
        typeSpec = qualifiedName();
        break;
      default:
        jj_la1[25] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    }
        if (typeSpec != null) {
            // (javaType must be null)
            String typeSub = tokensToString(typeSpec).toString();
            javaType = new ObjectType(typeSub);
        }

        typeNames.put(symName.image, javaType);

        if (DEBUG) {
            System.out.println("[Type-name] (" +
                symName.image + " => " + javaType + ")");
        }
  }

  final private void observableEvent() throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case 74:
      jj_consume_token(74);
          inclusion=true;
      break;
    case 75:
      jj_consume_token(75);
                                  inclusion=false;
      break;
    default:
      jj_la1[26] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    eventDecl();
  }

  final private void eventDecl() throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case NEW_OBJECT:
      new_object__decl();
      break;
    case CONSTRUCT_OBJECT:
      construct_object__decl();
      break;
    case CONSTRUCT_FINISH:
      construct_finish__decl();
      break;
    case GET_STATIC:
      get_static__decl();
      break;
    case PUT_STATIC:
      put_static__decl();
      break;
    case GET_FIELD:
      get_field__decl();
      break;
    case PUT_FIELD:
      put_field__decl();
      break;
    case CONSTRUCTOR_CALL:
      constructor_call__decl();
      break;
    case STATIC_CALL:
      static_call__decl();
      break;
    case VIRTUAL_CALL:
      virtual_call__decl();
      break;
    case INTERFACE_CALL:
      interface_call__decl();
      break;
    case VIRTUAL_METHOD_ENTER:
      virtual_method_enter__decl();
      break;
    case VIRTUAL_METHOD_EXIT:
      virtual_method_exit__decl();
      break;
    case STATIC_METHOD_ENTER:
      static_method_enter__decl();
      break;
    case STATIC_METHOD_EXIT:
      static_method_exit__decl();
      break;
    case MONITOR_CONTEND:
      monitor_contend__decl();
      break;
    case MONITOR_ACQUIRE:
      monitor_acquire__decl();
      break;
    case MONITOR_PRE_RELEASE:
      monitor_pre_release__decl();
      break;
    case MONITOR_RELEASE:
      monitor_release__decl();
      break;
    case THROW:
      throw__decl();
      break;
    case CATCH:
      catch__decl();
      break;
    case STATIC_INIT_ENTER:
      static_init_enter__decl();
      break;
    case ARRAY_ELEM_LOAD:
      array_element_load__decl();
      break;
    case ARRAY_ELEM_STORE:
      array_element_store__decl();
      break;
    default:
      jj_la1[27] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
  }

  final private void new_object__decl() throws ParseException {
    TokenList nameSpec = null;
    boolean isTotalWild = false;
    boolean isPkgWild = false;
    jj_consume_token(NEW_OBJECT);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case 70:
      jj_consume_token(70);
                       isTotalWild=true;
      break;
    case STRING:
    case JNI_BYTE:
    case JNI_CHAR:
    case JNI_DOUBLE:
    case JNI_FLOAT:
    case JNI_INT:
    case JNI_LONG:
    case JNI_BOOLEAN:
    case JNI_SHORT:
    case JAVA_ID:
      nameSpec = qualifiedName();
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case 76:
        jj_consume_token(76);
                                           isPkgWild=true;
        break;
      default:
        jj_la1[28] = jj_gen;
        ;
      }
      break;
    default:
      jj_la1[29] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
            processClassExpr(nameSpec, isTotalWild, isPkgWild);
            nameSpec = null;

                if (DEBUG) {
                        System.out.println("[" + ((inclusion) ? "+" : "-") + ",(" +
                                eventRank + "),new_object] class=" + descClassName);
                }

            NewObjectRequest req = edlSpec.createNewObjectRequest(descClassName,
                inclusion, eventRank++);
    locationBlock(req);
        edlSpec.addNewObjectRequest(req);
  }

  final private void construct_object__decl() throws ParseException {
    TokenList nameSpec = null;
    boolean isTotalWild = false;
    Type[] argTypes = null;
    jj_consume_token(CONSTRUCT_OBJECT);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case 70:
      jj_consume_token(70);
                             isTotalWild=true;
      break;
    case STRING:
    case JNI_BYTE:
    case JNI_CHAR:
    case JNI_DOUBLE:
    case JNI_FLOAT:
    case JNI_INT:
    case JNI_LONG:
    case JNI_BOOLEAN:
    case JNI_SHORT:
    case JAVA_ID:
      nameSpec = qualifiedName();
      argTypes = argsExpr();
      break;
    default:
      jj_la1[30] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
        processClassExpr(nameSpec, isTotalWild, false);

        if (DEBUG) {
                System.out.println("[" + ((inclusion) ? "+" : "-") + "," +
                        eventRank + ",construct_object]");
                System.out.println("    class=" + descClassName);
            System.out.println("    argTypes=" + ((argTypes == null) ? "null"
                : java.util.Arrays.toString(argTypes)));
        }

        edlSpec.addConstructorEntryRequest(descClassName, argTypes,
            inclusion, eventRank++);
  }

  final private void construct_finish__decl() throws ParseException {
    TokenList nameSpec = null;
    boolean isTotalWild = false;
    Type[] argTypes = null;
    jj_consume_token(CONSTRUCT_FINISH);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case 70:
      jj_consume_token(70);
                             isTotalWild=true;
      break;
    case STRING:
    case JNI_BYTE:
    case JNI_CHAR:
    case JNI_DOUBLE:
    case JNI_FLOAT:
    case JNI_INT:
    case JNI_LONG:
    case JNI_BOOLEAN:
    case JNI_SHORT:
    case JAVA_ID:
      nameSpec = qualifiedName();
      argTypes = argsExpr();
      break;
    default:
      jj_la1[31] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
        processClassExpr(nameSpec, isTotalWild, false);

        if (DEBUG) {
                System.out.println("[" + ((inclusion) ? "+" : "-") + "," +
                        eventRank + ",construct_finish]");
                System.out.println("    class=" + descClassName);
            System.out.println("    argTypes=" + ((argTypes == null) ? "null"
                : java.util.Arrays.toString(argTypes)));
        }

        edlSpec.addConstructorExitRequest(descClassName, argTypes,
            inclusion, eventRank++);
  }

  final private void get_static__decl() throws ParseException {
        // The string following the last "." is expected to be the field name.
        // Strictly, though, this is ambiguous, and the qualifiedName()
        // production greedily consumes it as part of the class name. It would
        // be highly complicated to parameterize qualifiedName() to behave
        // otherwise. Instead we just treat the last token in the token list
        // returned by qualifiedName() as the fieldName, unless there is a
        // wildcard (the handling of which is straightforward).

    TokenList nameSpec;
    boolean fieldIsWild = false;
    jj_consume_token(GET_STATIC);
    nameSpec = qualifiedName();
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case 76:
      jj_consume_token(76);
                                                 fieldIsWild=true;
      break;
    default:
      jj_la1[32] = jj_gen;
      ;
    }
            String fullFieldName = processFieldExpr(nameSpec, fieldIsWild);
            nameSpec = null;

                        if (DEBUG) {
                        System.out.println("[" + ((inclusion) ? "+" : "-") + ",(" +
                                eventRank + "),get_static] field=" + fullFieldName);
            }

            FieldRequest req = edlSpec.createFieldRequest(fullFieldName,
                inclusion, eventRank++, FieldType.GETSTATIC);
    locationBlock(req);
        edlSpec.addFieldRequest(req);
  }

  final private void put_static__decl() throws ParseException {
    TokenList nameSpec;
    boolean fieldIsWild = false;
    jj_consume_token(PUT_STATIC);
    nameSpec = qualifiedName();
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case 76:
      jj_consume_token(76);
                                                 fieldIsWild=true;
      break;
    default:
      jj_la1[33] = jj_gen;
      ;
    }
            String fullFieldName = processFieldExpr(nameSpec, fieldIsWild);
            nameSpec = null;

                        if (DEBUG) {
                        System.out.println("[" + ((inclusion) ? "+" : "-") + ",(" +
                                eventRank + "),put_static] field=" + fullFieldName);
            }

            FieldRequest req = edlSpec.createFieldRequest(fullFieldName,
                inclusion, eventRank++, FieldType.PUTSTATIC);
    locationBlock(req);
        edlSpec.addFieldRequest(req);
  }

  final private void get_field__decl() throws ParseException {
    TokenList nameSpec;
    boolean fieldIsWild = false;
    jj_consume_token(GET_FIELD);
    nameSpec = qualifiedName();
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case 76:
      jj_consume_token(76);
                                                fieldIsWild=true;
      break;
    default:
      jj_la1[34] = jj_gen;
      ;
    }
            String fullFieldName = processFieldExpr(nameSpec, fieldIsWild);
            nameSpec = null;

                        if (DEBUG) {
                        System.out.println("[" + ((inclusion) ? "+" : "-") + ",(" +
                                eventRank + "),get_field] field=" + fullFieldName);
            }

            FieldRequest req = edlSpec.createFieldRequest(fullFieldName,
                inclusion, eventRank++, FieldType.GETFIELD);
    locationBlock(req);
        edlSpec.addFieldRequest(req);
  }

  final private void put_field__decl() throws ParseException {
    TokenList nameSpec;
    boolean fieldIsWild = false;
    jj_consume_token(PUT_FIELD);
    nameSpec = qualifiedName();
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case 76:
      jj_consume_token(76);
                                                fieldIsWild=true;
      break;
    default:
      jj_la1[35] = jj_gen;
      ;
    }
            String fullFieldName = processFieldExpr(nameSpec, fieldIsWild);
            nameSpec = null;

                        if (DEBUG) {
                        System.out.println("[" + ((inclusion) ? "+" : "-") + ",(" +
                                eventRank + "),put_field] field=" + fullFieldName);
            }

            FieldRequest req = edlSpec.createFieldRequest(fullFieldName,
                inclusion, eventRank++, FieldType.PUTFIELD);
    locationBlock(req);
        edlSpec.addFieldRequest(req);
  }

  final private void constructor_call__decl() throws ParseException {
    TokenList nameSpec = null;
    boolean classIsWild = false;
    Type[] argTypes = null;
    jj_consume_token(CONSTRUCTOR_CALL);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case 70:
      jj_consume_token(70);
                             classIsWild=true;
      break;
    case STRING:
    case JNI_BYTE:
    case JNI_CHAR:
    case JNI_DOUBLE:
    case JNI_FLOAT:
    case JNI_INT:
    case JNI_LONG:
    case JNI_BOOLEAN:
    case JNI_SHORT:
    case JAVA_ID:
      nameSpec = qualifiedName();
      argTypes = argsExpr();
      break;
    default:
      jj_la1[36] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
            processClassExpr(nameSpec, classIsWild, false);
            nameSpec = null;

                        if (DEBUG) {
                        System.out.println("[" + ((inclusion) ? "+" : "-") + ",(" +
                                eventRank + "),interface_call]");
                        System.out.println("    class=" + descClassName);
                    System.out.println("    argTypes=" + ((argTypes == null) ? "null"
                        : java.util.Arrays.toString(argTypes)));
            }

            CallRequest req = edlSpec.createCallRequest(descClassName,
                "<init>", argTypes, inclusion, eventRank++,
                CallType.CONSTRUCTOR, false);
    locationBlock(req);
        edlSpec.addCallRequest(req);
  }

  final private void static_call__decl() throws ParseException {
    TokenList nameSpec = null;
    boolean classIsWild = false;
    boolean methodIsWild = false;
    boolean useInterceptor = false;
    Type[] argTypes = null;
    jj_consume_token(STATIC_CALL);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case INTERCEPTOR:
      jj_consume_token(INTERCEPTOR);
                           useInterceptor=true;
      break;
    default:
      jj_la1[37] = jj_gen;
      ;
    }
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case 70:
      jj_consume_token(70);
              classIsWild=true;
      break;
    case STRING:
    case JNI_BYTE:
    case JNI_CHAR:
    case JNI_DOUBLE:
    case JNI_FLOAT:
    case JNI_INT:
    case JNI_LONG:
    case JNI_BOOLEAN:
    case JNI_SHORT:
    case JAVA_ID:
      nameSpec = qualifiedName();
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case 76:
        jj_consume_token(76);
                methodIsWild=true;
        break;
      case VOID:
      case BYTE:
      case CHAR:
      case DOUBLE:
      case FLOAT:
      case INT:
      case LONG:
      case BOOLEAN:
      case SHORT:
      case STRING:
      case JNI_VOID:
      case JNI_BYTE:
      case JNI_CHAR:
      case JNI_DOUBLE:
      case JNI_FLOAT:
      case JNI_INT:
      case JNI_LONG:
      case JNI_BOOLEAN:
      case JNI_SHORT:
      case JNI_ARRAY:
      case JAVA_ID:
      case 70:
      case 83:
        argTypes = argsExpr();
        break;
      default:
        jj_la1[38] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      break;
    default:
      jj_la1[39] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
            processClassAndMethodExpr(nameSpec, classIsWild, methodIsWild);
            nameSpec = null;

                        if (DEBUG) {
                        System.out.println("[" + ((inclusion) ? "+" : "-") + ",(" +
                                eventRank + "),static_call]");
                        System.out.println("    class=" + descClassName);
                        System.out.println("    method=" + descMethodName);
                    System.out.println("    argTypes=" + ((argTypes == null) ? "null"
                        : java.util.Arrays.toString(argTypes)));
                System.out.println("    useInterceptor=" + useInterceptor);
            }

            CallRequest req = edlSpec.createCallRequest(descClassName,
                descMethodName, argTypes, inclusion, eventRank++,
                CallType.STATIC, useInterceptor);
    locationBlock(req);
        edlSpec.addCallRequest(req);
  }

  final private void virtual_call__decl() throws ParseException {
    TokenList nameSpec = null;
    boolean classIsWild = false;
    boolean methodIsWild = false;
    boolean useInterceptor = false;
    Type[] argTypes = null;
    jj_consume_token(VIRTUAL_CALL);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case INTERCEPTOR:
      jj_consume_token(INTERCEPTOR);
                            useInterceptor=true;
      break;
    default:
      jj_la1[40] = jj_gen;
      ;
    }
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case 70:
      jj_consume_token(70);
              classIsWild=true;
      break;
    case STRING:
    case JNI_BYTE:
    case JNI_CHAR:
    case JNI_DOUBLE:
    case JNI_FLOAT:
    case JNI_INT:
    case JNI_LONG:
    case JNI_BOOLEAN:
    case JNI_SHORT:
    case JAVA_ID:
      nameSpec = qualifiedName();
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case 76:
        jj_consume_token(76);
                methodIsWild=true;
        break;
      case VOID:
      case BYTE:
      case CHAR:
      case DOUBLE:
      case FLOAT:
      case INT:
      case LONG:
      case BOOLEAN:
      case SHORT:
      case STRING:
      case JNI_VOID:
      case JNI_BYTE:
      case JNI_CHAR:
      case JNI_DOUBLE:
      case JNI_FLOAT:
      case JNI_INT:
      case JNI_LONG:
      case JNI_BOOLEAN:
      case JNI_SHORT:
      case JNI_ARRAY:
      case JAVA_ID:
      case 70:
      case 83:
        argTypes = argsExpr();
        break;
      default:
        jj_la1[41] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      break;
    default:
      jj_la1[42] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
            processClassAndMethodExpr(nameSpec, classIsWild, methodIsWild);
            nameSpec = null;

                        if (DEBUG) {
                        System.out.println("[" + ((inclusion) ? "+" : "-") + ",(" +
                                eventRank + "),virtual_call]");
                        System.out.println("    class=" + descClassName);
                        System.out.println("    method=" + descMethodName);
                    System.out.println("    argTypes=" + ((argTypes == null) ? "null"
                        : java.util.Arrays.toString(argTypes)));
                System.out.println("    useInterceptor=" + useInterceptor);
            }

            CallRequest req = edlSpec.createCallRequest(descClassName,
                descMethodName, argTypes, inclusion, eventRank++,
                CallType.VIRTUAL, useInterceptor);
    locationBlock(req);
        edlSpec.addCallRequest(req);
  }

  final private void interface_call__decl() throws ParseException {
    TokenList nameSpec = null;
    boolean classIsWild = false;
    boolean methodIsWild = false;
    boolean useInterceptor = false;
    Type[] argTypes = null;
    jj_consume_token(INTERFACE_CALL);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case INTERCEPTOR:
      jj_consume_token(INTERCEPTOR);
                              useInterceptor=true;
      break;
    default:
      jj_la1[43] = jj_gen;
      ;
    }
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case 70:
      jj_consume_token(70);
              classIsWild=true;
      break;
    case STRING:
    case JNI_BYTE:
    case JNI_CHAR:
    case JNI_DOUBLE:
    case JNI_FLOAT:
    case JNI_INT:
    case JNI_LONG:
    case JNI_BOOLEAN:
    case JNI_SHORT:
    case JAVA_ID:
      nameSpec = qualifiedName();
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case 76:
        jj_consume_token(76);
                methodIsWild=true;
        break;
      case VOID:
      case BYTE:
      case CHAR:
      case DOUBLE:
      case FLOAT:
      case INT:
      case LONG:
      case BOOLEAN:
      case SHORT:
      case STRING:
      case JNI_VOID:
      case JNI_BYTE:
      case JNI_CHAR:
      case JNI_DOUBLE:
      case JNI_FLOAT:
      case JNI_INT:
      case JNI_LONG:
      case JNI_BOOLEAN:
      case JNI_SHORT:
      case JNI_ARRAY:
      case JAVA_ID:
      case 70:
      case 83:
        argTypes = argsExpr();
        break;
      default:
        jj_la1[44] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      break;
    default:
      jj_la1[45] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
            processClassAndMethodExpr(nameSpec, classIsWild, methodIsWild);
            nameSpec = null;

                        if (DEBUG) {
                        System.out.println("[" + ((inclusion) ? "+" : "-") + ",(" +
                                eventRank + "),interface_call]");
                        System.out.println("    class=" + descClassName);
                        System.out.println("    method=" + descMethodName);
                    System.out.println("    argTypes=" + ((argTypes == null) ? "null"
                        : java.util.Arrays.toString(argTypes)));
                System.out.println("    useInterceptor=" + useInterceptor);
            }

            CallRequest req = edlSpec.createCallRequest(descClassName,
                descMethodName, argTypes, inclusion, eventRank++,
                CallType.INTERFACE, useInterceptor);
    locationBlock(req);
        edlSpec.addCallRequest(req);
  }

  final private void virtual_method_enter__decl() throws ParseException {
    TokenList nameSpec = null;
    boolean classIsWild = false;
    boolean methodIsWild = false;
    Type[] argTypes = null;
    jj_consume_token(VIRTUAL_METHOD_ENTER);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case 70:
      jj_consume_token(70);
                                 classIsWild=true;
      break;
    case STRING:
    case JNI_BYTE:
    case JNI_CHAR:
    case JNI_DOUBLE:
    case JNI_FLOAT:
    case JNI_INT:
    case JNI_LONG:
    case JNI_BOOLEAN:
    case JNI_SHORT:
    case JAVA_ID:
      nameSpec = qualifiedName();
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case 76:
        jj_consume_token(76);
                    methodIsWild=true;
        break;
      case VOID:
      case BYTE:
      case CHAR:
      case DOUBLE:
      case FLOAT:
      case INT:
      case LONG:
      case BOOLEAN:
      case SHORT:
      case STRING:
      case JNI_VOID:
      case JNI_BYTE:
      case JNI_CHAR:
      case JNI_DOUBLE:
      case JNI_FLOAT:
      case JNI_INT:
      case JNI_LONG:
      case JNI_BOOLEAN:
      case JNI_SHORT:
      case JNI_ARRAY:
      case JAVA_ID:
      case 70:
      case 83:
        argTypes = argsExpr();
        break;
      default:
        jj_la1[46] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      break;
    default:
      jj_la1[47] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
        processClassAndMethodExpr(nameSpec, classIsWild, methodIsWild);

        if (DEBUG) {
                System.out.println("[" + ((inclusion) ? "+" : "-") + "," +
                        eventRank + ",virtual_method_enter]");
                System.out.println("    class=" + descClassName);
                System.out.println("    method=" + descMethodName);
            System.out.println("    argTypes=" + ((argTypes == null) ? "null"
                : java.util.Arrays.toString(argTypes)));
        }

        edlSpec.addMethodChangeRequest(descClassName, descMethodName,
            argTypes, inclusion, eventRank++,
            MethodAction.VIRTUAL_ENTER);
  }

  final private void virtual_method_exit__decl() throws ParseException {
    TokenList nameSpec = null;
    boolean classIsWild = false;
    boolean methodIsWild = false;
    Type[] argTypes = null;
    jj_consume_token(VIRTUAL_METHOD_EXIT);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case 70:
      jj_consume_token(70);
                                classIsWild=true;
      break;
    case STRING:
    case JNI_BYTE:
    case JNI_CHAR:
    case JNI_DOUBLE:
    case JNI_FLOAT:
    case JNI_INT:
    case JNI_LONG:
    case JNI_BOOLEAN:
    case JNI_SHORT:
    case JAVA_ID:
      nameSpec = qualifiedName();
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case 76:
        jj_consume_token(76);
                methodIsWild=true;
        break;
      case VOID:
      case BYTE:
      case CHAR:
      case DOUBLE:
      case FLOAT:
      case INT:
      case LONG:
      case BOOLEAN:
      case SHORT:
      case STRING:
      case JNI_VOID:
      case JNI_BYTE:
      case JNI_CHAR:
      case JNI_DOUBLE:
      case JNI_FLOAT:
      case JNI_INT:
      case JNI_LONG:
      case JNI_BOOLEAN:
      case JNI_SHORT:
      case JNI_ARRAY:
      case JAVA_ID:
      case 70:
      case 83:
        argTypes = argsExpr();
        break;
      default:
        jj_la1[48] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      break;
    default:
      jj_la1[49] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
        processClassAndMethodExpr(nameSpec, classIsWild, methodIsWild);

        if (DEBUG) {
                System.out.println("[" + ((inclusion) ? "+" : "-") + "," +
                        eventRank + ",virtual_method_exit]");
                System.out.println("    class=" + descClassName);
                System.out.println("    method=" + descMethodName);
            System.out.println("    argTypes=" + ((argTypes == null) ? "null"
                : java.util.Arrays.toString(argTypes)));
        }

        edlSpec.addMethodChangeRequest(descClassName, descMethodName,
            argTypes, inclusion, eventRank++,
            MethodAction.VIRTUAL_EXIT);
  }

  final private void static_method_enter__decl() throws ParseException {
    TokenList nameSpec = null;
    boolean classIsWild = false;
    boolean methodIsWild = false;
    Type[] argTypes = null;
    jj_consume_token(STATIC_METHOD_ENTER);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case 70:
      jj_consume_token(70);
                                classIsWild=true;
      break;
    case STRING:
    case JNI_BYTE:
    case JNI_CHAR:
    case JNI_DOUBLE:
    case JNI_FLOAT:
    case JNI_INT:
    case JNI_LONG:
    case JNI_BOOLEAN:
    case JNI_SHORT:
    case JAVA_ID:
      nameSpec = qualifiedName();
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case 76:
        jj_consume_token(76);
                    methodIsWild=true;
        break;
      case VOID:
      case BYTE:
      case CHAR:
      case DOUBLE:
      case FLOAT:
      case INT:
      case LONG:
      case BOOLEAN:
      case SHORT:
      case STRING:
      case JNI_VOID:
      case JNI_BYTE:
      case JNI_CHAR:
      case JNI_DOUBLE:
      case JNI_FLOAT:
      case JNI_INT:
      case JNI_LONG:
      case JNI_BOOLEAN:
      case JNI_SHORT:
      case JNI_ARRAY:
      case JAVA_ID:
      case 70:
      case 83:
        argTypes = argsExpr();
        break;
      default:
        jj_la1[50] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      break;
    default:
      jj_la1[51] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
        processClassAndMethodExpr(nameSpec, classIsWild, methodIsWild);

        if (DEBUG) {
                System.out.println("[" + ((inclusion) ? "+" : "-") + "," +
                        eventRank + ",static_method_enter]");
                System.out.println("    class=" + descClassName);
                System.out.println("    method=" + descMethodName);
            System.out.println("    argTypes=" + ((argTypes == null) ? "null"
                : java.util.Arrays.toString(argTypes)));
        }

        edlSpec.addMethodChangeRequest(descClassName, descMethodName,
            argTypes, inclusion, eventRank++,
            MethodAction.STATIC_ENTER);
  }

  final private void static_method_exit__decl() throws ParseException {
    TokenList nameSpec = null;
    boolean classIsWild = false;
    boolean methodIsWild = false;
    Type[] argTypes = null;
    jj_consume_token(STATIC_METHOD_EXIT);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case 70:
      jj_consume_token(70);
                               classIsWild=true;
      break;
    case STRING:
    case JNI_BYTE:
    case JNI_CHAR:
    case JNI_DOUBLE:
    case JNI_FLOAT:
    case JNI_INT:
    case JNI_LONG:
    case JNI_BOOLEAN:
    case JNI_SHORT:
    case JAVA_ID:
      nameSpec = qualifiedName();
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case 76:
        jj_consume_token(76);
                    methodIsWild=true;
        break;
      case VOID:
      case BYTE:
      case CHAR:
      case DOUBLE:
      case FLOAT:
      case INT:
      case LONG:
      case BOOLEAN:
      case SHORT:
      case STRING:
      case JNI_VOID:
      case JNI_BYTE:
      case JNI_CHAR:
      case JNI_DOUBLE:
      case JNI_FLOAT:
      case JNI_INT:
      case JNI_LONG:
      case JNI_BOOLEAN:
      case JNI_SHORT:
      case JNI_ARRAY:
      case JAVA_ID:
      case 70:
      case 83:
        argTypes = argsExpr();
        break;
      default:
        jj_la1[52] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      break;
    default:
      jj_la1[53] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
        processClassAndMethodExpr(nameSpec, classIsWild, methodIsWild);

        if (DEBUG) {
                System.out.println("[" + ((inclusion) ? "+" : "-") + "," +
                        eventRank + ",static_method_exit]");
                System.out.println("    class=" + descClassName);
                System.out.println("    method=" + descMethodName);
            System.out.println("    argTypes=" + ((argTypes == null) ? "null"
                : java.util.Arrays.toString(argTypes)));
        }

        edlSpec.addMethodChangeRequest(descClassName, descMethodName,
            argTypes, inclusion, eventRank++,
            MethodAction.STATIC_EXIT);
  }

  final private void monitor_contend__decl() throws ParseException {
    TokenList nameSpec = null;
    boolean isTotalWild = false;
    boolean isPkgWild = false;
    jj_consume_token(MONITOR_CONTEND);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case 70:
      jj_consume_token(70);
                            isTotalWild=true;
      break;
    case STRING:
    case JNI_BYTE:
    case JNI_CHAR:
    case JNI_DOUBLE:
    case JNI_FLOAT:
    case JNI_INT:
    case JNI_LONG:
    case JNI_BOOLEAN:
    case JNI_SHORT:
    case JAVA_ID:
      nameSpec = qualifiedName();
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case 76:
        jj_consume_token(76);
                                                 isPkgWild=true;
        break;
      default:
        jj_la1[54] = jj_gen;
        ;
      }
      break;
    default:
      jj_la1[55] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
            processClassExpr(nameSpec, isTotalWild, isPkgWild);
            nameSpec = null;

            if (DEBUG) {
                System.out.println("[" + ((inclusion) ? "+" : "-") + ",(" +
                        eventRank + "),monitor_contend] class=" + descClassName);
            }

            MonitorRequest req = edlSpec.createMonitorRequest(descClassName,
                inclusion, eventRank++, MonitorType.CONTEND);
    locationBlock(req);
        edlSpec.addMonitorRequest(req);
  }

  final private void monitor_acquire__decl() throws ParseException {
    TokenList nameSpec = null;
    boolean isTotalWild = false;
    boolean isPkgWild = false;
    jj_consume_token(MONITOR_ACQUIRE);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case 70:
      jj_consume_token(70);
                            isTotalWild=true;
      break;
    case STRING:
    case JNI_BYTE:
    case JNI_CHAR:
    case JNI_DOUBLE:
    case JNI_FLOAT:
    case JNI_INT:
    case JNI_LONG:
    case JNI_BOOLEAN:
    case JNI_SHORT:
    case JAVA_ID:
      nameSpec = qualifiedName();
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case 76:
        jj_consume_token(76);
                                                 isPkgWild=true;
        break;
      default:
        jj_la1[56] = jj_gen;
        ;
      }
      break;
    default:
      jj_la1[57] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
            processClassExpr(nameSpec, isTotalWild, isPkgWild);
            nameSpec = null;

            if (DEBUG) {
                System.out.println("[" + ((inclusion) ? "+" : "-") + ",(" +
                        eventRank + "),monitor_acquire] class=" + descClassName);
            }

            MonitorRequest req = edlSpec.createMonitorRequest(descClassName,
                inclusion, eventRank++, MonitorType.ACQUIRE);
    locationBlock(req);
        edlSpec.addMonitorRequest(req);
  }

  final private void monitor_pre_release__decl() throws ParseException {
    TokenList nameSpec = null;
    boolean isTotalWild = false;
    boolean isPkgWild = false;
    jj_consume_token(MONITOR_PRE_RELEASE);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case 70:
      jj_consume_token(70);
                                isTotalWild=true;
      break;
    case STRING:
    case JNI_BYTE:
    case JNI_CHAR:
    case JNI_DOUBLE:
    case JNI_FLOAT:
    case JNI_INT:
    case JNI_LONG:
    case JNI_BOOLEAN:
    case JNI_SHORT:
    case JAVA_ID:
      nameSpec = qualifiedName();
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case 76:
        jj_consume_token(76);
                                                 isPkgWild=true;
        break;
      default:
        jj_la1[58] = jj_gen;
        ;
      }
      break;
    default:
      jj_la1[59] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
            processClassExpr(nameSpec, isTotalWild, isPkgWild);
            nameSpec = null;

            if (DEBUG) {
                System.out.println("[" + ((inclusion) ? "+" : "-") + ",(" +
                        eventRank + "),monitor_pre_release] class=" +
                        descClassName);
            }

            MonitorRequest req = edlSpec.createMonitorRequest(descClassName,
                inclusion, eventRank++, MonitorType.PRE_RELEASE);
    locationBlock(req);
        edlSpec.addMonitorRequest(req);
  }

  final private void monitor_release__decl() throws ParseException {
    TokenList nameSpec = null;
    boolean isTotalWild = false;
    boolean isPkgWild = false;
    jj_consume_token(MONITOR_RELEASE);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case 70:
      jj_consume_token(70);
                            isTotalWild=true;
      break;
    case STRING:
    case JNI_BYTE:
    case JNI_CHAR:
    case JNI_DOUBLE:
    case JNI_FLOAT:
    case JNI_INT:
    case JNI_LONG:
    case JNI_BOOLEAN:
    case JNI_SHORT:
    case JAVA_ID:
      nameSpec = qualifiedName();
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case 76:
        jj_consume_token(76);
                                                 isPkgWild=true;
        break;
      default:
        jj_la1[60] = jj_gen;
        ;
      }
      break;
    default:
      jj_la1[61] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
            processClassExpr(nameSpec, isTotalWild, isPkgWild);
            nameSpec = null;

            if (DEBUG) {
                System.out.println("[" + ((inclusion) ? "+" : "-") + ",(" +
                        eventRank + "),monitor_release] class=" + descClassName);
            }

            MonitorRequest req = edlSpec.createMonitorRequest(descClassName,
                inclusion, eventRank++, MonitorType.RELEASE);
    locationBlock(req);
        edlSpec.addMonitorRequest(req);
  }

  final private void throw__decl() throws ParseException {
    TokenList nameSpec = null;
    boolean classIsWild = false;
    boolean subclasses = false;
    jj_consume_token(THROW);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case 70:
      jj_consume_token(70);
                  classIsWild=true;
      break;
    case STRING:
    case JNI_BYTE:
    case JNI_CHAR:
    case JNI_DOUBLE:
    case JNI_FLOAT:
    case JNI_INT:
    case JNI_LONG:
    case JNI_BOOLEAN:
    case JNI_SHORT:
    case JAVA_ID:
      nameSpec = qualifiedName();
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case 77:
        jj_consume_token(77);
                       subclasses=true;
        break;
      default:
        jj_la1[62] = jj_gen;
        ;
      }
      break;
    default:
      jj_la1[63] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
            processClassExpr(nameSpec, classIsWild, false);
            nameSpec = null;

            if (DEBUG) {
                System.out.println("[" + ((inclusion) ? "+" : "-") + ",(" +
                        eventRank + "),throw] class=" + descClassName);
                System.out.println("    andSubclasses=" + subclasses);
            }

            ThrowRequest req = edlSpec.createThrowRequest(descClassName,
                subclasses, inclusion, eventRank++);
    locationBlock(req);
        edlSpec.addThrowRequest(req);
  }

  final private void catch__decl() throws ParseException {
    TokenList nameSpec = null;
    boolean classIsWild = false;
    boolean subclasses = false;
    jj_consume_token(CATCH);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case 70:
      jj_consume_token(70);
                  classIsWild=true;
      break;
    case STRING:
    case JNI_BYTE:
    case JNI_CHAR:
    case JNI_DOUBLE:
    case JNI_FLOAT:
    case JNI_INT:
    case JNI_LONG:
    case JNI_BOOLEAN:
    case JNI_SHORT:
    case JAVA_ID:
      nameSpec = qualifiedName();
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case 77:
        jj_consume_token(77);
                                                                        subclasses=true;
        break;
      default:
        jj_la1[64] = jj_gen;
        ;
      }
      break;
    default:
      jj_la1[65] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
            processClassExpr(nameSpec, classIsWild, false);
            nameSpec = null;

                        if (DEBUG) {
                System.out.println("[" + ((inclusion) ? "+" : "-") + ",(" +
                        eventRank + "),catch] class=" + descClassName);
                System.out.println("    andSubclasses=" + subclasses);
                }

            CatchRequest req = edlSpec.createCatchRequest(descClassName,
                subclasses, inclusion, eventRank++);
    locationBlock(req);
        edlSpec.addCatchRequest(req);
  }

  final private void static_init_enter__decl() throws ParseException {
    TokenList nameSpec = null;
    boolean isTotalWild = false;
    boolean isPkgWild = false;
    jj_consume_token(STATIC_INIT_ENTER);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case 70:
      jj_consume_token(70);
                              isTotalWild=true;
      break;
    case STRING:
    case JNI_BYTE:
    case JNI_CHAR:
    case JNI_DOUBLE:
    case JNI_FLOAT:
    case JNI_INT:
    case JNI_LONG:
    case JNI_BOOLEAN:
    case JNI_SHORT:
    case JAVA_ID:
      nameSpec = qualifiedName();
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case 76:
        jj_consume_token(76);
                                         isPkgWild=true;
        break;
      default:
        jj_la1[66] = jj_gen;
        ;
      }
      break;
    default:
      jj_la1[67] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
        processClassExpr(nameSpec, isTotalWild, isPkgWild);

        if (DEBUG) {
                System.out.println("[" + ((inclusion) ? "+" : "-") + "," +
                        eventRank + ",static_init_enter] class=" + descClassName);
        }

        edlSpec.addStaticInitializerEntryRequest(descClassName, inclusion,
            eventRank++);
  }

  final private void array_element_load__decl() throws ParseException {
    Type javaType;
    Token minTok = null;
    Token maxTok = null;
    jj_consume_token(ARRAY_ELEM_LOAD);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case 70:
      jj_consume_token(70);
                      javaType=SemanticConstants.TYPE_ANY;
      break;
    case BYTE:
    case CHAR:
    case DOUBLE:
    case FLOAT:
    case INT:
    case LONG:
    case BOOLEAN:
    case SHORT:
    case STRING:
    case JNI_BYTE:
    case JNI_CHAR:
    case JNI_DOUBLE:
    case JNI_FLOAT:
    case JNI_INT:
    case JNI_LONG:
    case JNI_BOOLEAN:
    case JNI_SHORT:
    case JNI_ARRAY:
    case JAVA_ID:
      javaType = argType();
      break;
    default:
      jj_la1[68] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case 71:
      jj_consume_token(71);
      minTok = jj_consume_token(UINT);
      break;
    default:
      jj_la1[69] = jj_gen;
      ;
    }
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case 72:
      jj_consume_token(72);
      maxTok = jj_consume_token(UINT);
      break;
    default:
      jj_la1[70] = jj_gen;
      ;
    }
            ArrayElementBounds bounds =
                processArrayElementBounds(javaType, minTok, maxTok);
            minTok = maxTok = null;

            if (DEBUG) {
                System.out.println("[" + ((inclusion) ? "+" : "-") + ",(" +
                        eventRank + "),array_element_load]");
                System.out.println("    type=" + javaType);
                System.out.print("    min=" +
                    ((bounds.min != ArrayElementBounds.NO_BOUND)
                    ? bounds.min : "none"));
                System.out.println(", max=" +
                    ((bounds.max != ArrayElementBounds.NO_BOUND)
                    ? bounds.max : "none"));
            }

            ArrayElementRequest req = edlSpec.createArrayElementRequest(
                bounds, inclusion, eventRank++, ArrayElementType.LOAD);
    locationBlock(req);
        edlSpec.addArrayElementRequest(req);
  }

  final private void array_element_store__decl() throws ParseException {
    Type javaType;
    Token minTok = null;
    Token maxTok = null;
    jj_consume_token(ARRAY_ELEM_STORE);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case 70:
      jj_consume_token(70);
                      javaType=SemanticConstants.TYPE_ANY;
      break;
    case BYTE:
    case CHAR:
    case DOUBLE:
    case FLOAT:
    case INT:
    case LONG:
    case BOOLEAN:
    case SHORT:
    case STRING:
    case JNI_BYTE:
    case JNI_CHAR:
    case JNI_DOUBLE:
    case JNI_FLOAT:
    case JNI_INT:
    case JNI_LONG:
    case JNI_BOOLEAN:
    case JNI_SHORT:
    case JNI_ARRAY:
    case JAVA_ID:
      javaType = argType();
      break;
    default:
      jj_la1[71] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case 71:
      jj_consume_token(71);
      minTok = jj_consume_token(UINT);
      break;
    default:
      jj_la1[72] = jj_gen;
      ;
    }
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case 72:
      jj_consume_token(72);
      maxTok = jj_consume_token(UINT);
      break;
    default:
      jj_la1[73] = jj_gen;
      ;
    }
            ArrayElementBounds bounds =
                processArrayElementBounds(javaType, minTok, maxTok);
            minTok = maxTok = null;

            if (DEBUG) {
                System.out.println("[" + ((inclusion) ? "+" : "-") + ",(" +
                        eventRank + "),array_element_store]");
                System.out.println("    type=" + javaType);
                System.out.print("    min=" +
                    ((bounds.min != ArrayElementBounds.NO_BOUND)
                    ? bounds.min : "none"));
                System.out.println(", max=" +
                    ((bounds.max != ArrayElementBounds.NO_BOUND)
                    ? bounds.max : "none"));
            }

            ArrayElementRequest req = edlSpec.createArrayElementRequest(
                bounds, inclusion, eventRank++, ArrayElementType.STORE);
    locationBlock(req);
        edlSpec.addArrayElementRequest(req);
  }

  final private void locationBlock(EGEventRequest req) throws ParseException, ParseException {
    // It is ambiguous whether the string following the last "." is a final
    // component of the class name, or the method name. The qualifiedName()
    // production greedily consumes it as part of the class name, and it
    // would be highly complicated to parameterize that production to behave
    // otherwise. It is simpler to just inspect the last token in the list
    // returned by qualifiedName() and deduce the appropriate semantics
    // manually; therefore there is no explicit production for a method
    // expression. The grammar still makes it illegal to specify argument
    // types for a wildcard selection of methods, in any case.

    TokenList nameSpec = null;
    boolean isInCondition = false;
    boolean classIsWild = false;
    boolean methodIsWild = false;
    Type[] argTypes = null;

    EventConditions ecs = req.conditions();
    jj_consume_token(78);
    label_6:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case IN:
      case NOT:
        ;
        break;
      default:
        jj_la1[74] = jj_gen;
        break label_6;
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case IN:
        jj_consume_token(IN);
            isInCondition=true;
        break;
      case NOT:
        jj_consume_token(NOT);
                                          isInCondition=false;
        break;
      default:
        jj_la1[75] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case 70:
        jj_consume_token(70);
              classIsWild=true;
        break;
      case STRING:
      case JNI_BYTE:
      case JNI_CHAR:
      case JNI_DOUBLE:
      case JNI_FLOAT:
      case JNI_INT:
      case JNI_LONG:
      case JNI_BOOLEAN:
      case JNI_SHORT:
      case JAVA_ID:
        nameSpec = qualifiedName();
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case 76:
          jj_consume_token(76);
                    methodIsWild=true;
          break;
        case VOID:
        case BYTE:
        case CHAR:
        case DOUBLE:
        case FLOAT:
        case INT:
        case LONG:
        case BOOLEAN:
        case SHORT:
        case STRING:
        case JNI_VOID:
        case JNI_BYTE:
        case JNI_CHAR:
        case JNI_DOUBLE:
        case JNI_FLOAT:
        case JNI_INT:
        case JNI_LONG:
        case JNI_BOOLEAN:
        case JNI_SHORT:
        case JNI_ARRAY:
        case JAVA_ID:
        case 70:
        case 83:
          argTypes = argsExpr();
          break;
        default:
          jj_la1[76] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
        break;
      default:
        jj_la1[77] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
        processClassAndMethodExpr(nameSpec, classIsWild, methodIsWild);
        nameSpec = null;

        if (isInCondition) {
                if (DEBUG) {
                System.out.println("    [" + eventRank + ",in] ");
            }

            ecs.addInCondition(descClassName, descMethodName, argTypes,
                inclusion, eventRank++);
        }
        else {
                if (DEBUG) {
                System.out.println("    [" + eventRank + ",not] ");
            }

            ecs.addNotCondition(descClassName, descMethodName, argTypes,
                inclusion, eventRank++);
        }

        if (DEBUG) {
                System.out.println("      class=" + descClassName);
                System.out.println("      method=" + descMethodName);
            System.out.println("      argTypes=" + ((argTypes == null) ? "null"
                : java.util.Arrays.toString(argTypes)));
        }

        argTypes = null;
    }
    jj_consume_token(79);
  }

  final private Type[] argsExpr() throws ParseException {
    // An array return type is used, instead of a list, to make it more
    // convenient to interface with BCEL.

    List<Type> argTypes = null;
    Type curType = null;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case 70:
      jj_consume_token(70);
      break;
    case VOID:
    case JNI_VOID:
      curType = voidArg();
          argTypes = new ArrayList<Type>(1);
          argTypes.add(curType);
      break;
    case BYTE:
    case CHAR:
    case DOUBLE:
    case FLOAT:
    case INT:
    case LONG:
    case BOOLEAN:
    case SHORT:
    case STRING:
    case JNI_BYTE:
    case JNI_CHAR:
    case JNI_DOUBLE:
    case JNI_FLOAT:
    case JNI_INT:
    case JNI_LONG:
    case JNI_BOOLEAN:
    case JNI_SHORT:
    case JNI_ARRAY:
    case JAVA_ID:
      curType = argType();
          argTypes = new ArrayList<Type>(4);
          argTypes.add(curType);
      label_7:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case 80:
          ;
          break;
        default:
          jj_la1[78] = jj_gen;
          break label_7;
        }
        jj_consume_token(80);
        curType = argType();
                                 argTypes.add(curType);
      }
      break;
    case 83:
        Type[] argTypesArr;
      argTypesArr = jniMethodSignature();
        {if (true) return argTypesArr;}
      break;
    default:
      jj_la1[79] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
        if (argTypes != null) {
            {if (true) return (Type[]) argTypes.toArray(new Type[argTypes.size()]);}
        }
        else {
            {if (true) return null;}
        }
    throw new Error("Missing return statement in function");
  }

  final private Type voidArg() throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case VOID:
      jj_consume_token(VOID);
      break;
    case JNI_VOID:
      jj_consume_token(JNI_VOID);
      break;
    default:
      jj_la1[80] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
      {if (true) return Type.VOID;}
    throw new Error("Missing return statement in function");
  }

  final private Type argType() throws ParseException {
    Type javaType = null;
    TokenList nameSpec = null;
    if (jj_2_3(2147483647)) {
      javaType = basicTypeName();
    } else if (jj_2_4(2147483647)) {
      javaType = jniPrimitiveType();
    } else {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case STRING:
      case JNI_BYTE:
      case JNI_CHAR:
      case JNI_DOUBLE:
      case JNI_FLOAT:
      case JNI_INT:
      case JNI_LONG:
      case JNI_BOOLEAN:
      case JNI_SHORT:
      case JNI_ARRAY:
      case JAVA_ID:
        if (jj_2_2(2147483647)) {
          javaType = jniObjectType();
        } else {
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case JNI_ARRAY:
            javaType = jniArrayType();
            break;
          case STRING:
          case JNI_BYTE:
          case JNI_CHAR:
          case JNI_DOUBLE:
          case JNI_FLOAT:
          case JNI_INT:
          case JNI_LONG:
          case JNI_BOOLEAN:
          case JNI_SHORT:
          case JAVA_ID:
            nameSpec = qualifiedName();
            break;
          default:
            jj_la1[81] = jj_gen;
            jj_consume_token(-1);
            throw new ParseException();
          }
        }
        break;
      default:
        jj_la1[82] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    }
        if (nameSpec != null) {
            // (javaType must be null)

            String typeStr = tokensToString(nameSpec).toString();
            //System.out.println("argType: qualifiedName=" + typeStr);

            Type typeSub = typeNames.get(typeStr);
            if (typeSub != null) {
                javaType = typeSub;
                //System.out.println("    substitution=" + typeSub);
            }
            else {
                javaType = new ObjectType(typeStr);
            }
        }

        {if (true) return javaType;}
    throw new Error("Missing return statement in function");
  }

  final private Type basicTypeName() throws ParseException {
    Type javaType;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case BYTE:
      jj_consume_token(BYTE);
                  javaType = Type.BYTE;
      break;
    case CHAR:
      jj_consume_token(CHAR);
                  javaType = Type.CHAR;
      break;
    case DOUBLE:
      jj_consume_token(DOUBLE);
                  javaType = Type.DOUBLE;
      break;
    case FLOAT:
      jj_consume_token(FLOAT);
                  javaType = Type.FLOAT;
      break;
    case INT:
      jj_consume_token(INT);
                  javaType = Type.INT;
      break;
    case LONG:
      jj_consume_token(LONG);
                  javaType = Type.LONG;
      break;
    case BOOLEAN:
      jj_consume_token(BOOLEAN);
                  javaType = Type.BOOLEAN;
      break;
    case SHORT:
      jj_consume_token(SHORT);
                  javaType = Type.SHORT;
      break;
    case STRING:
      jj_consume_token(STRING);
                  javaType = Type.STRING;
      break;
    default:
      jj_la1[83] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
      {if (true) return javaType;}
    throw new Error("Missing return statement in function");
  }

  final private Type jniPrimitiveType() throws ParseException {
    Type javaType;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case JNI_BYTE:
      jj_consume_token(JNI_BYTE);
            javaType = Type.BYTE;
      break;
    case JNI_CHAR:
      jj_consume_token(JNI_CHAR);
            javaType = Type.CHAR;
      break;
    case JNI_DOUBLE:
      jj_consume_token(JNI_DOUBLE);
            javaType = Type.DOUBLE;
      break;
    case JNI_FLOAT:
      jj_consume_token(JNI_FLOAT);
            javaType = Type.FLOAT;
      break;
    case JNI_INT:
      jj_consume_token(JNI_INT);
            javaType = Type.INT;
      break;
    case JNI_LONG:
      jj_consume_token(JNI_LONG);
            javaType = Type.LONG;
      break;
    case JNI_BOOLEAN:
      jj_consume_token(JNI_BOOLEAN);
            javaType = Type.BOOLEAN;
      break;
    case JNI_SHORT:
      jj_consume_token(JNI_SHORT);
            javaType = Type.SHORT;
      break;
    default:
      jj_la1[84] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
      {if (true) return javaType;}
    throw new Error("Missing return statement in function");
  }

  final private Type jniReferenceType() throws ParseException {
    Type javaType;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case JNI_ARRAY:
      javaType = jniArrayType();
      break;
    case STRING:
    case JNI_BYTE:
    case JNI_CHAR:
    case JNI_DOUBLE:
    case JNI_FLOAT:
    case JNI_INT:
    case JNI_LONG:
    case JNI_BOOLEAN:
    case JNI_SHORT:
    case JAVA_ID:
      javaType = jniObjectType();
      break;
    default:
      jj_la1[85] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
      {if (true) return javaType;}
    throw new Error("Missing return statement in function");
  }

  final private Type jniArrayType() throws ParseException {
    Type elemType;
    int dims = 0;
    label_8:
    while (true) {
      jj_consume_token(JNI_ARRAY);
           dims++;
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case JNI_ARRAY:
        ;
        break;
      default:
        jj_la1[86] = jj_gen;
        break label_8;
      }
    }
    if (jj_2_5(2)) {
      elemType = jniPrimitiveType();
    } else {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case STRING:
      case JNI_BYTE:
      case JNI_CHAR:
      case JNI_DOUBLE:
      case JNI_FLOAT:
      case JNI_INT:
      case JNI_LONG:
      case JNI_BOOLEAN:
      case JNI_SHORT:
      case JAVA_ID:
        elemType = jniObjectType();
        break;
      default:
        jj_la1[87] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    }
        {if (true) return new ArrayType(elemType, dims);}
    throw new Error("Missing return statement in function");
  }

  final private Type jniObjectType() throws ParseException {
    Token start;
      Token head = getToken(1);
    start = javaIdentifier();
    label_9:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case 81:
        ;
        break;
      default:
        jj_la1[88] = jj_gen;
        break label_9;
      }
      jj_consume_token(81);
      javaIdentifier();
    }
    jj_consume_token(82);
        // Because of the maximal munch rule, the lexer wants to
        // consume the (required) leading L as part of a JAVA_ID.
        // It appears that fixing this would require that we:
        //   * factor 'L' out of the regex for the first letter
        //     of a JAVA_ID
        //   * write a grammar rule for Java IDs to express the
        //     validity of L at the start of an identifier
        //   * replace all uses of the JAVA_ID lexer token with
        //     the grammar rule
        //   * use lookahead wherever we need to disambiguate
        //     between a Java ID and a JNI type signature
        // The complexity of the above doesn't seem justified just
        // to avoid the following slightly hackish solution (note
        // that this action can only be triggered after the input
        // has matched the whole rule/template for a JNI type
        // signature, which cannot be ambiguous with any other
        // input that we would expect to see).
        if (start.image.charAt(0) != 'L') {
            {if (true) throw new ParseException("Invalid JNI type signature: " +
                "encountered \"" + start.image.charAt(0) + "\" at line " +
                start.beginLine + ", column " + start.beginColumn + ".\n" +
                "Was expecting:\n    \"L\"");}
        }

        String typeStr = tokensToString(head, getToken(0));
        {if (true) return Type.getType(typeStr);}
    throw new Error("Missing return statement in function");
  }

  final private Type[] jniMethodSignature() throws ParseException {
      Token head = getToken(1);
    jj_consume_token(83);
    label_10:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case STRING:
      case JNI_BYTE:
      case JNI_CHAR:
      case JNI_DOUBLE:
      case JNI_FLOAT:
      case JNI_INT:
      case JNI_LONG:
      case JNI_BOOLEAN:
      case JNI_SHORT:
      case JNI_ARRAY:
      case JAVA_ID:
      case 81:
      case 82:
        ;
        break;
      default:
        jj_la1[89] = jj_gen;
        break label_10;
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case STRING:
      case JNI_BYTE:
      case JNI_CHAR:
      case JNI_DOUBLE:
      case JNI_FLOAT:
      case JNI_INT:
      case JNI_LONG:
      case JNI_BOOLEAN:
      case JNI_SHORT:
      case JAVA_ID:
        javaIdentifier();
        break;
      case JNI_ARRAY:
        jj_consume_token(JNI_ARRAY);
        break;
      case 81:
        jj_consume_token(81);
        break;
      case 82:
        jj_consume_token(82);
        break;
      default:
        jj_la1[90] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    }
    jj_consume_token(84);
    label_11:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case STRING:
      case JNI_BYTE:
      case JNI_CHAR:
      case JNI_DOUBLE:
      case JNI_FLOAT:
      case JNI_INT:
      case JNI_LONG:
      case JNI_BOOLEAN:
      case JNI_SHORT:
      case JAVA_ID:
        javaIdentifier();
        break;
      case JNI_VOID:
        jj_consume_token(JNI_VOID);
        break;
      case JNI_ARRAY:
        jj_consume_token(JNI_ARRAY);
        break;
      case 81:
        jj_consume_token(81);
        break;
      case 82:
        jj_consume_token(82);
        break;
      default:
        jj_la1[91] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case STRING:
      case JNI_VOID:
      case JNI_BYTE:
      case JNI_CHAR:
      case JNI_DOUBLE:
      case JNI_FLOAT:
      case JNI_INT:
      case JNI_LONG:
      case JNI_BOOLEAN:
      case JNI_SHORT:
      case JNI_ARRAY:
      case JAVA_ID:
      case 81:
      case 82:
        ;
        break;
      default:
        jj_la1[92] = jj_gen;
        break label_11;
      }
    }
        String typeStr = tokensToString(head, getToken(0));
        try {
            {if (true) return Type.getArgumentTypes(typeStr);}
        }
        catch (org.apache.bcel.classfile.ClassFormatException e) {
            {if (true) throw new ParseException("Invalid JNI method signature at " +
                head.beginLine + ", column " + head.beginColumn + " (" +
                "\"" + typeStr + "\")");}
        }
    throw new Error("Missing return statement in function");
  }

  final private TokenList qualifiedName() throws ParseException {
      Token head = getToken(1);
    javaIdentifier();
    label_12:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case 85:
        ;
        break;
      default:
        jj_la1[93] = jj_gen;
        break label_12;
      }
      jj_consume_token(85);
      javaIdentifier();
    }
        {if (true) return new TokenList(head, getToken(0));}
    throw new Error("Missing return statement in function");
  }

  final private Token javaIdentifier() throws ParseException {
    // In the parts of the grammar that handle parsing of argument types,
    // it is efficient to let certain shorthand inputs be mapped directly
    // to corresponding BCEL Type constants by the generated parser code
    // (using actions; see the jniPrimitiveType() rule, for example).
    // To support this, those shorthand inputs have to be processed as
    // literal tokens in the lexer, which takes precedence over their
    // inclusion as part of a JAVA_ID. However, some are still technically
    // valid identifier characters/strings, so to support proper parsing of
    // JAVA_ID tokens they have to be "reintroduced" as legal components of
    // an identifier here, in the grammar. This avoids the need for
    // special handling where the grammar permits a qualifiedName
    // but not any of the shorthand notations (the common case).
    //
    // When parsing argument types, lookahead is used to resolve the
    // ambiguity that results from the possibility of using both
    // qualified names and shorthand inputs to specify the types.

    Token tok;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case STRING:
      tok = jj_consume_token(STRING);
      break;
    case JNI_BYTE:
      tok = jj_consume_token(JNI_BYTE);
      break;
    case JNI_CHAR:
      tok = jj_consume_token(JNI_CHAR);
      break;
    case JNI_DOUBLE:
      tok = jj_consume_token(JNI_DOUBLE);
      break;
    case JNI_FLOAT:
      tok = jj_consume_token(JNI_FLOAT);
      break;
    case JNI_INT:
      tok = jj_consume_token(JNI_INT);
      break;
    case JNI_LONG:
      tok = jj_consume_token(JNI_LONG);
      break;
    case JNI_BOOLEAN:
      tok = jj_consume_token(JNI_BOOLEAN);
      break;
    case JNI_SHORT:
      tok = jj_consume_token(JNI_SHORT);
      break;
    case JAVA_ID:
      tok = jj_consume_token(JAVA_ID);
      break;
    default:
      jj_la1[94] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
      {if (true) return tok;}
    throw new Error("Missing return statement in function");
  }

  final private boolean jj_2_1(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_1(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(0, xla); }
  }

  final private boolean jj_2_2(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_2(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(1, xla); }
  }

  final private boolean jj_2_3(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_3(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(2, xla); }
  }

  final private boolean jj_2_4(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_4(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(3, xla); }
  }

  final private boolean jj_2_5(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_5(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(4, xla); }
  }

  final private boolean jj_3R_37() {
    if (jj_scan_token(JNI_SHORT)) return true;
    return false;
  }

  final private boolean jj_3R_36() {
    if (jj_scan_token(JNI_BOOLEAN)) return true;
    return false;
  }

  final private boolean jj_3R_35() {
    if (jj_scan_token(JNI_LONG)) return true;
    return false;
  }

  final private boolean jj_3_5() {
    if (jj_3R_16()) return true;
    return false;
  }

  final private boolean jj_3R_34() {
    if (jj_scan_token(JNI_INT)) return true;
    return false;
  }

  final private boolean jj_3R_14() {
    if (jj_3R_19()) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_20()) { jj_scanpos = xsp; break; }
    }
    if (jj_scan_token(82)) return true;
    return false;
  }

  final private boolean jj_3R_33() {
    if (jj_scan_token(JNI_FLOAT)) return true;
    return false;
  }

  final private boolean jj_3R_32() {
    if (jj_scan_token(JNI_DOUBLE)) return true;
    return false;
  }

  final private boolean jj_3R_31() {
    if (jj_scan_token(JNI_CHAR)) return true;
    return false;
  }

  final private boolean jj_3R_40() {
    if (jj_3R_14()) return true;
    return false;
  }

  final private boolean jj_3R_30() {
    if (jj_scan_token(JNI_BYTE)) return true;
    return false;
  }

  final private boolean jj_3R_18() {
    if (jj_3R_14()) return true;
    return false;
  }

  final private boolean jj_3_2() {
    if (jj_3R_14()) return true;
    return false;
  }

  final private boolean jj_3R_16() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_30()) {
    jj_scanpos = xsp;
    if (jj_3R_31()) {
    jj_scanpos = xsp;
    if (jj_3R_32()) {
    jj_scanpos = xsp;
    if (jj_3R_33()) {
    jj_scanpos = xsp;
    if (jj_3R_34()) {
    jj_scanpos = xsp;
    if (jj_3R_35()) {
    jj_scanpos = xsp;
    if (jj_3R_36()) {
    jj_scanpos = xsp;
    if (jj_3R_37()) return true;
    }
    }
    }
    }
    }
    }
    }
    return false;
  }

  final private boolean jj_3R_19() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(53)) {
    jj_scanpos = xsp;
    if (jj_scan_token(55)) {
    jj_scanpos = xsp;
    if (jj_scan_token(56)) {
    jj_scanpos = xsp;
    if (jj_scan_token(57)) {
    jj_scanpos = xsp;
    if (jj_scan_token(58)) {
    jj_scanpos = xsp;
    if (jj_scan_token(59)) {
    jj_scanpos = xsp;
    if (jj_scan_token(60)) {
    jj_scanpos = xsp;
    if (jj_scan_token(61)) {
    jj_scanpos = xsp;
    if (jj_scan_token(62)) {
    jj_scanpos = xsp;
    if (jj_scan_token(67)) return true;
    }
    }
    }
    }
    }
    }
    }
    }
    }
    return false;
  }

  final private boolean jj_3_4() {
    if (jj_3R_16()) return true;
    return false;
  }

  final private boolean jj_3_3() {
    if (jj_3R_15()) return true;
    return false;
  }

  final private boolean jj_3R_39() {
    if (jj_scan_token(JNI_ARRAY)) return true;
    return false;
  }

  final private boolean jj_3R_38() {
    Token xsp;
    if (jj_3R_39()) return true;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_39()) { jj_scanpos = xsp; break; }
    }
    xsp = jj_scanpos;
    if (jj_3_5()) {
    jj_scanpos = xsp;
    if (jj_3R_40()) return true;
    }
    return false;
  }

  final private boolean jj_3R_29() {
    if (jj_scan_token(STRING)) return true;
    return false;
  }

  final private boolean jj_3R_28() {
    if (jj_scan_token(SHORT)) return true;
    return false;
  }

  final private boolean jj_3R_27() {
    if (jj_scan_token(BOOLEAN)) return true;
    return false;
  }

  final private boolean jj_3R_20() {
    if (jj_scan_token(81)) return true;
    if (jj_3R_19()) return true;
    return false;
  }

  final private boolean jj_3R_26() {
    if (jj_scan_token(LONG)) return true;
    return false;
  }

  final private boolean jj_3R_25() {
    if (jj_scan_token(INT)) return true;
    return false;
  }

  final private boolean jj_3R_24() {
    if (jj_scan_token(FLOAT)) return true;
    return false;
  }

  final private boolean jj_3R_23() {
    if (jj_scan_token(DOUBLE)) return true;
    return false;
  }

  final private boolean jj_3_1() {
    if (jj_3R_13()) return true;
    return false;
  }

  final private boolean jj_3R_22() {
    if (jj_scan_token(CHAR)) return true;
    return false;
  }

  final private boolean jj_3R_21() {
    if (jj_scan_token(BYTE)) return true;
    return false;
  }

  final private boolean jj_3R_15() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_21()) {
    jj_scanpos = xsp;
    if (jj_3R_22()) {
    jj_scanpos = xsp;
    if (jj_3R_23()) {
    jj_scanpos = xsp;
    if (jj_3R_24()) {
    jj_scanpos = xsp;
    if (jj_3R_25()) {
    jj_scanpos = xsp;
    if (jj_3R_26()) {
    jj_scanpos = xsp;
    if (jj_3R_27()) {
    jj_scanpos = xsp;
    if (jj_3R_28()) {
    jj_scanpos = xsp;
    if (jj_3R_29()) return true;
    }
    }
    }
    }
    }
    }
    }
    }
    return false;
  }

  final private boolean jj_3R_17() {
    if (jj_3R_38()) return true;
    return false;
  }

  final private boolean jj_3R_13() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_17()) {
    jj_scanpos = xsp;
    if (jj_3R_18()) return true;
    }
    return false;
  }

  public EDLParserTokenManager token_source;
  JavaCharStream jj_input_stream;
  public Token token, jj_nt;
  private int jj_ntk;
  private Token jj_scanpos, jj_lastpos;
  private int jj_la;
  public boolean lookingAhead = false;
  private boolean jj_semLA;
  private int jj_gen;
  final private int[] jj_la1 = new int[95];
  static private int[] jj_la1_0;
  static private int[] jj_la1_1;
  static private int[] jj_la1_2;
  static {
      jj_la1_0();
      jj_la1_1();
      jj_la1_2();
   }
   private static void jj_la1_0() {
      jj_la1_0 = new int[] {0x18,0x18,0x18,0x18,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x400,0x400,0x0,0x800,0x1000,0x0,0x0,0xffff0000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x2000,0x0,0x0,0x2000,0x0,0x0,0x2000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xc000,0xc000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,};
   }
   private static void jj_la1_1() {
      jj_la1_1 = new int[] {0x0,0x0,0x0,0x0,0x0,0xc0,0xc0,0xffbfe000,0x0,0x0,0x0,0xffbfe000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xc00,0x0,0x0,0x0,0x0,0x0,0x7fa00000,0x0,0x33f,0x0,0x7fa00000,0x7fa00000,0x7fa00000,0x0,0x0,0x0,0x0,0x7fa00000,0x0,0xfffff000,0x7fa00000,0x0,0xfffff000,0x7fa00000,0x0,0xfffff000,0x7fa00000,0xfffff000,0x7fa00000,0xfffff000,0x7fa00000,0xfffff000,0x7fa00000,0xfffff000,0x7fa00000,0x0,0x7fa00000,0x0,0x7fa00000,0x0,0x7fa00000,0x0,0x7fa00000,0x0,0x7fa00000,0x0,0x7fa00000,0x0,0x7fa00000,0xffbfe000,0x0,0x0,0xffbfe000,0x0,0x0,0x0,0x0,0xfffff000,0x7fa00000,0x0,0xfffff000,0x401000,0xffa00000,0xffa00000,0x3fe000,0x7f800000,0xffa00000,0x80000000,0x7fa00000,0x0,0xffa00000,0xffa00000,0xffe00000,0xffe00000,0x0,0x7fa00000,};
   }
   private static void jj_la1_2() {
      jj_la1_2 = new int[] {0x0,0x0,0x0,0x0,0x3,0x0,0x0,0x48,0x100,0x80,0x180,0x48,0x100,0x80,0x180,0x3,0xc00,0x3,0x3,0x0,0x200,0x200,0x3,0x0,0x0,0x8,0xc00,0x0,0x1000,0x48,0x48,0x48,0x1000,0x1000,0x1000,0x1000,0x48,0x0,0x81048,0x48,0x0,0x81048,0x48,0x0,0x81048,0x48,0x81048,0x48,0x81048,0x48,0x81048,0x48,0x81048,0x48,0x1000,0x48,0x1000,0x48,0x1000,0x48,0x1000,0x48,0x2000,0x48,0x2000,0x48,0x1000,0x48,0x48,0x80,0x100,0x48,0x80,0x100,0x0,0x0,0x81048,0x48,0x10000,0x80048,0x0,0x8,0x8,0x0,0x0,0x8,0x0,0x8,0x20000,0x60008,0x60008,0x60008,0x60008,0x200000,0x8,};
   }
  final private JJCalls[] jj_2_rtns = new JJCalls[5];
  private boolean jj_rescan = false;
  private int jj_gc = 0;

  public EDLParser(java.io.InputStream stream) {
     this(stream, null);
  }
  public EDLParser(java.io.InputStream stream, String encoding) {
    try { jj_input_stream = new JavaCharStream(stream, encoding, 1, 1); } catch(java.io.UnsupportedEncodingException e) { throw new RuntimeException(e); }
    token_source = new EDLParserTokenManager(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 95; i++) jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  public void ReInit(java.io.InputStream stream) {
     ReInit(stream, null);
  }
  public void ReInit(java.io.InputStream stream, String encoding) {
    try { jj_input_stream.ReInit(stream, encoding, 1, 1); } catch(java.io.UnsupportedEncodingException e) { throw new RuntimeException(e); }
    token_source.ReInit(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 95; i++) jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  public EDLParser(java.io.Reader stream) {
    jj_input_stream = new JavaCharStream(stream, 1, 1);
    token_source = new EDLParserTokenManager(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 95; i++) jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  public void ReInit(java.io.Reader stream) {
    jj_input_stream.ReInit(stream, 1, 1);
    token_source.ReInit(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 95; i++) jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  public EDLParser(EDLParserTokenManager tm) {
    token_source = tm;
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 95; i++) jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  public void ReInit(EDLParserTokenManager tm) {
    token_source = tm;
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 95; i++) jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  final private Token jj_consume_token(int kind) throws ParseException {
    Token oldToken;
    if ((oldToken = token).next != null) token = token.next;
    else token = token.next = token_source.getNextToken();
    jj_ntk = -1;
    if (token.kind == kind) {
      jj_gen++;
      if (++jj_gc > 100) {
        jj_gc = 0;
        for (int i = 0; i < jj_2_rtns.length; i++) {
          JJCalls c = jj_2_rtns[i];
          while (c != null) {
            if (c.gen < jj_gen) c.first = null;
            c = c.next;
          }
        }
      }
      return token;
    }
    token = oldToken;
    jj_kind = kind;
    throw generateParseException();
  }

  static private final class LookaheadSuccess extends java.lang.Error { }
  final private LookaheadSuccess jj_ls = new LookaheadSuccess();
  final private boolean jj_scan_token(int kind) {
    if (jj_scanpos == jj_lastpos) {
      jj_la--;
      if (jj_scanpos.next == null) {
        jj_lastpos = jj_scanpos = jj_scanpos.next = token_source.getNextToken();
      } else {
        jj_lastpos = jj_scanpos = jj_scanpos.next;
      }
    } else {
      jj_scanpos = jj_scanpos.next;
    }
    if (jj_rescan) {
      int i = 0; Token tok = token;
      while (tok != null && tok != jj_scanpos) { i++; tok = tok.next; }
      if (tok != null) jj_add_error_token(kind, i);
    }
    if (jj_scanpos.kind != kind) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) throw jj_ls;
    return false;
  }

  final public Token getNextToken() {
    if (token.next != null) token = token.next;
    else token = token.next = token_source.getNextToken();
    jj_ntk = -1;
    jj_gen++;
    return token;
  }

  final public Token getToken(int index) {
    Token t = lookingAhead ? jj_scanpos : token;
    for (int i = 0; i < index; i++) {
      if (t.next != null) t = t.next;
      else t = t.next = token_source.getNextToken();
    }
    return t;
  }

  final private int jj_ntk() {
    if ((jj_nt=token.next) == null)
      return (jj_ntk = (token.next=token_source.getNextToken()).kind);
    else
      return (jj_ntk = jj_nt.kind);
  }

  private java.util.Vector<int[]> jj_expentries = new java.util.Vector<int[]>();
  private int[] jj_expentry;
  private int jj_kind = -1;
  private int[] jj_lasttokens = new int[100];
  private int jj_endpos;

  private void jj_add_error_token(int kind, int pos) {
    if (pos >= 100) return;
    if (pos == jj_endpos + 1) {
      jj_lasttokens[jj_endpos++] = kind;
    } else if (jj_endpos != 0) {
      jj_expentry = new int[jj_endpos];
      for (int i = 0; i < jj_endpos; i++) {
        jj_expentry[i] = jj_lasttokens[i];
      }
      boolean exists = false;
      for (java.util.Enumeration e = jj_expentries.elements(); e.hasMoreElements();) {
        int[] oldentry = (int[])(e.nextElement());
        if (oldentry.length == jj_expentry.length) {
          exists = true;
          for (int i = 0; i < jj_expentry.length; i++) {
            if (oldentry[i] != jj_expentry[i]) {
              exists = false;
              break;
            }
          }
          if (exists) break;
        }
      }
      if (!exists) jj_expentries.addElement(jj_expentry);
      if (pos != 0) jj_lasttokens[(jj_endpos = pos) - 1] = kind;
    }
  }

  public ParseException generateParseException() {
    jj_expentries.removeAllElements();
    boolean[] la1tokens = new boolean[86];
    for (int i = 0; i < 86; i++) {
      la1tokens[i] = false;
    }
    if (jj_kind >= 0) {
      la1tokens[jj_kind] = true;
      jj_kind = -1;
    }
    for (int i = 0; i < 95; i++) {
      if (jj_la1[i] == jj_gen) {
        for (int j = 0; j < 32; j++) {
          if ((jj_la1_0[i] & (1<<j)) != 0) {
            la1tokens[j] = true;
          }
          if ((jj_la1_1[i] & (1<<j)) != 0) {
            la1tokens[32+j] = true;
          }
          if ((jj_la1_2[i] & (1<<j)) != 0) {
            la1tokens[64+j] = true;
          }
        }
      }
    }
    for (int i = 0; i < 86; i++) {
      if (la1tokens[i]) {
        jj_expentry = new int[1];
        jj_expentry[0] = i;
        jj_expentries.addElement(jj_expentry);
      }
    }
    jj_endpos = 0;
    jj_rescan_token();
    jj_add_error_token(0, 0);
    int[][] exptokseq = new int[jj_expentries.size()][];
    for (int i = 0; i < jj_expentries.size(); i++) {
      exptokseq[i] = (int[])jj_expentries.elementAt(i);
    }
    return new ParseException(token, exptokseq, tokenImage);
  }

  final public void enable_tracing() {
  }

  final public void disable_tracing() {
  }

  final private void jj_rescan_token() {
    jj_rescan = true;
    for (int i = 0; i < 5; i++) {
    try {
      JJCalls p = jj_2_rtns[i];
      do {
        if (p.gen > jj_gen) {
          jj_la = p.arg; jj_lastpos = jj_scanpos = p.first;
          switch (i) {
            case 0: jj_3_1(); break;
            case 1: jj_3_2(); break;
            case 2: jj_3_3(); break;
            case 3: jj_3_4(); break;
            case 4: jj_3_5(); break;
          }
        }
        p = p.next;
      } while (p != null);
      } catch(LookaheadSuccess ls) { }
    }
    jj_rescan = false;
  }

  final private void jj_save(int index, int xla) {
    JJCalls p = jj_2_rtns[index];
    while (p.gen > jj_gen) {
      if (p.next == null) { p = p.next = new JJCalls(); break; }
      p = p.next;
    }
    p.gen = jj_gen + xla - jj_la; p.first = token; p.arg = xla;
  }

  static final class JJCalls {
    int gen;
    Token first;
    int arg;
    JJCalls next;
  }

}
