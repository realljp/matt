/*
 * Copyright 2003-2007, Regents of the University of Nebraska
 *
 *  Licensed under the University of Nebraska Open Academic License,
 *  Version 1.0 (the "License"); you may not use this file except in
 *  compliance with the License. The License must be provided with
 *  the distribution of this software; if the license is absent from
 *  the distribution, please report immediately to galileo@cse.unl.edu
 *  and indicate where you obtained this software.
 *
 *  You may also obtain a copy of the License at:
 *
 *      http://sofya.unl.edu/LICENSE-1.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */

package sofya.ed.structural;

import java.net.*;
import java.io.*;
import java.nio.channels.SocketChannel;
import java.nio.channels.ServerSocketChannel;
import java.nio.channels.AsynchronousCloseException;
import java.util.*;
import java.util.jar.*;

import sofya.base.SConstants;
import sofya.base.SConstants.*;
import sofya.base.StreamRedirector;
import sofya.base.ProtectedJarOutputStream;
import sofya.ed.BadParameterValueException;
import sofya.ed.ParameterValueAbsentException;
import sofya.ed.structural.ProbeMetadata.*;
import sofya.ed.structural.processors.BlockCoverageProcessingStrategy;
import sofya.ed.structural.processors.BlockSequenceProcessingStrategy;
import sofya.ed.structural.processors.BranchCoverageProcessingStrategy;
import sofya.ed.structural.processors.BranchSequenceProcessingStrategy;

import org.apache.bcel.*;
import org.apache.bcel.generic.*;
import org.apache.bcel.classfile.*;
import org.apache.bcel.util.SyntheticRepository;
import org.apache.bcel.util.ClassPath;

/**
 * A program event dispatcher is responsible for launching a subject program
 * and dispatching an event stream of structural events observed during
 * execution.
 *
 * <p>The program event dispatcher executes an instrumented subject in a
 * separate Java virtual machine using a socket to receive the instrumentation
 * probes. By implementing the event dispatcher in this manner, multi-threaded
 * subjects can be monitored correctly (for coverage), subjects can be supplied
 * specialized classpaths, and the event dispatcher can run other program
 * event dispatchers as subjects.</p>
 *
 * <p>The event dispatcher operates by creating a thread to receive and process
 * instrumentation probes generated by the subject through a socket.
 * The main thread then executes the subject in a separate JVM process and
 * waits for it to terminate. It is considered paramount that a subject not be
 * terminated unexpectedly so as to avoid an indeterminate or unstable system
 * state. Therefore, termination of the subject is deferred as long as possible
 * in the event of exceptions related to the event dispatcher. The socket
 * connection to the subject is static and remains open until the
 * subject terminates. This avoids severe performance degradation which is
 * observed when transient socket connections are created for each trace
 * message.</p>
 *
 * <p>To support the static connection mechanism while preserving total self-
 * traceability, a SocketProbe is used for all subjects. This class is packaged
 * into a jar file that is added to the bootstrap classpath of the invoked
 * subject; thus the static method calls to the SocketProbe resolve to the copy
 * shared by the invoking event dispatcher, including when the subject is
 * another event dispatcher, without introducing any ambiguities regarding the
 * locations of subject classes in the classpath. A renamed copy of SocketProbe
 * is also cloned into the jar file at runtime when it is desired to trace the
 * execution of SocketProbe itself. If multiple event dispatchers are being
 * chained together, the original clone is copied to each subsequent
 * dispatcher. For additional details regarding how the instrumentation
 * connection is made from the subject,
 * see {@link sofya.ed.structural.SocketProbe}.</p>
 *
 * <p>When an event dispatcher is running another event dispatcher as its
 * subject, a situation arises in which the subject event dispatcher is running
 * in one JVM process, and the subject event dispatcher's SocketProbe
 * (logically considered a component of the subject event dispatcher)
 * is running in another JVM process. Thus to perform a complete trace of a
 * subject event dispatcher, it is necessary to receive socket connections for
 * trace messages from two different processes. The invoking event dispatcher
 * handles this situation by detecting that the subject is another event
 * dispatcher (or being informed as such) and starting two processing threads
 * executing a special synchronized version of the probe processing method. The
 * subject event dispatcher will be instrumented to start its SocketProbe in
 * a special mode that timestamps the trace messages. The synchronized threads
 * then use the timestamps to preserve the order of the trace messages during
 * processing. All of this special handling is internal - the resulting
 * event stream appears no different than that generated for a regular
 * subject.</p>
 *
 * <p>For security and performance reasons, the event dispatcher socket only
 * listens on the local loopback address (127.0.0.1).  This address is normally
 * a virtual address in software which is never visible external to the machine
 * and should not require data to go through the network hardware.</p>
 *
 * @see sofya.ed.structural.SocketProbe
 * @see sofya.ed.Instrumentor
 * @see sofya.ed.cfInstrumentor
 *
 * @author Alex Kinneer
 * @version 11/22/2006
 */
public class ProgramEventDispatcher extends AbstractEventDispatcher {
    /** The singleton instance of the dispatcher. Only one instance may exist
        because important parts of the class data are static. This is necessary
        to enable the multi-threaded probe processing strategy used when
        another event dispatcher is the subject, and for efficiency. */
    private static ProgramEventDispatcher theDispatcher = null;
    /** The probe processing strategy that this dispatcher is configured
        to use. */
    protected SocketProcessingStrategy processingStrategy;
    /** Holder array for the probe processor runners, only one element is used
        unless the subject is another event dispatcher. */
    protected ProcessorExecutor[] processor = new ProcessorExecutor[2];
    /** Holder array for the probe processing threads, only one element is used
        unless the subject is another event dispatcher. */
    protected static Thread[] processorThread = new Thread[2];

    /** Conditional compilation debug flag. Set to false to ensure the compiler
        will optimize away all print statements guarded by this flag. When set
        to true, it may be convenient to remove the <code>final</code> qualifier
        and uncomment the <code>-d</code> parameter detection in main, so that
        this flag can be activated at the command line.
     */
    protected static final boolean DEBUG = false;

    /** The global configuration and resources for this event dispatcher. */
    protected static EventDispatcherConfiguration config =
            new EventDispatcherConfiguration();

    /** Name of the class currently set to be run by the dispatcher. */
    protected static String className = null;
    /** Set of arguments that will be passed to the subject. */
    protected static String[] subjectArgs = null;
    /** Java classpath that will be set for the subject when it is run. */
    protected static String subjectCP = null;
    /** Set of arguments that will be passed to the Java launcher for
        the subject. */
    protected static String[] jvmArgs = null;
    /** Port on which socket should be opened to receive trace statements. */
    protected static int port = -1;
    /** Flag to control whether stdin will be connected to the subject.
        Set to true when the <code>-i</code> option is used. This is false by
        default since it introduces the overhead of another thread and is not
        consistent with the objectives of automated regression testing. */
    protected static boolean pipeInput = false;
    /** Maximum time subject is allowed to run (0 equals no limit). Set
        using <code>-tl</code> option. */
    protected static int timeLimit = 0;
    /** Name of output file to receive subject's output. This takes precedence
        over <code>sbjout</code>. */
    protected static String outputFile = null;
    /** Stream to which subject's output should be written. */
    protected static PrintStream sbjout = System.out;
    /** Stream to which filter's normal outputs should be written. */
    protected static PrintStream stdout = System.out;
    /** Stream to which filter's error outputs should be written. */
    protected static PrintStream stderr = System.err;

    /** Socket which accepts instrumentation connection(s). */
    protected static volatile ServerSocketChannel serverSocketChannel = null;

    /** Location of the commons-collections library. This is determined in
        the static initializer by searching the classpath for a directory
        containing the appropriate jar file. */
    protected static String collectionsLib = null;

    /** Convenience variable to represent directory separation character. */
    protected static final char fileSep = File.separatorChar;
    /** Convenience variable to represent path separation character. */
    protected static final char pathSep = File.pathSeparatorChar;
    /** Maximum number of instrumentation connections that can be accepted by
        the server socket (simultaneously). Should not need to be greater than
        two (one connection for subject filter and one connection for subject
        filter's SocketProbe).
     */
    public static final int MAX_CONNECTIONS = 2;

    /** Library path passed as a system property to the JVM of the
        subject; used to load support classes required by the probe
        implementation.
     */
    private static final String PROBE_LIB_PATH;

    /*************************************************************************
     * The static initializer determines the location of the
     * commons-collections library and stores it. This is passed to the
     * subject on the bootstrap classpath, so it is accessible to classes
     * in the bootstrap jar file that require collections classes.
     */
    static {
        String classPath = System.getProperty("java.class.path",".");
        String pathSepStr = String.valueOf(pathSep);
        StringTokenizer systemPath =
            new StringTokenizer(classPath, pathSepStr);
        String curPath;
        StringBuilder libPath = new StringBuilder();

        while (systemPath.hasMoreTokens()) {
            curPath = systemPath.nextToken();

            if (curPath.endsWith("commons-collections.jar")) {
                collectionsLib = curPath;
                break;
            }
        }
        libPath.append(collectionsLib);
        
        PROBE_LIB_PATH = libPath.toString();
    }
    
    /*************************************************************************
     * No argument constructor not permitted.
     */
    private ProgramEventDispatcher() {
        throw new AssertionError("Illegal constructor");
    }


    /*************************************************************************
     * Constructs a new event dispatcher using a given processing strategy;
     * private to implement the singleton pattern.
     *
     * @param processingStrategy Processing strategy to be used to process
     * probes received from the instrumentation.
     *
     * @throws CreateException If the commons-collections library could not be
     * found by the static initializer.
     */
    private ProgramEventDispatcher(
            SocketProcessingStrategy processingStrategy) {
        // If the static initializer fails
        if (collectionsLib == null) {
            throw new CreateException("Unable to locate commons collections " +
                    "library");
        }

        setProcessingStrategy(processingStrategy);
    }

    /*************************************************************************
     * Constructs a new event dispatcher using a given processing strategy
     * and directing outputs to specified streams; private to implement the
     * singleton pattern.
     *
     * @param processingStrategy Processing strategy to be used to process
     * probes received from the instrumentation.
     * @param sbjoutStream Output stream to which subject's outputs are to be
     * written. If <code>null</code>, <code>System.out</code> is used by
     * default.
     * @param stdoutStream Output stream to which the event dispatcher's normal
     * outputs are to be written. If <code>null</code>, <code>System.out</code>
     * is used by default. When the dispatcher is compiled in
     * <code>DEBUG</code> mode, debug information is also printed to
     * this stream.
     * @param stderrStream Output stream to which the event dispatcher's error
     * outputs are to be written. If <code>null</code>, <code>System.err</code>
     * is used by default.
     *
     * @throws CreateException If the commons-collections library could not be
     * found by the static initializer.
     */
    private ProgramEventDispatcher(SocketProcessingStrategy processingStrategy,
                                   PrintStream sbjoutStream,
                                   PrintStream stdoutStream,
                                   PrintStream stderrStream)
            throws CreateException {

        // If the static initializer fails
        if (collectionsLib == null) {
            throw new CreateException("Unable to locate commons collections " +
                    "library");
        }

        setProcessingStrategy(processingStrategy);

        setSubjectOutputStream(sbjoutStream);
        setStandardOutputStream(stdoutStream);
        setStandardErrorStream(stderrStream);

        dispatcherReady = true;
    }

    /*************************************************************************
     * Constructs a new event dispatcher with a specified initial
     * configuration; private to implement the singleton pattern.
     *
     * @param className Name of the subject class which is to be executed.
     * @param subjectArgs Set of arguments to be passed to the subject class.
     * @param subjectCP Java classpath that will be set for the subject when it
     * is executed.
     * @param port The port number on which event dispatcher should listen
     * for incoming instrumentation messages from the subject. The valid range
     * is 1024 to 65535. An exception is the value -1, which instructs it
     * to select the default port.
     * @param pipeInput If <code>true</code>, the event dispatcher will
     * redirect input on the standard input stream to the subject's standard
     * input stream.
     * @param timeLimit The length of time in seconds that the subject is
     * allowed to run before being killed.
     * @param sbjoutStream Output stream to which subject's outputs are to be
     * written. If <code>null</code>, <code>System.out</code> is used by
     * default.
     * @param stdoutStream Output stream to which the event dispatcher's normal
     * outputs are to be written. If <code>null</code>, <code>System.out</code>
     * is used by default. When the dispatcher is compiled in
     * <code>DEBUG</code> mode, debug information is also printed to
     * this stream.
     * @param stderrStream Output stream to which the event dispatcher's error
     * outputs are to be written. If <code>null</code>, <code>System.err</code>
     * is used by default.
     *
     * @throws CreateException If the commons-collections library could not be
     * found by the static initializer.
     * @throws IllegalArgumentException If required parameters are missing,
     * invalid parameters are encountered, or data required for optional
     * parameters is missing.
     */
    private ProgramEventDispatcher(SocketProcessingStrategy processingStrategy,
                                   String className, String[] subjectArgs,
                                   String subjectCP, int port,
                                   boolean pipeInput, int timeLimit,
                                   PrintStream sbjoutStream,
                                   PrintStream stdoutStream,
                                   PrintStream stderrStream)
            throws IllegalArgumentException, CreateException {

        // If the static initializer fails
        if (collectionsLib == null) {
            throw new CreateException("Unable to locate commons collections " +
                    "library");
        }

        setProcessingStrategy(processingStrategy);

        configureDispatcher(className, subjectArgs, subjectCP, port,
                   pipeInput, timeLimit, sbjoutStream, stdoutStream,
                   stderrStream);

        dispatcherReady = true;
    }

    ////////////////////////////////////////////////////////////////////////////
    // Factory methods
    ////////////////////////////////////////////////////////////////////////////

    /*************************************************************************
     * Factory method that returns a singleton instance of the event
     * dispatcher.
     *
     * <p>A singleton strategy is enforced because important parts of the
     * class data are static. This is necessary to enable the multi-threaded
     * probe processing strategy used when another event dispatcher is the
     * subject, and for efficiency.</p>
     *
     * @param strategy Processing strategy to be used to process probes
     * received from the instrumentation.
     *
     * @return A new event dispatcher, or a reference to the existing
     * singleton instance. An existing instance can be reconfigured, enabling
     * dispatch of multiple event streams.
     *
     * @throws CreateException If the commons-collections library could not be
     * found by the static initializer.
     */
    public static ProgramEventDispatcher createEventDispatcher(
                SocketProcessingStrategy strategy)
            throws CreateException {
        if (theDispatcher == null) {
            theDispatcher = new ProgramEventDispatcher(strategy);
        }

        return theDispatcher;
    }

    /*************************************************************************
     * Factory method that returns a singleton instance of the event
     * dispatcher.
     *
     * <p>A singleton strategy is enforced because important parts of the
     * class data are static. This is necessary to enable the multi-threaded
     * probe processing strategy used when another event dispatcher is the
     * subject, and for efficiency.</p>
     *
     * @param processingStrategy Processing strategy to be used to process
     * probes received from the instrumentation.
     * @param sbjoutStream Output stream to which subject's outputs are to be
     * written. If <code>null</code>, <code>System.out</code> is used by
     * default.
     * @param stdoutStream Output stream to which the event dispatcher's normal
     * outputs are to be written. If <code>null</code>, <code>System.out</code>
     * is used by default. When the dispatcher is compiled in
     * <code>DEBUG</code> mode, debug information is also printed to
     * this stream.
     * @param stderrStream Output stream to which the event dispatcher's error
     * outputs are to be written. If <code>null</code>, <code>System.err</code>
     * is used by default.
     *
     * @return A new event dispatcher, or a reference to the existing
     * singleton instance. An existing instance can be reconfigured, enabling
     * dispatch of multiple event streams.
     *
     * @throws CreateException If the commons-collections library could not be
     * found by the static initializer.
     */
    public static ProgramEventDispatcher createEventDispatcher(
                SocketProcessingStrategy processingStrategy,
                PrintStream sbjoutStream,
                PrintStream stdoutStream,
                PrintStream stderrStream)
            throws CreateException {
        if (theDispatcher == null) {
            theDispatcher = new ProgramEventDispatcher(
                    processingStrategy, sbjoutStream, stdoutStream,
                    stderrStream);
        }

        return theDispatcher;
    }

    /*************************************************************************
     * Factory method that returns a singleton instance of the event
     * dispatcher.
     *
     * <p>A singleton strategy is enforced because important parts of the
     * class data are static. This is necessary to enable the multi-threaded
     * probe processing strategy used when another event dispatcher is the
     * subject, and for efficiency.</p>
     *
     * @param className Name of the subject class which is to be executed.
     * @param subjectArgs Set of arguments to be passed to the subject class.
     * @param subjectCP Java classpath that will be set for the subject when it
     * is executed.
     * @param port The port number on which event dispatcher should listen
     * for incoming instrumentation messages from the subject. The valid range
     * is 1024 to 65535. An exception is the value -1, which instructs it
     * to select the default port.
     * @param pipeInput If <code>true</code>, the event dispatcher will
     * redirect input on the standard input stream to the subject's standard
     * input stream.
     * @param timeLimit The length of time in seconds that the subject is
     * allowed to run before being killed.
     * @param sbjoutStream Output stream to which subject's outputs are to be
     * written. If <code>null</code>, <code>System.out</code> is used by
     * default.
     * @param stdoutStream Output stream to which the event dispatcher's normal
     * outputs are to be written. If <code>null</code>, <code>System.out</code>
     * is used by default. When the dispatcher is compiled in
     * <code>DEBUG</code> mode, debug information is also printed to
     * this stream.
     * @param stderrStream Output stream to which the event dispatcher's error
     * outputs are to be written. If <code>null</code>, <code>System.err</code>
     * is used by default.
     *
     * @return A new event dispatcher, or a reference to the existing
     * singleton instance. An existing instance can be reconfigured, enabling
     * dispatch of multiple event streams.
     *
     * @throws CreateException If the commons-collections library could not be
     * found by the static initializer.
     * @throws IllegalArgumentException If required parameters are missing,
     * invalid parameters are encountered, or data required for optional
     * parameters is missing.
     */
    public static ProgramEventDispatcher createEventDispatcher(
                SocketProcessingStrategy processingStrategy, String className,
                String[] subjectArgs, String subjectCP, int port,
                boolean pipeInput, int timeLimit, PrintStream sbjoutStream,
                PrintStream stdoutStream, PrintStream stderrStream)
            throws IllegalArgumentException, CreateException {

        if (theDispatcher == null) {
            theDispatcher = new ProgramEventDispatcher(processingStrategy,
                    className, subjectArgs, subjectCP, port, pipeInput,
                    timeLimit, sbjoutStream, stdoutStream, stderrStream);
        }

        return theDispatcher;
    }

    ////////////////////////////////////////////////////////////////////////////
    // Execution control
    ////////////////////////////////////////////////////////////////////////////

    /**
     * Internal class that provides the mechanism to execute the processing
     * strategy in a separate thread or threads.
     */
    private static class ProcessorExecutor implements Runnable {
        private int threadID;
        private SocketProcessingStrategy processor;
        private ServerSocketChannel servChannel;
        private Exception err;

        private static int nextThreadID = 0;
        private static Object connectLock = new Object();

        private ProcessorExecutor() {
        }

        ProcessorExecutor(SocketProcessingStrategy procStrat,
                          ServerSocket servSocket) {
            this.threadID = nextThreadID++;
            this.processor = procStrat;
            this.servChannel = servSocket.getChannel();
        }

        boolean isProcessing() {
            if (!config.isSubjectDispatcher()) {
                return ControlData.threadConnected[threadID];
            }
            else {
                synchronized (ControlData.stateLock) {
                    return ControlData.threadConnected[threadID];
                }
            }
        }

        public void run() {
            SocketChannel recvChannel = null;

            try {
                synchronized(connectLock) {
                    recvChannel = servChannel.accept();
                    isInstrumented = true;
                }
                // The handshake currently consists of validating the
                // instrumentation type.
                try {
                    processor.doHandshake(recvChannel);
                }
                catch (ExecException e) {
                    err = e;
                    return;
                }
            }
            catch (AsynchronousCloseException e) {
                // This happens if the socket accept is interrupted
                // before the subject runs (such as when the specified
                // subject was not a valid class). It may also happen
                // if the subject is an event dispatcher, and only one
                // or the other of the subject dispatcher and probe
                // was instrumented, but not both
                err = new ExecException("Error accepting instrumentation " +
                        "connection!");
                return;
            }
            catch (IOException e) {
                // This may happen the subject is an event dispatcher,
                // and only one or the other of the subject dispatcher
                // and probe was instrumented, but not both
                String msg = e.getMessage();
                if ((msg != null)
                        && msg.toLowerCase().startsWith("socket closed")) {
                    return;
                }
                err = new ExecException("Error accepting instrumentation " +
                                        "connection!", e);
                return;
            }

            try {
                if (config.isSubjectDispatcher()) {
                    processor.processProbesSynchronized(recvChannel,
                            new ControlData(threadID));
                }
                else {
                    processor.processProbes(recvChannel,
                            new ControlData(threadID));
                }
            }
            catch (Exception e) {
                err = e;
            }
            finally {
                try {
                    recvChannel.close();
                }
                catch (IOException e) {
                    // What can we do?
                }
            }
        }

        void stop() {
            ControlData.forceStop[threadID] = true;
        }

        Exception getError() {
            return err;
        }
    }

    /*************************************************************************
     * Signals the processing threads to stop.
     *
     * <p>This method signals the processing threads to forcibly terminate.
     * The socket connection will be closed and any necessary standard
     * cleanup is performed. Use with caution; this will result in
     * incomplete traces and inconsistent behavior in the subject.</p>
     */
    protected void stop() {
        if (processor[0] != null) processor[0].stop();
        if (processor[1] != null) processor[1].stop();
    }

    /*************************************************************************
     * Gets the probe processing strategy currently in use by the event
     * dispatcher.
     *
     * @return The processing strategy being used by the event dispatcher
     * to receive probes.
     */
    public SocketProcessingStrategy getProcessingStrategy() {
        return processingStrategy;
    }

    /*************************************************************************
     * Sets the probe processing strategy to be used by the event
     * dispatcher.
     *
     * @param processingStrategy The processing strategy to be used by the
     * event dispatcher to receive probes.
     */
    public void setProcessingStrategy(
            SocketProcessingStrategy processingStrategy) {
        this.processingStrategy = processingStrategy;
    }

    /*************************************************************************
     * Resets the event dispatcher configuration; the event dispatcher must
     * be reconfigured before it can be run again.
     */
    public void reset() {
        checkRunning("Cannot reset/release running event dispatcher");

        className = null;
        subjectArgs = null;
        subjectCP = null;
        port = -1;
        pipeInput = false;
        timeLimit = 0;
        dispatcherReady = false;
        config.clear();

        this.processingStrategy.reset();

        ProcessorExecutor.nextThreadID = 0;

        dispatcherReady = false;
    }

    /*************************************************************************
     * Reports whether the event dispatcher is ready to begin dispatching
     * the event stream.
     *
     * @return <code>true</code> if the event dispatcher and all attached
     * components indicate that they are ready to being dispatching the
     * event stream.
     */
    protected boolean isReady() {
        return dispatcherReady && processingStrategy.isReady();
    }

    /*************************************************************************
     * Releases this event dispatcher, its processing strategy, and any
     * attached components.
     *
     * <p>After release, attached components may have to be replaced or
     * fully reinitialized.</p>
     */
    public void release() {
        this.reset();
        this.processingStrategy.release();
    }

    /*************************************************************************
     * Registers the probe processor and any attached components.
     */
    public void registerProcessor() {
        config.setStandardOutput(stdout);
        config.setStandardError(stderr);
        config.setSubjectOutput(sbjout);

        this.processingStrategy.register(config);
    }

    /*************************************************************************
     * Starts the server socket to receive the instrumentation connection(s).
     *
     * @throws ExecException If there is an error binding the server socket.
     */
    protected ServerSocket startServer() throws ExecException {
        // Set up server socket, only listens on local loopback
        // (127.0.0.1) for security reasons (and hopefully for
        // performance benefits)
        try {
            serverSocketChannel =
                ServerSocketChannel.open();
            ServerSocket serverSocket = serverSocketChannel.socket();
            serverSocket.bind(new InetSocketAddress("localhost", port),
                MAX_CONNECTIONS);
            return serverSocket;
        }
        catch (BindException e) {
            throw new ExecException("Unable to bind to port " + port, e);
        }
        catch (IOException e) {
            throw new ExecException("Unable to create trace reader socket!",
                                    e);
        }
    }

    /*************************************************************************
     * Stops the server socket, signalling the end of the event stream.
     */
    protected void stopServer() {
        try {
            serverSocketChannel.close();
        }
        catch (IOException e) { }
    }

    /*************************************************************************
     * Performs setup and runs the processing threads threads and subject.
     * This is the main driving method for the event dispatcher.
     *
     * @throws SetupException If there is an error attempting to set up the
     * event dispatcher to run the subject.
     * @throws ExecException If an error occurs executing the subject. This
     * does not include exceptions thrown by the subject itself, only errors
     * in the event dispatcher while attempting to interface with the subject.
     */
    public void startDispatcher() throws SetupException, ExecException {
        if (!isReady()) {
            throw new SetupException("Dispatcher is not ready, it must be " +
                "configured");
        }

        setup();

        processingStrategy.dispatcherStarting();

        runSubject();

        processingStrategy.dispatcherStopped();

        if (!isInstrumented) {
            throw new ExecException("Class is not instrumented");
        }

        Exception err = processor[0].getError();
        if ((err == null) && (processor[1] != null)) {
            err = processor[1].getError();
        }
        
        if (err != null) {
            if (err instanceof ExecException) {
                throw (ExecException) err;
            }
            else {
                throw new ExecException("Error during event dispatch", err);
            }
        }
    }

    /*************************************************************************
     * Performs setup actions to prepare the event dispatcher and subject
     * for execution.
     *
     * <p>This method is responsible for relocating the SocketProbe,
     * patching the subject's classpath, and creating SocketProbeAlt.</p>
     *
     * @throws SetupException If there is an error performing any of the
     * aforementioned tasks.
     */
    protected void setup() throws SetupException {
        // Determine whether we believe the subject is an event dispatcher
        config.setSubjectIsDispatcher(isSubjectDispatcher());

        registerProcessor();

        // If no classpath was specified for the subject, inherit it from
        // our own.
        if (subjectCP == null) {
            subjectCP = System.getProperty("java.class.path");
        }

        if (port == -1) {
            if (config.isSubjectDispatcher()) {
                port = SConstants.DEFAULT_PORT + 1;
            }
            else {
                port = SConstants.DEFAULT_PORT;
            }
        }

        File jarFile = new File("bootstrap.jar");
        if (!jarFile.exists()) {
            try {
                createBootstrapJar();
            }
            catch (SetupException e) {
                // Don't risk leaving a corrupted jar file lying around
                if (jarFile.exists()) {
                    jarFile.delete();
                }
                throw e;
            }
        }
    }

    /*************************************************************************
     * Checks whether the subject is an event dispatcher.
     *
     * <p>This method performs a variety of tests to attempt to determine if
     * the subject is an event dispatcher from the current version of Sofya
     * or one of the earlier Galileo or Sofya event dispatchers (Filter
     * classes).</p>
     *
     * @return <code>true</code> if the subject class is an event dispatcher,
     * <code>false</code> otherwise.
     *
     * @throws SetupException If the subject class or root event dispatcher
     * or filter class cannot be found on the subject classpath for
     * inheritance tests, or if there are any problems loading those classes.
     */
    private boolean isSubjectDispatcher() throws SetupException {
        // Check for known classes that are built on the event dispatchers
        if ("sofya.ed.BBTracer".equals(className)
                || "sofya.ed.BBSequenceTracer".equals(className)
                || "sofya.ed.BranchTracer".equals(className)
                || "sofya.ed.BranchSequenceTracer".equals(className)) {
            return true;
        }

        //System.err.println("PED:827:subjectCP=" + subjectCP);

        String classpath = subjectCP;
        if (classpath == null) {
            classpath = System.getProperty("java.class.path");
        }
        else {
            classpath += File.pathSeparator +
                         System.getProperty("java.class.path");
        }

        //System.err.println("PED:838:classpath=" + classpath);

        org.apache.bcel.util.Repository mainRep = Repository.getRepository();
        SyntheticRepository locRepository = SyntheticRepository.getInstance(
            new ClassPath(classpath));
        Repository.setRepository(locRepository);

        JavaClass dispatcherClass;
        JavaClass subjectClass;
        if (className.startsWith("galileo")) {
            try {
                // Later versions of Galileo had AbstractFilter at the base
                // of the filter class hierarchy, as with Sofya.
                dispatcherClass = Repository.lookupClass(
                    "galileo.inst.AbstractFilter");
            }
            catch (ClassNotFoundException e) {
                // Attempt next test below
            }
            try {
                // Earlier versions of Galileo had Filter at the base of
                // the filter class hierarchy.
                dispatcherClass = Repository.lookupClass(
                    "galileo.inst.Filter");
            }
            catch (ClassNotFoundException e) {
                throw new SetupException("Cannot determine if " +
                    "subject is an event dispatcher: base " +
                    "dispatcher class could not be loaded");
            }
        }
        else {
            try {
                // Initial versions of Sofya had AbstractFilter at the
                // base of the event dispatcher class hierarchy
                dispatcherClass = Repository.lookupClass(
                    "sofya.inst.AbstractFilter");
            }
            catch (ClassNotFoundException e) {
                // AbstractFilter would have to be on the classpath to
                // run the subject if it was an older version of Sofya,
                // so if it is not, we know the subject isn't old Sofya
                return false;
            }
        }

        try {
            subjectClass = Repository.lookupClass(className);
        }
        catch (ClassNotFoundException e) {
            throw new SetupException("Subject class cannot be found on " +
                "subject classpath");
        }

        //System.err.println("PED:889:className=" + className);
        //System.err.println("PED:890:dispatcherClass="
        //    + dispatcherClass.getClassName());

        boolean isSubclass = false;
        try {
            isSubclass = subjectClass.instanceOf(dispatcherClass);
        }
        catch (ClassNotFoundException e) {
            throw new SetupException("Cannot determine if subject " +
                "is an event dispatcher: subject class cannot be found " +
                "on classpath\n  " + e.getMessage());
        }

        Repository.setRepository(mainRep);

        return isSubclass;
    }

    /*************************************************************************
     * Creates and starts the trace statement processing thread(s).
     *
     * <p>Starts the thread(s) to process incoming instrumentation messages.</p>
     *
     * @throws ExecException If there is an error binding the server socket to
     * listen for incoming instrumentation messages.
     */
    protected void startThreads() throws ExecException {
        ServerSocket servSocket = startServer();

        processor[0] = new ProcessorExecutor(processingStrategy, servSocket);
        processorThread[0] = new Thread(processor[0]);
        processorThread[0].start();

        // If the subject is an event dispatcher, two threads are required,
        // since SocketProbe and SocketProbeAlt are communicating from
        // different JVMs
        if (config.isSubjectDispatcher()) {
            if (processor[1] == null) {
                processor[1] =
                        new ProcessorExecutor(processingStrategy, servSocket);
            }
            processorThread[1] = new Thread(processor[1]);
            processorThread[1].start();
        }
    }

    /*************************************************************************
     * Waits for the probe processing threads to exit.
     *
     * <p>This method is used to ensure orderly termination of the
     * threads, regardless of the circumstances under which the event
     * dispatcher exits. If the subject was not found to be instrumented,
     * this method will itself stop the processing threads.</p>
     *
     * @throws ExecException If an exception occurs while waiting for the
     * threads to exit.
     */
    protected void waitOnThreads() throws ExecException {
        try {
            // These joins force the main thread to yield to any processing
            // threads that may still be running. This guarantees that there
            // is an opportunity for the isInstrumented flag to be set. (A
            // small class that executes quickly may make a connection, print
            // all of its trace statements without filling the socket buffer,
            // and then terminate. If this thread then gets scheduled before
            // the processing thread, the flag may not yet be set). The actual
            // timeout duration on the join is probably irrelevant.
            if ((processorThread[0] != null) && processorThread[0].isAlive()) {
                processorThread[0].join(50);
            }
            if ((processorThread[1] != null) && processorThread[1].isAlive()) {
                processorThread[1].join(50);
            }

            // If the processing thread(s) were asleep and the flag was still
            // not set, the subject terminated without ever making a connection,
            // which means it must not have been instrumented. Kill the server
            // socket, which will also allow the processing thread(s) to die.
            if (!isInstrumented) {
                stopServer();
            }
            else {
                try {
                    // Await completion of trace statement processing
                    if (DEBUG) {
                        stdout.println("waiting for thread 1, " +
                            "if necessary");
                    }
                    if ((processorThread[0] != null)
                           && processorThread[0].isAlive()) {
                       processorThread[0].join();
                    }
                    // The only time there are two threads is if the subject is
                    // an event dispatcher. If the subject filter exited
                    // without the second thread receiving a connection, then
                    // we are guaranteed there is nothing to wait for (either
                    // the subject SocketProbe was not instrumented or it was
                    // never loaded because of some other problem).
                    if (DEBUG) {
                        stdout.println("waiting for thread 2, " +
                            "if necessary");
                    }
                    if ((processor[1] != null) && processor[1].isProcessing()) {
                        if ((processorThread[1] != null)
                                && processorThread[1].isAlive()) {
                            processorThread[1].join();
                        }
                    }
                }
                catch (IllegalThreadStateException e) { }
                catch (InterruptedException e) {
                    throw new ExecException("Interrupted while waiting for " +
                        "probe processor to finish!", e);
                }
                finally {
                    stopServer();
                }
            }
        }
        catch (InterruptedException e) {
            throw new ExecException("Abnormal interrupt received.", e);
        }
    }

    /*************************************************************************
     * Executes the subject, handling its inputs and outputs.
     *
     * <p>The subject process is executed, and a thread is created to pipe
     * outputs from the subject. If piping of input to the subject and/or a
     * time limit has been imposed on the subject, those threads are created
     * here also. Upon completion of the subject's execution (or forcible
     * termination), the method waits for the processing threads to finish.</p>
     */
    protected void runSubject() throws ExecException {
        startThreads();

        try {
            isInstrumented = false;
            Process subjectProc = null;
            try {
                ArrayList<Object> cmd = new ArrayList<Object>();
                
                cmd.add("java");
                
                if (jvmArgs != null) {
                    for (int i = 0; i < jvmArgs.length; i++) {
                        cmd.add(jvmArgs[i]);
                    }
                }
                
                cmd.add("-Xbootclasspath/p:./bootstrap.jar");
                cmd.add("-DPROBE_LIB_PATH=" + PROBE_LIB_PATH);
                cmd.add("-cp");
                cmd.add(subjectCP);
                // Fedora Core 4 IP stack fix
                // cmd.add("-Djava.net.preferIPv4Stack=true");
                // End fix
                cmd.add(className);

                for (int i = 0; i < subjectArgs.length; i++) {
                    cmd.add(subjectArgs[i]);
                }

                if (DEBUG) {
                    stdout.println("Exec param: " + cmd.toString());
                }

                Runtime rt = Runtime.getRuntime();
                subjectProc = rt.exec(
                    (String[]) cmd.toArray(new String[cmd.size()]));
            }
            catch (IOException e) {
                throw new ExecException("Error creating subject process!", e);
            }

            // To prevent the subject from possibly deadlocking if it isn't
            // instrumented, read the error stream. If the subject is
            // instrumented, this thread will simply remain asleep for the
            // duration of execution, so performance won't be affected.
            StreamRedirector errRead = new StreamRedirector(
                subjectProc.getErrorStream(), stdout,
                false, stderr);
            Thread errReadThread = new Thread(errRead);
            errReadThread.start();

            // Setup input redirection if necessary
            StreamRedirector pipeIn = null;
            Thread pipeInputThread = null;
            if (pipeInput) {
                pipeIn = new StreamRedirector(System.in,
                    subjectProc.getOutputStream(), true, stderr);
                pipeInputThread = new Thread(pipeIn);
                pipeInputThread.setDaemon(true);
                pipeInputThread.start();
            }

            if (timeLimit > 0) startTimer(subjectProc);

            try {
                pipeOutput(subjectProc);
            }
            catch (IOException e) {
                // Kill the stream redirection threads in an orderly way;
                // we saw some ugly stack dumps on Linux without this
                errRead.stop();
                if (pipeInput) pipeIn.stop();
                try {
                    errReadThread.join();
                    if (pipeInput) pipeInputThread.join();
                }
                catch (InterruptedException e2) {
                    stderr.println("Interruped waiting for termination " +
                        "of redirection thread");
                }

                subjectProc.destroy();

                String msg;
                if (e instanceof FileNotFoundException) {
                    msg = "Could not create output file: " + e.getMessage();
                    // Prevents a stack trace, since this is a somewhat
                    // expected exception
                    e = null;
                }
                else {
                    msg = "Error reading output from subject!";
                }

                throw new ExecException(msg, e);
            }

            try {
                subjectProc.waitFor();
            }
            catch (InterruptedException e) {
                throw new ExecException("Interrupted while waiting for subject " +
                    "to finish!", e);
            }
        }
        finally {
            waitOnThreads();
        }
    }

    /*************************************************************************
     * Starts timer to limit subject execution time.
     *
     * <p>A thread is started which sleeps for the number of seconds specified
     * by <code>timeLimit</code> and then kills the subject process. The
     * thread is set to maximum priority to give it the best possible chance
     * of running once it wakes up, nonetheless no realtime guarantee is
     * made by the timer. <b>Note:</b> If the timer thread is interrupted,
     * it will exit immediately and will<i>not</i> kill the subject
     * process.</p>
     *
     * @param subjectProc Subject process which will be killed, as obtained
     * from a <code>Runtime.exec()</code> call.
     */
    private void startTimer(Process subjectProc) {
        class ProcessTimer implements Runnable {
            private Process proc;
            private int duration;
            public ProcessTimer(Process proc, int duration) {
                this.proc = proc;
                this.duration = duration;
            }
            public void run() {
                try {
                    synchronized(this) {
                        this.wait(duration * 1000);
                    }
                    proc.destroy();
                }
                catch (InterruptedException e) { }
            }
        }
        Thread timerThread = new Thread(
            new ProcessTimer(subjectProc, timeLimit));
        // Let it die if subject finishes normally before time is up
        timerThread.setDaemon(true);
        timerThread.setPriority(Thread.MAX_PRIORITY);
        timerThread.start();
    }

    /*************************************************************************
     * Reads output from subject and redirects to console or file.
     *
     * <p>A subject's standard error stream is immediately reassigned to its
     * standard output stream by the <code>start</code> method in SocketProbe.
     * Since the SocketProbe <code>start</code> method is guaranteed to be
     * the first code executed by an instrumented subject, all of the subject's
     * output is guaranteed to be placed on its standard output stream. (See
     * {@link SocketProbe#start}). As a result, we simply read from its
     * standard out stream and redirect it to the appropriate location until
     * that stream is closed.</p>
     *
     * <p>This mechanism avoids the overhead of additional threads inside the
     * event dispatcher, and is the only means by which the original order of
     * outputs from the subject can be guaranteed to be preserved during
     * redirection by the event dispatcher (due to the lack of scheduling
     * guarantees that would be associated with such threads and lack of
     * guarantees about the flushing of system buffers underlying the streams).
     * If it is absolutely required that the subject's stdout and stderr
     * outputs be distinguished, it is suggested that those streams be
     * reassigned to files in the subject itself.</p>
     *
     * @param subjectProc The subject process, obtained from a call to
     * <code>java.lang.Runtime.exec()</code>.
     *
     * @throws IOException If there is an error while reading from a subject
     * stream or handling the specified target file for redirection.
     */
    private void pipeOutput(Process subjectProc) throws IOException {
        int ch;

        PrintStream tempStream = null;
        if (outputFile != null) {
            try {
                tempStream = sbjout;
                sbjout = new PrintStream(new BufferedOutputStream(
                    new FileOutputStream(outputFile)), true);
            }
            catch (IOException e) {
                throw e;
            }
        }

        //System.out.println("***************Did you passed");
        BufferedReader subjectStdOut = new BufferedReader(
            new InputStreamReader(subjectProc.getInputStream()));
        //System.out.println(subjectStdOut.);
        try {
            while (true) {
                ch = subjectStdOut.read();
                //System.out.println("************"+ch);
                if (ch == -1) {
                    break;
                }
                sbjout.print((char) ch);
                if (!subjectStdOut.ready()) {
                    sbjout.flush();
                }
            }
            sbjout.flush();
            subjectStdOut.close();
        }
        catch (Exception e) {
            e.printStackTrace(stderr);
            stderr.println("Abnormal exception in stream redirection " +
                "thread!");
        }

        if (outputFile != null) {
            sbjout.close();
            sbjout = tempStream;
        }
    }
    
    /*************************************************************************
     * Determines how the event dispatcher should obtain the alternately
     * named probe classes (used when the probe itself is being traced);
     * This is accomplished either by copying them from a parent event
     * dispatcher or creating them, and writing them to the jar
     * output stream.
     *
     * <p>This method uses BCEL to attempt to load the various alternately
     * named probe classes from the classpath. If successful, they are
     * copied directly to the output stream, otherwise they are created
     * from this event dispatcher's copies of the classes.</p>
     *
     * @param stream Jar output stream to which the binary class data for
     * the alternately named probe classes will be written.
     *
     * @throws SetupException For any error that prevents successful creation
     * or copying of the alternately named probe classes.
     */
    private void getAltProbeClasses(JarOutputStream stream)
            throws SetupException {
        Map<Object, Object> toCopy = new HashMap<Object, Object>();
        
        int rootCnt = ProbeMetadata.CLASSES.size();
        Iterator<Object> rootClasses = ProbeMetadata.CLASSES.iterator();
        for (int i = rootCnt; i-- > 0; ) {
            ClassMetadata clData = (ClassMetadata) rootClasses.next();
            
            String prefix;
            if (clData.bootstrap) {
                prefix = "";
            }
            else {
                prefix = Sofya$$Probe$ClassLoader.SOURCE_PREFIX;
            }
            
            String clName = clData.theClass.getName() + "Alt";
            String clPathAndName = prefix + ProbeMetadata.PATH_PREFIX +
                clData.theClass.getSimpleName() + "Alt";
            
            //System.out.println(clName);
            //System.out.println(clPathAndName + ".class");
            try {
                toCopy.put(clPathAndName + ".class", Class.forName(clName));
            }
            catch (ClassNotFoundException e) {
                buildAltProbeClasses(stream);
                return;
            }
            
            Set<Object> inners = clData.innerClasses.keySet();
            int innerCnt = inners.size();
            Iterator<Object> innerClasses = inners.iterator();
            for (int j = innerCnt; j-- > 0; ) {
                String innerShortName = (String) innerClasses.next();
                String innerName = clName + innerShortName;
                
                //System.out.println(innerName);
                //System.out.println(clPathAndName + innerShortName + ".class");
                try {
                    toCopy.put(clPathAndName + innerShortName + ".class",
                        Class.forName(innerName));
                }
                catch (ClassNotFoundException e) {
                    buildAltProbeClasses(stream);
                    return;
                }
            }
        }
        
        byte[] buffer = new byte[4096];
        int size = toCopy.size();
        Iterator<Object> iter = toCopy.keySet().iterator();
        for (int i = size; i-- > 0; ) {
            String pathAndName = (String) iter.next();
            Class cl = (Class) toCopy.get(pathAndName);
            
            try {
                JarEntry jarEntry = new JarEntry(pathAndName);
                stream.putNextEntry(jarEntry);
                copyClassToStream(cl, stream, buffer);
                stream.closeEntry();
            }
            catch (IOException e) {
                throw new SetupException("Could not copy alternate " +
                    "variant of \"" + cl.getName() + "\",\naborting" +
                    "to avoid instrumentation errors!");
            }
        }
    }

    /*************************************************************************
     * Creates the alternately named clones of the probe classes used to
     * enable tracing of the probe classes themselves.
     *
     * <p>This method uses BCEL to copy this event dispatcher's probe classes
     * to clones that have the suffix "Alt" appended to their names, and have
     * constant pool references to probe classes likewise patched to reflect
     * the modified names. The classes will be identical in all other
     * respects. When the instrumentor encounters a probe class, it
     * instruments the class with calls to the alternate probe class name to
     * to avoid infinite recursion.</p>
     *
     * @param stream Output stream to which the binary class data for
     * the alternately named probe classes will be written.
     *
     * @see sofya.inst.SocketProbe
     * @see sofya.inst.cfInstrumentor
     *
     * @throws SetupException For any error that prevents successful creation
     * of SocketProbeAlt.
     */
    private void buildAltProbeClasses(JarOutputStream stream)
            throws SetupException {
        int rootCnt = ProbeMetadata.CLASSES.size();
        Iterator<Object> rootClasses = ProbeMetadata.CLASSES.iterator();
        for (int i = rootCnt; i-- > 0; ) {
            ClassMetadata clData = (ClassMetadata) rootClasses.next();
            
            String prefix;
            if (clData.bootstrap) {
                prefix = "";
            }
            else {
                prefix = Sofya$$Probe$ClassLoader.SOURCE_PREFIX;
            }
            
            String pathAndName = prefix + ProbeMetadata.PATH_PREFIX +
                clData.theClass.getSimpleName();
            
            JavaClass patchedCl = patchProbeRefs(clData.theClass);

            try {
                JarEntry jarEntry = new JarEntry(pathAndName + "Alt.class");
                stream.putNextEntry(jarEntry);
                patchedCl.dump(stream);
                stream.closeEntry();
            }
            catch (Exception e) {
                throw new SetupException("Unable to create alternate " +
                    "variant of \"" + clData.theClass.getName() + "\",\n" +
                    "aborting to avoid instrumentation errors!", e);
            }
            
            Set<Object> inners = clData.innerClasses.keySet();
            int innerCnt = inners.size();
            Iterator<Object> innerClasses = inners.iterator();
            for (int j = innerCnt; j-- > 0; ) {
                String innerName = (String) innerClasses.next();
                Class innerCl = (Class) clData.innerClasses.get(innerName);
                
                patchedCl = patchProbeRefs(innerCl);
                
                try {
                    JarEntry jarEntry = new JarEntry(pathAndName +
                        "Alt" + innerName + ".class");
                    stream.putNextEntry(jarEntry);
                    patchedCl.dump(stream);
                    stream.closeEntry();
                }
                catch (Exception e) {
                    throw new SetupException("Unable to create alternate " +
                        "variant of \"" + innerCl.getName() + "\",\n" +
                        "aborting to avoid instrumentation errors!", e);
                }
            }
        }
    }
    
    /*************************************************************************
     * Patches a probe class by modifying it to its alternate name, and
     * updating constant pool references to other probe classes to likewise
     * use the alternate names.
     * 
     * @param clazz Probe class to be patched.
     * 
     * @return BCEL representation of the patched class, from which the
     * class bytes can be obtained.
     * 
     * @throws SetupException If the bytecode for the given class cannot
     * be loaded.
     */
    private JavaClass patchProbeRefs(Class clazz) throws SetupException {
        JavaClass javaClass;
        String clName = clazz.getName();
        Set<Object> patchShortNames = ProbeMetadata.ROOT_SHORT_NAMES;
        int checkCount = patchShortNames.size();
        
        try {
            javaClass = Repository.lookupClass(clazz);
        }
        catch (ClassNotFoundException e) {
            throw new SetupException("Unable to create alternate " +
                "variant of \"" + clName + "\",\naborting" +
                "to avoid instrumentation errors!");
        }
        
        ClassGen cg = new ClassGen(javaClass);
        ConstantPoolGen cpg = cg.getConstantPool();
        Constant[] cp = javaClass.getConstantPool().getConstantPool();
        int numConstants = cp.length;
        
        // Cycle through all UTF8 constants. For any containing
        // the simple names of any probe classes, substitute the
        // alternate simple name. The package is assumed to be invariant.
        StringBuilder val = new StringBuilder();
        for (int i = numConstants - 1; i >= 0; i--) {
            if (cp[i] instanceof ConstantUtf8) {
                ConstantUtf8 utfConstant = (ConstantUtf8) cp[i];
                val.append(utfConstant.getBytes());
                
                Iterator<Object> iter = patchShortNames.iterator();
                for (int j = checkCount; j-- > 0; ) {
                    String checkName = (String) iter.next();
                    
                    int startIdx = val.indexOf(checkName);
                    if (startIdx >= 0) {
                        int endIdx = startIdx + checkName.length();
                        val.replace(startIdx, endIdx, checkName + "Alt");
                        break;
                    }
                }
                
                utfConstant.setBytes(val.toString());
                val.setLength(0);
            }
        }
        
        cg.setConstantPool(cpg);
        
        return cg.getJavaClass();
    }

    /*************************************************************************
     * Creates a jar file containing various 'bootstrap' classes to be
     * prepended to the subject's bootstrap classpath.
     *
     * <p>Currently the following classes are inserted into the jar file:
     * <ul>
     * <li><code>java.lang.Runtime</code>: This class is trivially patched
     * to ensure that {@link SocketProbe#finish} is
     * called by the <code>exit</code> and <code>halt</code> methods
     * (The <code>System.exit</code> method calls <code>Runtime.exit</code>
     * internally). This ensures that pending trace information is
     * captured when using optimized forms of instrumentation.</li>
     * <li><code>sofya.ed.structural.SocketProbe</code>: Provides the
     * subject's connection to the event dispatcher (as always), and is
     * consistent with the classpath override pattern required for chaining
     * event dispatchers.</li>
     * <li><code>sofya.ed.structural.SocketProbe$LRUTraceMap</code>: Internal
     * class dependency of SocketProbe.</li>
     * <li><code>sofya.base.SConstants</code>: Defines constants used by the
     * SocketProbe class.</li>
     * <li><i>(If necessary)</i>
     * <code>sofya.ed.structural.SocketProbeAlt</code>:
     * Support class required to trace an instrumented SocketProbe, when
     * applicable.</li>
     * </ul>
     * </p>
     *
     * <p>The Runtime class is obtained from the current boot classpath,
     * so the patching mechanism is JDK/JRE version independent.</p>
     *
     * @throws SetupException On any error that prevents successful creation
     * of the bootstrap jar file.
     */
    private void createBootstrapJar() throws SetupException {
        byte[] buffer = new byte[4096];

        // Find the Java bootstrap classes archive
        StringTokenizer stok = new StringTokenizer(
            System.getProperty("sun.boot.class.path"),
            System.getProperty("path.separator"));
        String pathElement = null;
        boolean found = false;
        while (stok.hasMoreTokens()) {
            pathElement = stok.nextToken();
            if (pathElement.endsWith("rt.jar")
                    || pathElement.endsWith("classes.zip")) {
                found = true;
                break;
            }
        }
        if (!found) {
            throw new SetupException("Unable to patch runtime class " +
                "for subject");
        }

        // Read Runtime class
        JavaClass clazz = null;
        try {
            clazz = new ClassParser(pathElement,
                "java/lang/Runtime.class").parse();
        }
        catch (Exception e) {
            throw new SetupException("Unable to set up runtime for " +
                "subject", e);
        }
        
        String fullProbeName = ProbeMetadata.PACKAGE_PREFIX +
            ProbeMetadata.INTERFACE_NAME;
        ClassGen cg = new ClassGen(clazz);
        ConstantPoolGen cpg = cg.getConstantPool();
        Method[] methods = cg.getMethods();
        MethodGen mg;
        InstructionList il;
        
        InstructionFactory iFactory = new InstructionFactory(cpg);
        GETSTATIC instFieldLoad = iFactory.createGetStatic(fullProbeName,
            "probe", new ObjectType(fullProbeName));
        InvokeInstruction finishCall = iFactory.createInvoke(fullProbeName,
            "finish", Type.VOID, new Type[0], Constants.INVOKEINTERFACE);

        // Patch Runtime.exit(int) and Runtime.halt(int) to ensure
        // SocketProbe.finish() is called
        int len = methods.length;
        for (int i = 0; i < len; i++) {
            if (methods[i].getName().equals("exit")) {
                mg = new MethodGen(methods[i], "java.lang.Runtime", cpg);
                il = mg.getInstructionList();
                il.insert(il.getStart(), finishCall);
                il.insert(il.getStart(), instFieldLoad);
                mg.setInstructionList(il);
                mg.setMaxStack();
                cg.setMethodAt(mg.getMethod(), i);
            }
            else if (methods[i].getName().equals("halt")) {
                mg = new MethodGen(methods[i], "java.lang.Runtime", cpg);
                il = mg.getInstructionList();
                il.insert(il.getStart(), finishCall);
                il.insert(il.getStart(), instFieldLoad);
                mg.setInstructionList(il);
                mg.setMaxStack();
                cg.setMethodAt(mg.getMethod(), i);
            }
        }

        // Create the jar file. The dump method of BCEL's JavaClass class
        // exhibits the highly irritating behavior of closing the output
        // stream automatically (or at least did, at one point in the past),
        // so we give it a special subclass which disables the close method.
        ProtectedJarOutputStream jos = null;
        try {
            jos = new ProtectedJarOutputStream(
                  new BufferedOutputStream(
                  new FileOutputStream("bootstrap.jar")));

            // Add the patched Runtime class
            JarEntry jarEntry = new JarEntry("java/lang/Runtime.class");
            jos.putNextEntry(jarEntry);
            cg.getJavaClass().dump(jos);
            jos.closeEntry();
            
            // Add SConstants
            jarEntry = new JarEntry(ProbeMetadata.PATH_PREFIX +
                "SConstants.class");
            jos.putNextEntry(jarEntry);
            copyClassToStream(SConstants.class, jos, buffer);
            jos.closeEntry();
            
            int rootCnt = ProbeMetadata.CLASSES.size();
            Iterator<Object> rootClasses = ProbeMetadata.CLASSES.iterator();
            for (int i = rootCnt; i-- > 0; ) {
                ClassMetadata clData = (ClassMetadata) rootClasses.next();
                
                String prefix;
                if (clData.bootstrap) {
                    prefix = "";
                }
                else {
                    prefix = Sofya$$Probe$ClassLoader.SOURCE_PREFIX;
                }
                
                String pathAndName = prefix + ProbeMetadata.PATH_PREFIX +
                    clData.theClass.getSimpleName();
                
                jarEntry = new JarEntry(pathAndName + ".class");
                jos.putNextEntry(jarEntry);
                copyClassToStream(clData.theClass, jos, buffer);
                jos.closeEntry();
                
                Set<Object> inners = clData.innerClasses.keySet();
                int innerCnt = inners.size();
                Iterator<Object> innerClasses = inners.iterator();
                for (int j = innerCnt; j-- > 0; ) {
                    String innerName = (String) innerClasses.next();
                    Class innerCl = (Class) clData.innerClasses.get(innerName);
                    
                    jarEntry = new JarEntry(pathAndName +
                        innerName + ".class");
                    jos.putNextEntry(jarEntry);
                    copyClassToStream(innerCl, jos, buffer);
                    jos.closeEntry();
                }
            }
            
            // Add alternate-named variants of probe classes
            getAltProbeClasses(jos);
        }
        catch (IOException e) {
            throw new SetupException("Unable to set up probe for " +
                "subject", e);
        }
        finally {
            if (jos != null) {
                try {
                    jos.closeStream();
                }
                catch (IOException e) {
                    e.printStackTrace(stderr);
                }
            }
        }
    }

    /*************************************************************************
     * Copies a class loaded by the classloader to an output stream.
     *
     * @param cl Class to be copied.
     * @param stream Output stream to which the class bytes should be
     * written.
     * @param buffer Buffer which will be used to perform the copy
     * operation.
     *
     * @throws IOException If there is any error reading the class bytes
     * or writing to the stream.
     */
    private void copyClassToStream(Class cl, OutputStream stream,
                                   byte[] buffer)
            throws IOException {
        ClassLoader cloader = cl.getClassLoader();
        if (cloader == null) {
            cloader = ClassLoader.getSystemClassLoader();
        }

        String className = cl.getName().replace('.', '/') + ".class";
        InputStream is =  cloader.getResourceAsStream(className);

        if (is == null) {
            throw new IOException("Could not find class '" + className +
                                  " on classpath");
        }

        try {
            int readCount;
            while ((readCount = is.read(buffer)) != -1) {
                stream.write(buffer, 0, readCount);
            }
        }
        finally {
            is.close();
        }
    }

    /*************************************************************************
     * Checks whether the event dispatcher is currently running its subject
     * and throws an exception if so.
     *
     * <p>This method can be used to guard operations that should not be
     * performed while the event dispatcher is actively running a subject.</p>
     *
     * @param msg Message to be assigned to the exception.
     *
     * @throws IllegalStateException If the event dispatcher is currently
     * running its subject.
     */
    protected void checkRunning(String msg) throws IllegalStateException {
        synchronized(ControlData.stateLock) {
            if (ControlData.threadConnected[0]
                    || ControlData.threadConnected[1]) {
                throw new IllegalStateException(msg);
            }
        }
    }

    ////////////////////////////////////////////////////////////////////////////
    // Configuration
    ////////////////////////////////////////////////////////////////////////////

    /*************************************************************************
     * Configures the event dispatcher with a new set of parameters to run a
     * subject class.
     *
     * @param className Name of the subject class which is to be executed.
     * @param subjectArgs Set of arguments to be passed to the subject class.
     * @param subjectCP Java classpath that will be set for the subject when it
     * is executed.
     * @param port The port number on which event dispatcher should listen
     * for incoming instrumentation messages from the subject. The valid range
     * is 1024 to 65535. An exception is the value -1, which instructs it
     * to select the default port.
     * @param pipeInput If <code>true</code>, the event dispatcher will
     * redirect input on the standard input stream to the subject's standard
     * input stream.
     * @param timeLimit The length of time in seconds that the subject is
     * allowed to run before being killed.
     * @param sbjoutStream Output stream to which subject's outputs are to be
     * written. If <code>null</code>, <code>System.out</code> is used by
     * default.
     * @param stdoutStream Output stream to which the event dispatcher's normal
     * outputs are to be written. If <code>null</code>, <code>System.out</code>
     * is used by default. When the dispatcher is compiled in
     * <code>DEBUG</code> mode, debug information is also printed to
     * this stream.
     * @param stderrStream Output stream to which the event dispatcher's error
     * outputs are to be written. If <code>null</code>, <code>System.err</code>
     * is used by default.
     *
     * @throws IllegalArgumentException If required parameters are missing,
     * invalid parameters are encountered, or data required for optional
     * parameters is missing.
     * @throws IllegalStateException If called while the event dispatcher
     * is running.
     */
    public void configureDispatcher(String className, String[] subjectArgs,
                String subjectCP, int port, boolean pipeInput,
                int timeLimit, PrintStream sbjoutStream,
                PrintStream stdoutStream, PrintStream stderrStream)
            throws IllegalArgumentException, IllegalStateException {
        checkRunning("Cannot configure while filter is running");

        setClassName(className);
        setClassArguments(subjectArgs);
        setSubjectClasspath(subjectCP);
        setPort(port);
        setRedirectInput(pipeInput);
        setTimeLimit(timeLimit);
        setSubjectOutputStream(sbjoutStream);
        setStandardOutputStream(stdoutStream);
        setStandardErrorStream(stderrStream);

        dispatcherReady = true;
    }

    /*************************************************************************
     * Configures this event dispatcher using the specified set of command
     * line parameters.
     *
     * @param params Array of command line parameters.
     *
     * @return A list of parameters that were unrecognized. If the method
     * does not throw an exception, the event dispatcher will have been
     * configured to a runnable state, thus it is at the discretion of the
     * caller whether or not to do anything with this list.
     *
     * @throws IllegalArgumentException If required parameters are missing
     * or data required for optional parameters is missing.
     * @throws IllegalStateException If called while the event dispatcher
     * is running.
     */
    public List<String> configureDispatcher(String[] params)
                throws IllegalArgumentException, IllegalStateException {
        checkRunning("Cannot configure while event dispatcher is running");
        return configureDispatcher(new LinkedList<String>(
            Arrays.asList(params)));
    }

    /*************************************************************************
     * Configures this event dispatcher using the specified set of command line
     * parameters.
     *
     * <p>The public method first ensures that all state variables are
     * cleared before calling this method. It is expected that implementations
     * will remove from the list those parameters which it has successfully
     * processed. This creates an extensible model that permits new
     * parameters to be defined by attached classes implementing
     * {@link ActiveComponent}. Such a component can process all the parameters
     * that it recognizes and then pass the remainder of the list back
     * to be provided to other components for processing or returned to
     * the caller.</p>
     *
     * @param params List of strings containing the command line parameters.
     *
     * @return A list of parameters that were unrecognized. Other components
     * may attempt to process these parameters, or they can be returned back
     * to the caller for handling (usually to report as an error).
     *
     * @throws IllegalArgumentException If required parameters are missing
     * or data required for optional parameters is missing.
     * @throws IllegalStateException If called while the event dispatcher
     * is running.
     */
    public List<String> configureDispatcher(List<String> params)
                   throws IllegalArgumentException, IllegalStateException {
        checkRunning("Cannot configure while filter is running");

        // Reset to clear any current configuration first
        reset();

        boolean portSet = false;

        if (params.size() < 1) {
            throw new IllegalArgumentException("No subject class specified");
        }
       
        int chainStopIndex = -1;
        ListIterator<String> li = params.listIterator();
        for (li = params.listIterator(); li.hasNext(); ) {
            String param = li.next();
            if (param.startsWith("-")) {
                if (param.equals("-cp")) {
                    li.remove();
                    if (li.hasNext()) {
                        subjectCP = li.next();
                        li.remove();
                    }
                    else {
                        throw new ParameterValueAbsentException("Classpath " +
                                "not supplied");
                    }
                }
                else if (param.equals("-main")) {
                    li.remove();
                    if (li.hasNext()) {
                        className = li.next();
                        li.remove();
                        chainStopIndex = li.nextIndex();
                        break;
                    }
                    else {
                        throw new ParameterValueAbsentException("Main class " +
                        "not supplied");
                    }
                }
                else if (param.equals("-port")) {
                    li.remove();
                    if (li.hasNext()) {
                        try {
                            port = Integer.parseInt(li.next());
                        }
                        catch (NumberFormatException e) {
                            throw new BadParameterValueException("Port " +
                                "argument must be numeric");
                        }
                        portSet = true;
                        li.remove();
                    }
                    else {
                        throw new ParameterValueAbsentException("Port " +
                            "number not supplied");
                    }
                }
                else if (param.equals("-i")) {
                    li.remove();
                    pipeInput = true;
                }
                else if (param.equals("-tl")) {
                    li.remove();
                    if (li.hasNext()) {
                        try {
                            timeLimit = Integer.parseInt(li.next());
                        }
                        catch (NumberFormatException e) {
                            throw new BadParameterValueException("Time " +
                                "limit argument must be numeric");
                        }
                        li.remove();
                    }
                    else {
                        throw new ParameterValueAbsentException("Time limit " +
                                "not specified");
                    }
                }
                else if (param.equals("-o")) {
                    li.remove();
                    if (li.hasNext()) {
                        outputFile = li.next();
                        li.remove();
                    }
                    else {
                        throw new ParameterValueAbsentException("Output " +
                            "file not specified");
                    }
                }
                else if (param.equals("-ja")) {
                    li.remove();
                    
                    List<String> argList = new ArrayList<String>();
                    while (li.hasNext()) {
                        String token = li.next();
                        
                        if (token.equals("__end")) {
                            li.remove();
                            break;
                        }
                        
                        argList.add(token);
                        li.remove();
                    }
                    
                    jvmArgs = argList.toArray(new String[argList.size()]);
                }
                /*else if (param.equals("-d")) {
                    debug = true;
                }*/
            }
        }
        if (chainStopIndex == -1) {
            chainStopIndex = params.size();
        }

        //System.out.println(params.subList(0, chainStopIndex));
        
        processingStrategy.configure(params.subList(0, chainStopIndex));

        if (params.size() == 0) {
            throw new IllegalArgumentException("You must specify an " +
                "instrumented subject class to be run");
        }
        else {
            li = params.listIterator();
            
            if (className == null) {
                try {
                    while (true) {
                        className = (String) li.next();
                        if (!className.startsWith("-")) break;
                    }
                }
                catch (NoSuchElementException e) {
                    throw new IllegalArgumentException("You must specify an " +
                        "instrumented subject class to be run");
                }
                setClassName(className);
                li.remove();
            }
            
            LinkedList<Object> args = new LinkedList<Object>();
            while (li.hasNext()) {
                args.add(li.next());
                li.remove();
            }
            subjectArgs = (String[]) args.toArray(new String[args.size()]);
        }
        
        //System.out.println("className=" + className);
        //System.out.println("subjectArgs=" + java.util.Arrays.toString(subjectArgs));

        if (!portSet) {
            port = -1;  // Default will be selected
        }
        else if (port < 1024 || port > 65535) {
            throw new BadParameterValueException("Port " + port + " out of " +
                "range (valid range is 1024-65535)");
        }

        dispatcherReady = true;

        return params;
    }

    /*************************************************************************
     * Gets the name of the subject class.
     *
     * @return The name of the subject class being executed by the
     * event dispatcher.
     */
    public String getClassName() {
        return className;
    }

    /*************************************************************************
     * Sets the name of the subject class.
     *
     * @param value The name of the subject class to be executed by the
     * event dispatcher.
     */
    public void setClassName(String value) throws IllegalStateException {
        if ((value == null) || (value.length() == 0)) {
            throw new IllegalArgumentException("Class name must be specified");
        }
        checkRunning("Cannot set class name while event dispatcher " +
                     "is running");
        className = value;
    }

    /*************************************************************************
     * Gets the arguments to the subject class.
     *
     * @return The arguments that will be passed to the subject when it is run
     * by the event dispatcher.
     */
    public String[] getClassArguments()  {
        return subjectArgs;
    }

    /*************************************************************************
     * Sets the arguments to the subject class.
     *
     * @param arguments The arguments that should be passed to the subject when
     * it is run by the event dispatcher.
     */
    public void setClassArguments(String[] arguments)
                throws IllegalStateException {
        checkRunning("Cannot set subject arguments while event dispatcher " +
                     "is running");
        if (arguments == null) {
            subjectArgs = new String[0];
        }
        else {
            subjectArgs = arguments;
        }
    }

    /*************************************************************************
     * Gets the subject classpath.
     *
     * @return The classpath that will be set for the subject when it is run
     * by the event dispatcher.
     */
    public String getSubjectClasspath()  {
        return subjectCP;
    }

    /*************************************************************************
     * Sets the subject classpath.
     *
     * @param cp The classpath that should be set for the subject when
     * it is run by the event dispatcher.
     */
    public void setSubjectClasspath(String cp) throws IllegalStateException {
        checkRunning("Cannot set subject classpath while event dispatcher " +
                     "is running");
        if (cp == null) {
            subjectCP = System.getProperty("java.class.path");
        }
        else {
            subjectCP = cp;
        }
    }

    /*************************************************************************
     * Gets the name of the file to which subject output is redirected, if any.
     *
     * <p><b>Note:</b> Even if the subject's output is not being directed to a
     * file, it may still be redirected to an output stream. However,
     * file redirection takes precedence over any specified stream.
     *
     * @return The name of the file, including path, to which subject output
     * will be redirected, <code>null</code> if output is not being redirected
     * to file.
     */
    public String getSubjectOutputFile()  {
        return outputFile;
    }

    /*************************************************************************
     * Sets the file to which the subject's outputs should be redirected.
     *
     * <p>Specifying a file for redirection in this manner takes precedence
     * over any requests to redirect output to a stream. You can pass
     * <code>null</code> to this method to cause the event dispatcher to
     * revert to the last stream specified for redirection.</p>
     *
     * @param fileName Name of the file to which output should be redirected,
     * including path if desired. If <code>null</code>, disables redirection to
     * file and causes the event dispatcher to default to the last specified
     * stream (<code>stdout</code> if none has been specified).
     */
    public void setSubjectOutputFile(String fileName)
                throws IllegalStateException {
        checkRunning("Cannot set output file while the event dispatcher " +
                     "is running");
        outputFile = fileName;
    }

    /*************************************************************************
     * Gets the socket port on which the event dispatcher will listen for
     * instrumentation from the subject.
     *
     * @return The port number on which the event dispatcher will connect
     * the socket to listen for incoming instrumentation messages from
     * the subject.
     */
    public int getPort()  {
        if (port != -1) {
            return port;
        }
        else {
            try {
                if (isSubjectDispatcher()) {
                    return SConstants.DEFAULT_PORT + 1;
                }
                else {
                    return SConstants.DEFAULT_PORT;
                }
            }
            catch (SetupException e) {
                throw new IllegalStateException(e.getMessage());
            }
        }
    }

    /*************************************************************************
     * Sets the socket port on which the event dispatcher will listen for
     * instrumentation from the subject.
     *
     * @param p The port number on which the event dispatcher should listen
     * for incoming instrumentation messages from the subject. The valid range
     * is 1024 to 65535. An exception is the value -1, which instructs it
     * to select the default port.
     */
    public void setPort(int p) throws IllegalStateException {
        checkRunning("Cannot set port while the event dispatcher is running");
        if ((p != -1) && (p < 1024 || p > 65535)) {
            throw new IllegalArgumentException("Port " + p +
                " out of range (valid range is 1024-65535)");
        }
        else {
            port = p;
        }
    }

    /*************************************************************************
     * Gets the maximum time in seconds that a subject is allowed to run
     * before being forcibly terminated.
     *
     * @return The length of time in seconds that a subject can run before
     * being killed. 0 (zero) signifies that a subject is permitted to run
     * indefinitely.
     */
    public int getTimeLimit()  {
        return timeLimit;
    }

    /*************************************************************************
     * Sets the maximum time in seconds that a subject is allowed to run
     * before being forcibly terminated.
     *
     * @param tl The length of time in seconds that the subject can run before
     * being killed. 0 (zero) signifies that a subject is permitted to
     * run indefinitely.
     */
    public void setTimeLimit(int tl) throws IllegalStateException {
        checkRunning("Cannot set time limit while the event dispatcher " +
                     "is running");
        timeLimit = tl;
    }

    /*************************************************************************
     * Reports whether the event dispatcher is set to redirect input on
     * standard input to the subject's standard input stream.
     *
     * @return <code>true</code> if the event dispatcher is to redirect input
     * on <code>stdin</code> to the subject, <code>false</code> otherwise.
     */
    public boolean getRedirectInput()  {
        return pipeInput;
    }

    /*************************************************************************
     * Sets whether the event dispatcher will redirect input on standard input
     * to the subject's standard input stream.
     *
     * @param enable <code>true</code> to enable redirection,
     * <code>false</code> to disable.
     */
    public void setRedirectInput(boolean enable) throws IllegalStateException {
        checkRunning("Cannot change input redirection while the event " +
                     "dispatcher is running");
        pipeInput = enable;
    }

    /*************************************************************************
     * Sets the stream to which subject outputs will be written.
     *
     * @param sbjoutStream Output stream to which subject outputs are to be
     * written.
     */
    public void setSubjectOutputStream(OutputStream sbjoutStream) {
        if (sbjoutStream == null) {
            sbjout = System.out;
        }
        else if (sbjoutStream instanceof PrintStream) {
            sbjout = (PrintStream) sbjoutStream;
        }
        else {
            sbjout = new PrintStream(
                new BufferedOutputStream(sbjoutStream), true);
        }
    }

    /*************************************************************************
     * Sets the stream to which the event dispatcher standard outputs will
     * be written.
     *
     * @param stdoutStream Output stream to which the event dispatcher standard
     * outputs are to be written.
     */
    public void setStandardOutputStream(OutputStream stdoutStream) {
        if (stdoutStream == null) {
            stdout = System.out;
        }
        else if (stdoutStream instanceof PrintStream) {
            stdout = (PrintStream) stdoutStream;
        }
        else {
            stdout = new PrintStream(
                new BufferedOutputStream(stdoutStream), true);
        }
    }

    /*************************************************************************
     * Sets the stream to which the event dispatcher error outputs will
     * be written.
     *
     * @param stderrStream Output stream to which the event dispatcher error
     * outputs are to be written.
     */
    public void setStandardErrorStream(OutputStream stderrStream) {
        if (stderrStream == null) {
            stderr = System.err;
        }
        else if (stderrStream instanceof PrintStream) {
            stderr = (PrintStream) stderrStream;
        }
        else {
            stderr = new PrintStream(
                new BufferedOutputStream(stderrStream), true);
        }
    }

    ////////////////////////////////////////////////////////////////////////////
    // Convenience factory methods
    ////////////////////////////////////////////////////////////////////////////

    /*************************************************************************
     * Constructs a ready to run event dispatcher to collect basic block
     * coverage traces, equivalent to the old Sofya <code>Filter</code>
     * class.
     *
     * @param argv Array of command line parameters.
     * @param sbjout Output stream to which subject's outputs are to be
     * written. If <code>null</code>, <code>System.out</code> is used by
     * default.
     * @param stdout Output stream to which the event dispatcher's normal
     * outputs are to be written. If <code>null</code>, <code>System.out</code>
     * is used by default. When the dispatcher is compiled in
     * <code>DEBUG</code> mode, debug information is also printed to
     * this stream.
     * @param stderr Output stream to which the event dispatcher's error
     * outputs are to be written. If <code>null</code>, <code>System.err</code>
     * is used by default.
     *
     * @return A new event dispatcher, or a reference to the existing
     * singleton instance. An existing instance can be reconfigured, enabling
     * dispatch of multiple event streams.
     *
     * @throws CreateException If the commons-collections library could not be
     * found by the static initializer.
     */
    public static ProgramEventDispatcher createBlockCoverageTracer(
                String[] argv, PrintStream sbjout, PrintStream stdout,
                PrintStream stderr)
            throws CreateException {
        BlockCoverageProcessingStrategy strategy =
            new BlockCoverageProcessingStrategy();
        TraceHandler traceHandler = new TraceHandler();
        strategy.setCoverageListenerManager(traceHandler);

        ProgramEventDispatcher blockTracer = createEventDispatcher(
            strategy, sbjout, stdout, stderr);

        List<String> badParams = blockTracer.configureDispatcher(
            new LinkedList<String>(Arrays.asList(argv)));
        int badCount = badParams.size();
        if (badCount > 0) {
            StringBuilder sb = new StringBuilder();
            Iterator<String> li = badParams.iterator();
            for (int i = badCount; i-- > 0; ) {
                sb.append("'");
                sb.append(li.next());
                sb.append("' ");
            }
            throw new IllegalArgumentException("Unrecognized " +
                "parameter(s): " + sb.toString());
        }

        traceHandler.setTypeFlags(strategy.getTypeFlags());
        traceHandler.initialize();

        return blockTracer;
    }

    /*************************************************************************
     * Constructs a ready to run event dispatcher to collect basic block
     * sequence traces, equivalent to the old Sofya
     * <code>SequenceFilter</code> class.
     *
     * @param argv Array of command line parameters.
     * @param sbjout Output stream to which subject's outputs are to be
     * written. If <code>null</code>, <code>System.out</code> is used by
     * default.
     * @param stdout Output stream to which the event dispatcher's normal
     * outputs are to be written. If <code>null</code>, <code>System.out</code>
     * is used by default. When the dispatcher is compiled in
     * <code>DEBUG</code> mode, debug information is also printed to
     * this stream.
     * @param stderr Output stream to which the event dispatcher's error
     * outputs are to be written. If <code>null</code>, <code>System.err</code>
     * is used by default.
     *
     * @return A new event dispatcher, or a reference to the existing
     * singleton instance. An existing instance can be reconfigured, enabling
     * dispatch of multiple event streams.
     *
     * @throws CreateException If the commons-collections library could not be
     * found by the static initializer.
     */
    public static ProgramEventDispatcher createBlockSequenceTracer(
                String[] argv, PrintStream sbjout, PrintStream stdout,
                PrintStream stderr)
            throws CreateException {
        BlockSequenceProcessingStrategy strategy =
            new BlockSequenceProcessingStrategy();
        SequenceTraceWriter traceWriter = new SequenceTraceWriter();
        strategy.addEventListener(traceWriter);

        ProgramEventDispatcher blockTracer = createEventDispatcher(
            strategy, sbjout, stdout, stderr);

        List<String> badParams = blockTracer.configureDispatcher(
            new LinkedList<String>(Arrays.asList(argv)));
        int badCount = badParams.size();
        if (badCount > 0) {
            StringBuilder sb = new StringBuilder();
            Iterator<String> li = badParams.iterator();
            for (int i = badCount; i-- > 0; ) {
                sb.append("'");
                sb.append(li.next());
                sb.append("' ");
            }
            throw new IllegalArgumentException("Unrecognized " +
                "parameter(s): " + sb.toString());
        }

        traceWriter.initialize();

        return blockTracer;
    }

    /*************************************************************************
     * Constructs a ready to run event dispatcher to collect branch
     * coverage traces, equivalent to the old Sofya
     * <code>BranchFilter</code> class.
     *
     * @param argv Array of command line parameters.
     * @param sbjout Output stream to which subject's outputs are to be
     * written. If <code>null</code>, <code>System.out</code> is used by
     * default.
     * @param stdout Output stream to which the event dispatcher's normal
     * outputs are to be written. If <code>null</code>, <code>System.out</code>
     * is used by default. When the dispatcher is compiled in
     * <code>DEBUG</code> mode, debug information is also printed to
     * this stream.
     * @param stderr Output stream to which the event dispatcher's error
     * outputs are to be written. If <code>null</code>, <code>System.err</code>
     * is used by default.
     *
     * @return A new event dispatcher, or a reference to the existing
     * singleton instance. An existing instance can be reconfigured, enabling
     * dispatch of multiple event streams.
     *
     * @throws CreateException If the commons-collections library could not be
     * found by the static initializer.
     */
    public static ProgramEventDispatcher createBranchCoverageTracer(
                String[] argv, PrintStream sbjout, PrintStream stdout,
                PrintStream stderr)
            throws CreateException {
        BranchCoverageProcessingStrategy strategy =
            new BranchCoverageProcessingStrategy();
        TraceHandler traceHandler = new TraceHandler();
        strategy.setCoverageListenerManager(traceHandler);

        ProgramEventDispatcher branchTracer = createEventDispatcher(
            strategy, sbjout, stdout, stderr);

        List<String> badParams = branchTracer.configureDispatcher(
            new LinkedList<String>(Arrays.asList(argv)));
        int badCount = badParams.size();
        if (badCount > 0) {
            StringBuilder sb = new StringBuilder();
            Iterator<String> li = badParams.iterator();
            for (int i = badCount; i-- > 0; ) {
                sb.append("'");
                sb.append(li.next());
                sb.append("' ");
            }
            throw new IllegalArgumentException("Unrecognized " +
                "parameter(s): " + sb.toString());
        }

        traceHandler.setObjectType(TraceObjectType.BRANCH_EDGE);
        traceHandler.setTypeFlags(strategy.getTypeFlags());
        traceHandler.initialize();

        return branchTracer;
    }

    /*************************************************************************
     * Constructs a ready to run event dispatcher to collect branch
     * sequence traces, equivalent to the old Sofya
     * <code>BranchSequenceFilter</code> class.
     *
     * @param argv Array of command line parameters.
     * @param sbjout Output stream to which subject's outputs are to be
     * written. If <code>null</code>, <code>System.out</code> is used by
     * default.
     * @param stdout Output stream to which the event dispatcher's normal
     * outputs are to be written. If <code>null</code>, <code>System.out</code>
     * is used by default. When the dispatcher is compiled in
     * <code>DEBUG</code> mode, debug information is also printed to
     * this stream.
     * @param stderr Output stream to which the event dispatcher's error
     * outputs are to be written. If <code>null</code>, <code>System.err</code>
     * is used by default.
     *
     * @return A new event dispatcher, or a reference to the existing
     * singleton instance. An existing instance can be reconfigured, enabling
     * dispatch of multiple event streams.
     *
     * @throws CreateException If the commons-collections library could not be
     * found by the static initializer.
     */
    public static ProgramEventDispatcher createBranchSequenceTracer(
                String[] argv, PrintStream sbjout, PrintStream stdout,
                PrintStream stderr)
            throws CreateException {
        BranchSequenceProcessingStrategy strategy =
             new BranchSequenceProcessingStrategy();
         SequenceTraceWriter traceWriter = new SequenceTraceWriter();
         strategy.addEventListener(traceWriter);

         ProgramEventDispatcher branchTracer = createEventDispatcher(
            strategy, sbjout, stdout, stderr);

         List<String> badParams = branchTracer.configureDispatcher(
             new LinkedList<String>(Arrays.asList(argv)));
         int badCount = badParams.size();
         if (badCount > 0) {
             StringBuilder sb = new StringBuilder();
             Iterator<String> li = badParams.iterator();
             for (int i = badCount; i-- > 0; ) {
                 sb.append("'");
                 sb.append(li.next());
                 sb.append("' ");
             }
             throw new IllegalArgumentException("Unrecognized " +
                 "parameter(s): " + sb.toString());
         }

         traceWriter.initialize();

         return branchTracer;
    }
}
